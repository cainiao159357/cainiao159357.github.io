<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前言在学习了一段时间的kernelpwn后，发现自己对于操作系统理解的还是十分浅薄，遂想浅浅深入学习一下，然后从a3大佬得知mit的操作系统课程十分之好便下定决心跟着过一遍，本来是想学习mit6.828的，但不管教材还是视频全是洋文，而我的洋文能力着实有限，幸好我找见了mit6.s081版，也在网上找见了翻译版，还有诸多博客可以答疑，感觉可行，那就开干！ 准备git课程使用的是git进行代码管理和">
<meta property="og:type" content="article">
<meta property="og:title" content="mit6.s081">
<meta property="og:url" content="http://example.com/2022/08/09/mit6-s081/index.html">
<meta property="og:site_name" content="study">
<meta property="og:description" content="前言在学习了一段时间的kernelpwn后，发现自己对于操作系统理解的还是十分浅薄，遂想浅浅深入学习一下，然后从a3大佬得知mit的操作系统课程十分之好便下定决心跟着过一遍，本来是想学习mit6.828的，但不管教材还是视频全是洋文，而我的洋文能力着实有限，幸好我找见了mit6.s081版，也在网上找见了翻译版，还有诸多博客可以答疑，感觉可行，那就开干！ 准备git课程使用的是git进行代码管理和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/张鹏/AppData/Roaming/Typora/typora-user-images/image-20220806173357404.png">
<meta property="og:image" content="c:/Users/张鹏/AppData/Roaming/Typora/typora-user-images/image-20220807185230278.png">
<meta property="og:image" content="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c2/p2.png">
<meta property="article:published_time" content="2022-08-09T14:58:21.000Z">
<meta property="article:modified_time" content="2022-08-12T05:49:59.502Z">
<meta property="article:author" content="rootzhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/张鹏/AppData/Roaming/Typora/typora-user-images/image-20220806173357404.png">

<link rel="canonical" href="http://example.com/2022/08/09/mit6-s081/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>mit6.s081 | study</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">study</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/09/mit6-s081/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          mit6.s081
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-09 22:58:21" itemprop="dateCreated datePublished" datetime="2022-08-09T22:58:21+08:00">2022-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-12 13:49:59" itemprop="dateModified" datetime="2022-08-12T13:49:59+08:00">2022-08-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习了一段时间的kernelpwn后，发现自己对于操作系统理解的还是十分浅薄，遂想浅浅深入学习一下，然后从a3大佬得知mit的操作系统课程十分之好便下定决心跟着过一遍，本来是想学习mit6.828的，但不管教材还是视频全是洋文，而我的洋文能力着实有限，幸好我找见了mit6.s081版，也在网上找见了翻译版，还有诸多博客可以答疑，感觉可行，那就开干！</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>课程使用的是git进行代码管理和版本控制的，可笑我到目前为止只熟悉<code>git close</code>,所以再开始之前得了解一下git的命令。</p>
<p>看了几个小时，大概能使用了。</p>
<h3 id="RSIC-V指令集"><a href="#RSIC-V指令集" class="headerlink" title="RSIC-V指令集"></a>RSIC-V指令集</h3><p>……此处省略好多字</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>我使用的是最新的ubuntu22,其实完全不用搜什么搭建环境教程的，课程的网页已经非常清楚了（他推荐的是ubuntu20.4），按照它所述一步一步来就好了，可惜我意识到这一点的时候已经浪费了一两个小时了</p>
<p>准备完环境最激动人心的就是实验调试环境解了，调试我参考的是这篇文章<a target="_blank" rel="noopener" href="https://xistor.github.io/post/6.s081/xv6-gdb/">qemu xv6 使用GDB调试 - xistor’s notes</a></p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220806173357404.png" alt="image-20220806173357404"></p>
<p>我在ls上下了断点，可见成功截住了。</p>
<p>从这篇文章中了解到了关于<del>/.gdbinit文件的使用，可以向这个文件中写入gdb命令，当gdb执行的时候会在当前用户的主目录下寻找<code>.gdbinit</code>文件然后执行其中的命令，当你想要gdb执行不在当前用户的主目录下的<code>.gdbinit</code>的时候，可以在`</del>/.gdbinit<code>文件中导入，例如</code>add-auto-load-safe-path /home/x/xv6-labs-2021/.gdbinit<code>,这样做的话调试的时候就非常方便了，只需要键入</code>gdb-multiarch`就可以直接设置架构并连接qemu了。</p>
<h2 id="Lecture"><a href="#Lecture" class="headerlink" title="Lecture"></a>Lecture</h2><h4 id="Lecture1"><a href="#Lecture1" class="headerlink" title="Lecture1"></a>Lecture1</h4><p>讲了一点操作系统大体作用以及结构，然后通过几个例子示范了系统调用，其中比较有收获的是fork+exec两个系统调用的搭配可以在子进程重新载入一个新程序，所以原来的子进程被完全取代，一般情况下exec函数不会返回。值得注意的是exec()后的程序的文件描述符并没有重置，还是和源程序一样，利用这个特性可以完成一些骚操作。</p>
<p>总体比较简单。这节课有课后实验，我看课程介绍好像可以在本地测试自己的实验并打出分数，吆西，明天看看怎么整。</p>
<h4 id="Lecture3"><a href="#Lecture3" class="headerlink" title="Lecture3"></a>Lecture3</h4><p><strong>隔离性</strong>：操作系统提供进程和进程之间的墙隔离以及进程和硬件资源的强隔离，隔离的手段是进行抽象，提供系统调用接口。</p>
<p><strong>防御性</strong>：首先得具有错误处理能力，如果用户态进程使用系统调用的时候传入了错误的参数，内核得具有处理这种错误的能力，其次是应用程序不能破坏隔离性，这里的隔离指进程和内核的隔离，想要实现这种隔离性得需要硬件支持，比如内核模式和用户模式以及虚拟内存。</p>
<p><strong>user/kernel</strong>:当cpu运行在kernel模式中就会拥有执行特权指令的权限，特权指令指直接操作硬件的指令，相对的运行在user模式只能执行非特权指令，当user模式下执行特权指令时cpu并不会真正去执行，而是从user跳到kernel，内核获得cpu控制权，然后让内核判断user是否出现了问题是否改杀死。</p>
<p><strong>user-&gt;kernel</strong>:有专门的的一个指令可以从user到kernel,在x86下是syscall,在本次课程中的risc-v中是<code>ecall</code>，系统调用号存储在<code>a0</code>寄存器中。</p>
<p><strong>宏内核&amp;微内核</strong>：相比起宏内核，微内核的诸多服务都运行在user模式，在普通进程想要使用这些服务的时候通知内核，内核再通知服务，这样会导致User和kernel的切换比较频繁。</p>
<h2 id="lab"><a href="#lab" class="headerlink" title="lab"></a>lab</h2><h3 id="Lab1-Xv6-and-Unix-utilities"><a href="#Lab1-Xv6-and-Unix-utilities" class="headerlink" title="Lab1: Xv6 and Unix utilities"></a>Lab1: Xv6 and Unix utilities</h3><p>这个实验主要是熟悉xv6的系统调用接口的。</p>
<h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;your parameter is not number\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h4><p>利用pipe完成父子进程之间双向通信，刚开始没理解透pipe,只用了一个管道，发现怎么都不对，看了别人的代码才恍然大雾，pipe只能完成单向通信，双向肯定得要两个管道啊,不过我错误那一版骗过了lab检查程序，乐</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rd 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wt 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p_to_child[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> p_to_parent[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    pipe(p_to_child);</span><br><span class="line">    pipe(p_to_parent);</span><br><span class="line">    <span class="keyword">int</span> pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;fork fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        close(p_to_child[wt]);</span><br><span class="line">        close(p_to_parent[rd]);</span><br><span class="line">        <span class="keyword">int</span> ret=read(p_to_child[rd],buf,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;read fail\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;%d: received ping\n&quot;</span>,getpid());</span><br><span class="line">        ret=write(p_to_parent[wt],<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p_to_child[rd]);</span><br><span class="line">        close(p_to_parent[wt]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        close(p_to_child[rd]);</span><br><span class="line">        close(p_to_parent[wt]);</span><br><span class="line">        <span class="keyword">int</span> ret=write(p_to_child[wt],<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret=read(p_to_parent[rd],buf,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;read fail\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;%d: received pong\n&quot;</span>,getpid());</span><br><span class="line">        close(p_to_child[wt]);</span><br><span class="line">        close(p_to_parent[rd]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h4><p>这个程序还是比较麻烦的，要求利用fork和管道完成对素数的筛选，理论如下</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20220807185230278.png" alt="image-20220807185230278"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rd 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wt 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> p_rd,<span class="keyword">int</span> c_wt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first_num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    read(p_rd,&amp;first_num,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;prime %d\n&quot;</span>,first_num);</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(read(p_rd,&amp;num,<span class="number">4</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(num%first_num!=<span class="number">0</span>)&#123;</span><br><span class="line">            temp++;</span><br><span class="line">            write(c_wt,&amp;num,<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    pipe(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">35</span>;i++)&#123;</span><br><span class="line">        write(p[wt],&amp;i,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">            pipe(c);</span><br><span class="line">            close(p[wt]);</span><br><span class="line">            <span class="keyword">int</span> ret=fun(p[rd],c[wt]);</span><br><span class="line">            close(p[rd]);</span><br><span class="line">            <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[rd]=c[rd];</span><br><span class="line">            p[wt]=c[wt];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[wt])&#123;</span><br><span class="line">                close(p[wt]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p[rd])&#123;</span><br><span class="line">                close(p[rd]);</span><br><span class="line">            &#125;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span>(status==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;wait fail\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>这个调了我半个早上🤦‍♀️，首先是程序退出时报错，我试了半天才发现xv6系统的main函数只能以exit()退出，其次是测试程序老是过不去，多方调试后发现自己的一块逻辑写的有明显问题，呜呜呜这明明只是中等难度，代码能力还是太菜了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *file_path,<span class="keyword">char</span> *res)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    memmove(buf,file_path,<span class="built_in">strlen</span>(file_path));</span><br><span class="line">    <span class="keyword">int</span> fd=open(file_path,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;open fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (read(fd,&amp;de,<span class="keyword">sizeof</span>(de))==<span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">        <span class="keyword">if</span>(de.inum==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(de.name,<span class="string">&quot;.&quot;</span>)||!<span class="built_in">strcmp</span>(de.name,<span class="string">&quot;..&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p=buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">        memmove(p, de.name, DIRSIZ);</span><br><span class="line">        <span class="keyword">if</span>(stat(buf,&amp;st)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;stat() fail filename :%s\n&quot;</span>,buf);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.type==T_FILE)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(de.name,res))&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">1</span>,<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (st.type==T_DIR)</span><br><span class="line">        &#123;</span><br><span class="line">            p=buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">            *p=<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            find(buf,res);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">         memmove(buf,file_path,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;parameter fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(buf,argv[<span class="number">1</span>],DIRSIZ);</span><br><span class="line">    p=buf+<span class="built_in">strlen</span>(buf)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*p!=<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">        p++;</span><br><span class="line">        *p=<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    find(buf,argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><p>主要麻烦的点在对字符串的处理上，我看别人的博客利用了有限自动机，嘿嘿，不会这个高端的东西，我的解决办法是对得到的字符串进行标准化，然后就利于后面的字符串处理了(无脑做法属于)。还有我的代码能力真得弱，这点代码花了我两个小时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_line_length</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> line_length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(buf[line_length]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">        line_length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> line_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> line_num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;argv fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size=read(<span class="number">0</span>,buf,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">char</span> parm_buf[size+<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">memset</span>(parm_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(parm_buf));</span><br><span class="line">    cur++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size; i++,cur++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(buf[i]==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">            cur++;</span><br><span class="line">            parm_buf[cur]=<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            line_num++;</span><br><span class="line">            cur++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parm_buf[cur]=buf[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(buf[size<span class="number">-1</span>]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">        line_num++;</span><br><span class="line">    &#125;</span><br><span class="line">    cur=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;line_num;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> add_parm_num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp_cur=cur;</span><br><span class="line">        <span class="keyword">for</span>(;parm_buf[temp_cur]!=<span class="string">&#x27;\n&#x27;</span>;temp_cur++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parm_buf[temp_cur]==<span class="number">0</span>&amp;&amp;parm_buf[temp_cur+<span class="number">1</span>]!=<span class="number">0</span>&amp;&amp;parm_buf[temp_cur+<span class="number">1</span>]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                add_parm_num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> *parm[add_parm_num+argc];</span><br><span class="line">        <span class="built_in">memset</span>(parm,<span class="number">0</span>,<span class="keyword">sizeof</span>(parm));</span><br><span class="line">        <span class="keyword">int</span> parm_cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;argc;j++,parm_cur++)&#123;</span><br><span class="line">            parm[parm_cur]=argv[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;parm_buf[cur]!=<span class="string">&#x27;\n&#x27;</span>;cur++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parm_buf[cur]==<span class="number">0</span>&amp;&amp;parm_buf[cur+<span class="number">1</span>]!=<span class="number">0</span>&amp;&amp;parm_buf[cur+<span class="number">1</span>]!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                parm[parm_cur]=&amp;parm_buf[cur+<span class="number">1</span>];</span><br><span class="line">                parm_cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;</span><br><span class="line">        <span class="keyword">int</span> pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">            exec(parm[<span class="number">0</span>],parm);</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;exec fail\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span>(status==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot; wait fail\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最后lab得分"><a href="#最后lab得分" class="headerlink" title="最后lab得分"></a>最后lab得分</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score: 100/100</span><br></pre></td></tr></table></figure>

<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>在xv6操作系统上编程很奇妙也很有意思。</p>
<h3 id="Lab2-system-calls"><a href="#Lab2-system-calls" class="headerlink" title="Lab2: system calls"></a>Lab2: system calls</h3><p>这个实验主要是为了理解系统调用的工作流程，并为xv6增加一些新的系统调用。</p>
<h4 id="book-read"><a href="#book-read" class="headerlink" title="book-read"></a>book-read</h4><p><strong>trap</strong>:有三种时间导致cpu搁置普通指令的执行，强制将控制权转移给处理该事件的特殊代码上，一种情况是系统调用使用<code>ecall</code>的时候，一种是异常，比如user/kernel指令做了一些非法的事情如除零，第三种是设备中断，这三种情况被统称为<code>trap</code>,xv6内核处理所有的trap.</p>
<p><strong>risc-v陷入机制</strong>:risc-v架构的cpu都有一组控制寄存器，kernel通过向这些寄存器写入内容来使cpu处理trap</p>
<p>下面是重要的寄存器</p>
<blockquote>
<p><code>stvec</code>:内核在这里写入trap处理程序的地址，risc-v跳转到这里处理trap</p>
<p><code>sepc</code>:当发生trap时，risc-v会保存原来<code>pc</code>的信息到<code>sepc</code>,<code>sret</code>(从陷阱返回)指令就会将<code>sepc</code>复制到<code>pc</code>,内核可以写入<code>sepc</code>来控制<code>sret</code>的去向。</p>
<p><code>scause</code>:risc-v在这里防止描述trap原因的数字</p>
<p><code>sscratch</code>:内核在这里放置一个值，这个值在trap处理程序一开始就会派上用场。</p>
<p><code>sstatus</code>:其中的<code>SIE</code>位控制设备中断是否启动，<code>SPP</code>位指示trap是来自user-mode还是kernel-mode,并控制<code>sret</code>返回的模式</p>
</blockquote>
<p>risc-v硬件对所有trap(除了计时器中断)执行以下操作</p>
<blockquote>
<ol>
<li>如果陷阱是设备中断，并且状态<strong>SIE</strong>位被清空，则不执行以下任何操作。</li>
<li>清除<strong>SIE</strong>以禁用中断。</li>
<li>将<code>pc</code>复制到<code>sepc</code>。</li>
<li>将当前模式（用户或管理）保存在状态的<strong>SPP</strong>位中。</li>
<li>设置<code>scause</code>以反映产生陷阱的原因。</li>
<li>将模式设置为管理模式。</li>
<li>将<code>stvec</code>复制到<code>pc</code>。</li>
<li>在新的<code>pc</code>上开始执行。</li>
</ol>
</blockquote>
<p>可见cpu硬件只会执行这些操作，当控制权给到内核的时候，得要内核自己完成对内核页表的切换，对内核栈的切换，然后进入对trap真正处理的函数上，对除了<code>pc</code>以外所有寄存器的保存。</p>
<p><strong>从用户空间陷入</strong></p>
<p><img src="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c2/p2.png" alt="img"></p>
<p>总体分为四步调用，<code>uservec</code>,<code>usertrap</code>,<code>usertrapret</code>和<code>userret</code>。</p>
<p><strong>uservec</strong></p>
<p><code>uservec</code>代码处于<code>kernel/trampoline.S</code>中，一猜就是用汇编写的，因为控制单位到了寄存器量级，但是是risc-v捏，看不太懂。如上面所说，kernel-mode得完成那些操作才可以进入对trap真正处理的函数上（<code>usertrap</code>），而这些操作都被放置在<code>uservec</code>中，即刚开始的<code>stvec</code>指向了<code>uservec</code>,但是刚进入kernel-mode的时候<code>satp</code>并没有指向<code>kernel-page</code>,而是在<code>user-page</code>中，要想执行<code>uservec</code>则必须在用户页表中也映射上,在<code>uservec</code>中会切换<code>satp</code>以指向内核页表，所以为了在切换后继续执行指令，<code>uservec</code>必须在内核页表和用户页表中映射相同的地址。</p>
<p>为此xv6专门设置了一个页面放置<code>uservec</code>代码，然后把这个页面映射到内核页表和所有的用户页表中，且虚拟地址全部相同，这个虚拟地址就是上图的<code>trampoline</code>,在user-mode时stvec就指向了<code>trampoline</code>即<code>userevc</code>。</p>
<p>到这里我觉得十分合理，可能x86也是这样干的，当<code>userevc</code>启动的时候，所有的32个寄存器都保存着原来中断代码的值，不能够随意更改，但<code>userevc</code>需要能够使用一些寄存器才能完成他的功能，risc-v的<code>sscratch</code>就发挥了作用，<code>userevc</code>开始的时候通过指令<code>csrrw</code>交换了<code>a0</code>和<code>sscratch</code>的内容，此时<code>a0</code>寄存器的值就被保存了，<code>uservec</code>就可以使用<code>a0</code>寄存器了。</p>
<p>具体该怎么保存所有的寄存器的值，就牵扯到了另一个机制<code>陷阱帧</code>，如上图所示，陷阱帧就是<code>trapframe</code>,该帧有保存用户所有的寄存器的空间。此时<code>satp</code>还是指向了用户页表，所以要使用这个陷阱帧还得把他映射到用户页表中，<code>sscratch</code>就指向了这个陷阱帧，执行完<code>csrrw</code>后<code>a0</code>寄存器就指向了陷阱帧，然后<code>uservec</code>就利用a0把所有用户寄存器保存在陷阱帧，陷阱帧中还包含了指向当前进程内核栈的指针，当前cpu的<code>hartid</code>,<code>usertrap</code>的地址以及内核页表的地址，<code>uservec</code>就取得这些值，将<code>satp</code>切换到内核页表，并调用<code>usertrap</code>。</p>
<p><strong>usertrap</strong></p>
<p>下面是xv6 usertrap代码</p>
<p>代码比较清晰，首先会检查上一个模式是什么，然后设置<code>stvec</code>,因为此时cpu已经处于内核态了，当发生trap时得执行内核的<code>kernelvec</code>而不是<code>suervec</code>,所以会把<code>stvec</code>指向<code>kernelvec</code>,然后保存了sepc到p-&gt;trapframe-&gt;sepc中防止被覆盖，然后判断trap的类型，如果是系统调用<code>syscall()</code>会处理，如果是设备中断，<code>devintr</code>会处理他，否则就是一个异常，就设置<code>p-&gt;killed=1</code>,代表会被杀死，最后内核检查进程是否应该被杀死或者因为时钟中断让出cpu,最后调用<code>usertrapret</code>,流程比起<code>uservec</code>好理解多了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">usertrap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>usertrapret</strong></p>
<p>首先是获得进程的proc结构体，然后是<code>intr_off</code>设置了sstatus的<code>sie</code>位，然后是设置了<code>stvec</code>，因为要返回用户态了，所以trap处理程序变成了<code>uservec</code>,然后是在陷阱帧中记录内核页表地址，sp地址，<code>usertrap</code>地址，以及<code>hartid</code>。然后是设置sstatus的ssp位，把上一个模式设置为user-mode,然后是设置sepc得到用户态页表地址，然后又跳回<code>trampoline</code>中执行<code>userret</code>,至于为什么要把<code>userret</code>函数放置在<code>trampoline</code>中，是因为<code>userret</code>中会切换页表。要想切换完页表还能继续执行<code>userret</code>只能把他放在<code>trampoline</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">usertrapret</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="keyword">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>userret</strong></p>
<p>a1保存的是用户态页表地址，a0保存的是<code>trampoline</code>地址，首先切换页表，然后从陷阱帧中恢复用户寄存器，最后调用<code>sret</code>完成对用户态的切换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(TRAPFRAME, pagetable)</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # usertrapret() calls here.</span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, for satp.</span><br><span class="line"></span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # put the saved user a0 in sscratch, so we</span><br><span class="line">        # can swap it with our a0 (TRAPFRAME) in the last step.</span><br><span class="line">        ld t0, 112(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        ld gp, 56(a0)</span><br><span class="line">        ld tp, 64(a0)</span><br><span class="line">        ld t0, 72(a0)</span><br><span class="line">        ld t1, 80(a0)</span><br><span class="line">        ld t2, 88(a0)</span><br><span class="line">        ld s0, 96(a0)</span><br><span class="line">        ld s1, 104(a0)</span><br><span class="line">        ld a1, 120(a0)</span><br><span class="line">        ld a2, 128(a0)</span><br><span class="line">        ld a3, 136(a0)</span><br><span class="line">        ld a4, 144(a0)</span><br><span class="line">        ld a5, 152(a0)</span><br><span class="line">        ld a6, 160(a0)</span><br><span class="line">        ld a7, 168(a0)</span><br><span class="line">        ld s2, 176(a0)</span><br><span class="line">        ld s3, 184(a0)</span><br><span class="line">        ld s4, 192(a0)</span><br><span class="line">        ld s5, 200(a0)</span><br><span class="line">        ld s6, 208(a0)</span><br><span class="line">        ld s7, 216(a0)</span><br><span class="line">        ld s8, 224(a0)</span><br><span class="line">        ld s9, 232(a0)</span><br><span class="line">        ld s10, 240(a0)</span><br><span class="line">        ld s11, 248(a0)</span><br><span class="line">        ld t3, 256(a0)</span><br><span class="line">        ld t4, 264(a0)</span><br><span class="line">        ld t5, 272(a0)</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<p>借助从用户态的陷入终于理清了xv6的用户态和内核态的转换了，受益匪浅。</p>
<p><strong>调用系统调用</strong></p>
<p><code>syscall</code>代码如下，代码简略清晰，就以<code>exec</code>调用位例子，两个参数分别存放在a0,和a1中，然后把系统调用号放在a7中，系统调用号就是<code>syscall[]</code>的下标，寻找到的值就是该系统调用的处理函数，<code>exec</code>系统调用最后就会调用<code>sys_exec</code>。此时会有个疑问，系统调用都是有参数的，为什么最后的<code>p-&gt;trapframe-&gt;a0 = syscalls[num]();</code>没有呢，我大概看了<code>sys_exec</code>的代码，发现他是直接从陷阱帧中取寄存器值的，而不是传参。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="keyword">void</span>)</span> </span>= &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>系统调用参数</strong></p>
<p>好家伙，我刚有这个疑问，书的下一节就解释这个问题，牛啊。</p>
<p>系统提供三个函数artint,artaddr,artfd从陷阱帧中检索第<code>n</code>个系统调用参数并且以整数，指针，或者文件描述符的形式保存，他们都调用<code>argraw</code>来检索相应的保存的用户寄存器。比如<code>argstr</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">argstr(<span class="keyword">int</span> n, <span class="keyword">char</span> *buf, <span class="keyword">int</span> max)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(n, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> fetchstr(addr, buf, max);</span><br><span class="line">&#125;</span><br><span class="line">argaddr(<span class="keyword">int</span> n, uint64 *ip)</span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核要想获得一个整数还行，但是要想获得用户态的某一个字符串或者某一段内存的值就不好办了，因为此时处于内核态，页表是内核页表，并不能访问用户态的内存，可以看看xv6是如何完成的。</p>
<p><code>copyinstr</code>函数就是完成在内核态从用户态到内核态拷贝数据的函数，传入的参数有进程的陷阱帧，内核接收地址dst和用户态地址srcva以及拷贝量max。我简述一下原理，就是利用传进来的用户态虚拟地址srcva和进程的陷阱帧完成对这个虚拟地址所映射的物理地址<code>pa0</code>的查询，查询过程就是利用陷阱帧记录的用户态页表，然后通过这个虚拟地址找到对应物理地址返回，在内核态中，由于内核将所有物理RAM地址映射到同一个内核虚拟地址，<code>copyinstr</code>可以直接将字符串字节从<code>pa0</code>复制到<code>dst</code>（这段其实不是很理解，我不确定这个pa0到底是不是物理地址，如果是的话<code>copyinstr</code>直接使用物理地址进行copy<code>*dst = *p</code>,那唯一的解释就是映射是直接映射，即虚拟地址和物理地址是一一对应的才可以）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">copyinstr(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">char</span> *dst, uint64 srcva, uint64 max)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="keyword">int</span> got_null = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(got_null == <span class="number">0</span> &amp;&amp; max &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (srcva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; max)</span><br><span class="line">      n = max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *) (pa0 + (srcva - va0));</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(*p == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        *dst = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        got_null = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *dst = *p;</span><br><span class="line">      &#125;</span><br><span class="line">      --n;</span><br><span class="line">      --max;</span><br><span class="line">      p++;</span><br><span class="line">      dst++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    srcva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(got_null)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在qemu下打印页表发现似乎就是这样的,映射了个寂寞🤦‍♀️，在linux系统中内核好歹是线性映射所有物理区域，xv6直接一对一了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vaddr            paddr            size             attr</span><br><span class="line">---------------- ---------------- ---------------- -------</span><br><span class="line">0000000002000000 0000000002000000 0000000000010000 rw-----</span><br><span class="line">000000000c000000 000000000c000000 0000000000001000 rw---ad</span><br><span class="line">000000000c001000 000000000c001000 0000000000001000 rw-----</span><br><span class="line">000000000c002000 000000000c002000 0000000000001000 rw---ad</span><br><span class="line">000000000c003000 000000000c003000 00000000001fe000 rw-----</span><br><span class="line">000000000c201000 000000000c201000 0000000000001000 rw---ad</span><br><span class="line">000000000c202000 000000000c202000 0000000000001000 rw-----</span><br><span class="line">000000000c203000 000000000c203000 0000000000001000 rw---ad</span><br><span class="line">000000000c204000 000000000c204000 0000000000001000 rw-----</span><br><span class="line">000000000c205000 000000000c205000 0000000000001000 rw---ad</span><br><span class="line">000000000c206000 000000000c206000 00000000001fa000 rw-----</span><br><span class="line">0000000010000000 0000000010000000 0000000000002000 rw---ad</span><br><span class="line">0000000080000000 0000000080000000 0000000000007000 r-x--a-</span><br><span class="line">0000000080007000 0000000080007000 0000000000001000 r-x----</span><br><span class="line">0000000080008000 0000000080008000 0000000000005000 rw---ad</span><br><span class="line">000000008000d000 000000008000d000 0000000000004000 rw-----</span><br><span class="line">0000000080011000 0000000080011000 0000000000011000 rw---ad</span><br><span class="line">0000000080022000 0000000080022000 0000000000001000 rw-----</span><br><span class="line">0000000080023000 0000000080023000 0000000000003000 rw---ad</span><br><span class="line">0000000080026000 0000000080026000 0000000007f35000 rw-----</span><br><span class="line">0000000087f5b000 0000000087f5b000 000000000005d000 rw---ad</span><br><span class="line">0000000087fb8000 0000000087fb8000 0000000000001000 rw---a-</span><br><span class="line">0000000087fb9000 0000000087fb9000 0000000000046000 rw-----</span><br><span class="line">0000000087fff000 0000000087fff000 0000000000001000 rw---a-</span><br><span class="line">0000003ffff7f000 0000000087f77000 000000000003e000 rw-----</span><br><span class="line">0000003fffffb000 0000000087fb5000 0000000000002000 rw---ad</span><br><span class="line">0000003ffffff000 0000000080007000 0000000000001000 r-x--a-</span><br></pre></td></tr></table></figure>

<h5 id="从内核态陷入"><a href="#从内核态陷入" class="headerlink" title="从内核态陷入"></a>从内核态陷入</h5><p>书中涉及到了计数器中断的处理办法，由于我不是很熟悉计数器中断，所以暂且不讨论这种情况，在第七章中会系统的学到。我只讨论一般情况下的内核陷入。</p>
<p>内核发生陷入的话只有两种情况，一是设备中断，二是内核异常，此时是处于内核态的，<code>stvec</code>就指向了<code>kernelvec</code>,然后处理trap也是在内核态，所以不需要切换页表了。处理流程主要是两个函数：<code>kernelvec</code>-&gt;<code>kerneltrap</code>-&gt;<code>kernelvec</code></p>
<p><strong>kernelvec</strong></p>
<p>意料之中又是risc-v汇编捏，但是大概是能看懂的，kernelvec首先得把所有的寄存器存放到当前内核栈的栈上，所以首先<code>addi sp.sp,-256</code>就是<code>sp=sp+(-256)</code>，先提升栈的容量。然后把寄存器放在这256容量的栈里，<code>sd ra,0(sp)</code>等于<code>*[sp+0]=ra</code>这样的形式存储，至于为什么要存储所有的寄存器，是因为在调用<code>kerneltrap</code>的时候，会因为时钟中断而让出cpu导致丢失寄存器信息，所以得记录一下，记录完就是调用<code>kerneltrap</code>了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">        # interrupts and exceptions while in supervisor</span><br><span class="line">        # mode come here.</span><br><span class="line">        #</span><br><span class="line">        # push all registers, call kerneltrap(), restore, return.</span><br><span class="line">        #</span><br><span class="line">.globl kerneltrap</span><br><span class="line">.globl kernelvec</span><br><span class="line">.align 4</span><br><span class="line">kernelvec:</span><br><span class="line">        // make room to save registers.</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">        // save the registers.</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">        sd sp, 8(sp)</span><br><span class="line">        sd gp, 16(sp)</span><br><span class="line">        sd tp, 24(sp)</span><br><span class="line">        sd t0, 32(sp)</span><br><span class="line">        sd t1, 40(sp)</span><br><span class="line">        sd t2, 48(sp)</span><br><span class="line">        sd s0, 56(sp)</span><br><span class="line">        sd s1, 64(sp)</span><br><span class="line">        sd a0, 72(sp)</span><br><span class="line">        sd a1, 80(sp)</span><br><span class="line">        sd a2, 88(sp)</span><br><span class="line">        sd a3, 96(sp)</span><br><span class="line">        sd a4, 104(sp)</span><br><span class="line">        sd a5, 112(sp)</span><br><span class="line">        sd a6, 120(sp)</span><br><span class="line">        sd a7, 128(sp)</span><br><span class="line">        sd s2, 136(sp)</span><br><span class="line">        sd s3, 144(sp)</span><br><span class="line">        sd s4, 152(sp)</span><br><span class="line">        sd s5, 160(sp)</span><br><span class="line">        sd s6, 168(sp)</span><br><span class="line">        sd s7, 176(sp)</span><br><span class="line">        sd s8, 184(sp)</span><br><span class="line">        sd s9, 192(sp)</span><br><span class="line">        sd s10, 200(sp)</span><br><span class="line">        sd s11, 208(sp)</span><br><span class="line">        sd t3, 216(sp)</span><br><span class="line">        sd t4, 224(sp)</span><br><span class="line">        sd t5, 232(sp)</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">	// call the C trap handler in trap.c</span><br><span class="line">        call kerneltrap</span><br><span class="line"></span><br><span class="line">        // restore registers.</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        ld gp, 16(sp)</span><br><span class="line">        // not this, in case we moved CPUs: ld tp, 24(sp)</span><br><span class="line">        ld t0, 32(sp)</span><br><span class="line">        ld t1, 40(sp)</span><br><span class="line">        ld t2, 48(sp)</span><br><span class="line">        ld s0, 56(sp)</span><br><span class="line">        ld s1, 64(sp)</span><br><span class="line">        ld a0, 72(sp)</span><br><span class="line">        ld a1, 80(sp)</span><br><span class="line">        ld a2, 88(sp)</span><br><span class="line">        ld a3, 96(sp)</span><br><span class="line">        ld a4, 104(sp)</span><br><span class="line">        ld a5, 112(sp)</span><br><span class="line">        ld a6, 120(sp)</span><br><span class="line">        ld a7, 128(sp)</span><br><span class="line">        ld s2, 136(sp)</span><br><span class="line">        ld s3, 144(sp)</span><br><span class="line">        ld s4, 152(sp)</span><br><span class="line">        ld s5, 160(sp)</span><br><span class="line">        ld s6, 168(sp)</span><br><span class="line">        ld s7, 176(sp)</span><br><span class="line">        ld s8, 184(sp)</span><br><span class="line">        ld s9, 192(sp)</span><br><span class="line">        ld s10, 200(sp)</span><br><span class="line">        ld s11, 208(sp)</span><br><span class="line">        ld t3, 216(sp)</span><br><span class="line">        ld t4, 224(sp)</span><br><span class="line">        ld t5, 232(sp)</span><br><span class="line">        ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        // return to whatever we were doing in the kernel.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<p><strong>kerneltrap</strong></p>
<p>首先是储存<code>sepc</code>和<code>sstatus</code>两个寄存器，因为如果有时钟中断而调用<code>yield()</code>函数的时候会破坏他们，要使破坏了他们trap返回的时候就会出问题，保存完后真正处理trap，处理完之后恢复<code>sepc</code>和<code>sstatus</code>，然后返回到函数<code>kernelvec</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">kerneltrap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the yield() may have caused some traps to occur,</span></span><br><span class="line">  <span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span></span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回到kernelvec中就会简单了，就利用栈信息恢复通用寄存器，然后<code>addi sp, sp, 256</code>后<code>sret</code>结束内核陷入。</p>
<p>总而言之比用户态陷入要简单很多了。</p>
<h5 id="页面错误异常"><a href="#页面错误异常" class="headerlink" title="页面错误异常"></a>页面错误异常</h5><p>这个暂时不看，涉及到了第三章的知识，暂时还没有学习到。</p>
<h4 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h4><p>就是增加一个系统调用追踪的功能，可以先利用这个系统调用设置自己想要追踪的系统调用，然后这个程序以及子程序在调用这个系统调用的时候都会打印相应数据。</p>
<p>编程不是难点，难点可能是理清楚系统调用的原理以及对应的几个c文件就好了，只要阅读过书籍的第四章问题就不大的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trace_printf_sysname</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">  <span class="keyword">int</span> mask=p-&gt;trace_num;</span><br><span class="line">  <span class="keyword">int</span> sys_num=p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(mask&amp;(<span class="number">1</span>&lt;&lt;sys_num))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid,syscall_name[sys_num],p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_trace</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mask;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>,&amp;mask)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;trace_num=mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h4><p>这个系统调用个就比较麻烦了，首先得把结构体从<code>struct sysinfo</code>从内核态拷贝回用户空间，然后得在内核获得空闲内存量，然后还得获得<code>stat</code>不为<code>UNUSED</code>的进程数。都没怎么听过，得阅读源码慢慢搞清楚。</p>
<p>从内核态拷贝数据使用的是<code>copyout</code>函数,之前分析过<code>copyin</code>函数，原理都是差不多的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copyout</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="keyword">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获得内存空闲字节课以通过阅读<code>kmalloc.c</code>源码很好的解决,在xv6系统中定义了两个结构体来管理空闲页面其中通过<code>struct run</code>组成一个单向链表来链接所有的空闲链表，然后通过<code>struct kmem.freelist</code>指向这个链表的头结点，所以只需要遍历这个链表就可以所有空闲页面了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>

<p>在<code>struct proc</code>中有一个字段<code>struct proc *parent</code>可以通过遍历这个字段完成对进程数的统计，这种统计方式肯定有问题，因为一个进程可以有多个子进程，这个办法每一层进程只能遍历一个，与其说统计有多少个进程，不如说统计有多少层进程，当然这也是<code>struct proc</code>的设计问题，只能这样干。</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sysinfo</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  uint64 user_info;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>,&amp;user_info)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sysinfo addr get fail\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  info.freemem=countfree();</span><br><span class="line">  info.nproc=get_proc_num();</span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable,user_info,(<span class="keyword">char</span> *)&amp;info,<span class="keyword">sizeof</span>(info))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> </span></span><br><span class="line"><span class="function"><span class="title">countfree</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  r=kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(r)&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;page_addr:%p\n&quot;,r);</span></span><br><span class="line">    n=n+<span class="number">4096</span>;</span><br><span class="line">    r=r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_proc_num</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">  <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;parent)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state!=UNUSED)&#123;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">    p=p-&gt;parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="得分"><a href="#得分" class="headerlink" title="得分"></a>得分</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score: 35/35</span><br></pre></td></tr></table></figure>

<h4 id="结语-1"><a href="#结语-1" class="headerlink" title="结语"></a>结语</h4><p>对系统调用理解的更深了吧，之前只知道大概思想，现在也知道了如何实现的，也对xv6的用户态和内核态的切换更加熟悉，也更加了解了xv6的源代码。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/26/kernelpwn-%E5%86%8D%E5%85%A5%E9%97%A8/" rel="prev" title="kernelpwn 再入门">
      <i class="fa fa-chevron-left"></i> kernelpwn 再入门
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/12/%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B-Smurfs%E5%A4%8D%E7%8E%B0/" rel="next" title="蓝帽杯半决赛 Smurfs复现">
      蓝帽杯半决赛 Smurfs复现 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%86%E5%A4%87"><span class="nav-number">2.</span> <span class="nav-text">准备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#git"><span class="nav-number">2.1.</span> <span class="nav-text">git</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RSIC-V%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="nav-number">2.2.</span> <span class="nav-text">RSIC-V指令集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="nav-number">2.3.</span> <span class="nav-text">环境准备</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lecture"><span class="nav-number">3.</span> <span class="nav-text">Lecture</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Lecture1"><span class="nav-number">3.0.1.</span> <span class="nav-text">Lecture1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lecture3"><span class="nav-number">3.0.2.</span> <span class="nav-text">Lecture3</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lab"><span class="nav-number">4.</span> <span class="nav-text">lab</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab1-Xv6-and-Unix-utilities"><span class="nav-number">4.1.</span> <span class="nav-text">Lab1: Xv6 and Unix utilities</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sleep"><span class="nav-number">4.1.1.</span> <span class="nav-text">sleep</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pingpong"><span class="nav-number">4.1.2.</span> <span class="nav-text">pingpong</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#primes"><span class="nav-number">4.1.3.</span> <span class="nav-text">primes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#find"><span class="nav-number">4.1.4.</span> <span class="nav-text">find</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xargs"><span class="nav-number">4.1.5.</span> <span class="nav-text">xargs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%90%8Elab%E5%BE%97%E5%88%86"><span class="nav-number">4.1.6.</span> <span class="nav-text">最后lab得分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-number">4.1.7.</span> <span class="nav-text">结语</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab2-system-calls"><span class="nav-number">4.2.</span> <span class="nav-text">Lab2: system calls</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#book-read"><span class="nav-number">4.2.1.</span> <span class="nav-text">book-read</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E5%86%85%E6%A0%B8%E6%80%81%E9%99%B7%E5%85%A5"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">从内核态陷入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E9%94%99%E8%AF%AF%E5%BC%82%E5%B8%B8"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">页面错误异常</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#System-call-tracing"><span class="nav-number">4.2.2.</span> <span class="nav-text">System call tracing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sysinfo"><span class="nav-number">4.2.3.</span> <span class="nav-text">Sysinfo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%97%E5%88%86"><span class="nav-number">4.2.4.</span> <span class="nav-text">得分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD-1"><span class="nav-number">4.2.5.</span> <span class="nav-text">结语</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rootzhang</p>
  <div class="site-description" itemprop="description">我的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rootzhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
