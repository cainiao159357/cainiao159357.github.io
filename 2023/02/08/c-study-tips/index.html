<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="c++ study tips记录一些学习c++过程中的小问题或者有意思的点。 互相引用A和B两个头文件互相引用在c++中会报错，因为可能会发生超前引用问题，超前引用是指使用了一个只声明了但没有定义的类型来声明一个变量，也就是还没有定义只声明了就使用它来创建变量，编译器是不会允许通过的。 解决办法就是在A的头文件中includeB，然后在A的.h文件中就能正常使用B了，但是在B的.h文件中不能inc">
<meta property="og:type" content="article">
<meta property="og:title" content="c++ study tips">
<meta property="og:url" content="http://example.com/2023/02/08/c-study-tips/index.html">
<meta property="og:site_name" content="study">
<meta property="og:description" content="c++ study tips记录一些学习c++过程中的小问题或者有意思的点。 互相引用A和B两个头文件互相引用在c++中会报错，因为可能会发生超前引用问题，超前引用是指使用了一个只声明了但没有定义的类型来声明一个变量，也就是还没有定义只声明了就使用它来创建变量，编译器是不会允许通过的。 解决办法就是在A的头文件中includeB，然后在A的.h文件中就能正常使用B了，但是在B的.h文件中不能inc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/张鹏/AppData/Roaming/Typora/typora-user-images/image-20230204002217162.png">
<meta property="article:published_time" content="2023-02-08T10:56:58.000Z">
<meta property="article:modified_time" content="2023-02-08T12:40:35.752Z">
<meta property="article:author" content="rootzhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/张鹏/AppData/Roaming/Typora/typora-user-images/image-20230204002217162.png">

<link rel="canonical" href="http://example.com/2023/02/08/c-study-tips/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>c++ study tips | study</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">study</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/08/c-study-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          c++ study tips
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-08 18:56:58 / 修改时间：20:40:35" itemprop="dateCreated datePublished" datetime="2023-02-08T18:56:58+08:00">2023-02-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="c-study-tips"><a href="#c-study-tips" class="headerlink" title="c++ study tips"></a>c++ study tips</h1><p>记录一些学习c++过程中的小问题或者有意思的点。</p>
<h2 id="互相引用"><a href="#互相引用" class="headerlink" title="互相引用"></a>互相引用</h2><p>A和B两个头文件互相引用在c++中会报错，因为可能会发生超前引用问题，超前引用是指使用了一个只声明了但没有定义的类型来声明一个变量，也就是还没有定义只声明了就使用它来创建变量，编译器是不会允许通过的。</p>
<p>解决办法就是在A的头文件中includeB，然后在A的.h文件中就能正常使用B了，但是在B的.h文件中不能includeA,只能声明一个class A,然后也不能声明一个A的对象比如<code>A a</code>,只能声明一个A的指针<code>A *a</code>。但是在B的.cpp文件中可以includeA来使用A的一些声明。</p>
<p>至于为什么可以声明指针但不能声明对象是因为此时对B来说A只声明了没有定义不知道A的大小所以没有办法确定A的大小，但是指针始终是8个字节可以确定，所以可以声明一个指针。</p>
<p>不得不说c++是真的饶啊。</p>
<h2 id="指针类"><a href="#指针类" class="headerlink" title="指针类"></a>指针类</h2><p>顾名思义就是某一个类的指针类，这个指针类并不是一个真的指针，而是会封装这个类的一些指针操作，然后通过这个指针类来操作这个类的数据会更加方便一些，比如容器和迭代器就是类和指针类。</p>
<h2 id="返回局部变量"><a href="#返回局部变量" class="headerlink" title="返回局部变量"></a>返回局部变量</h2><p>众所周知函数不能返回自己的局部变量的地址，但是比较我比较疑惑的是为什么可以返回一个局部对象，经过查阅得知当返回一个局部对象的时候并不是返回局部对象本身，而是将返回对象拷贝到函数调用点，所以返回的是一个副本，这个副本的作用域不是这个函数的，而是调用这个函数的函数的。</p>
<h2 id="智能指针初始化"><a href="#智能指针初始化" class="headerlink" title="智能指针初始化"></a>智能指针初始化</h2><p>默认初始化一个智能指针,然后使用程序就会报错，报错的原因是默认初始化的只能指针中保存着一个空指针，既然是空指针那就肯定不能使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    shared_ptr&lt;vector&lt;string&gt;&gt; word;</span><br><span class="line">    word-&gt;<span class="built_in">push_back</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> beg=word-&gt;<span class="built_in">begin</span>();</span><br><span class="line">    cout&lt;&lt;*beg&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用make_shared进行初始化才可以使用，比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    shared_ptr&lt;vector&lt;string&gt;&gt; word= make_shared&lt;vector&lt;string&gt;&gt;();</span><br><span class="line">    word-&gt;<span class="built_in">push_back</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> beg=word-&gt;<span class="built_in">begin</span>();</span><br><span class="line">    cout&lt;&lt;*beg&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非const引用与临时变量问题"><a href="#非const引用与临时变量问题" class="headerlink" title="非const引用与临时变量问题"></a>非const引用与临时变量问题</h2><p>首先得说明一下临时变量和局部变量的区别，局部变量指在函数内显示声明的变量称为局部变量，所以局部变量都是有变量名的，相对于的临时变量虽然也是函数内声明的变量但是这个变量没有变量名的，局部变量很容易理解，临时变量通常在函数参数传递发生类型转换以及函数返回值时被创建。</p>
<p>  当一个函数的形参为非const类型，而一个参数以非const传入，编译器一般会认为程序员会在该函数里修改该参数，而且该参数返回后还会发挥作用。此时如果你把一个临时变量当成非const引用传进来，由于临时变量的特殊性，程序员无法对改临时变量进行操作，同时临时变量可能随时会消失，修改临时变量也毫无意义，因此，临时变量不能作为非const引用。</p>
<p>比如下面的代码,uppercasify()函数的参数是string类型，但是传入的是char *类型，所以会把char *隐式转化成string变量，这个string变量就是临时变量，那uppercasify()函数内部如果对string操作的化也是对临时变量string进行操作而不是对subtleBookPlug变量进行操作，这样就会引起误操作了。所以不能使用非const引用接收临时变量，不仅没有意义还会引起误操作。</p>
<p>但是肯定非const引用可以接收局部变量的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uppercasify</span><span class="params">(<span class="built_in">string</span>&amp; str)</span> </span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> subtleBookPlug[] = <span class="string">&quot;Effective C++&quot;</span>;</span><br><span class="line"></span><br><span class="line"> uppercasify(subtleBookPlug);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是那句话，c++真的饶。</p>
<h2 id="记录自己利用智能指针和标准库写的单词索引程序"><a href="#记录自己利用智能指针和标准库写的单词索引程序" class="headerlink" title="记录自己利用智能指针和标准库写的单词索引程序"></a>记录自己利用智能指针和标准库写的单词索引程序</h2><p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TextQuery.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(fstream &amp;file)</span></span>&#123;</span><br><span class="line">    <span class="function">TextQuery <span class="title">textquery</span><span class="params">(file)</span></span>;</span><br><span class="line">    string user_string;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;plz input your word: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(cin&gt;&gt;user_string)||user_string==<span class="string">&quot;quit&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        QueryResult qr=textquery.<span class="built_in">query</span>(user_string);</span><br><span class="line">        <span class="built_in">print</span>(cout,qr)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fstream file;</span><br><span class="line">    file.<span class="built_in">open</span>(<span class="string">&quot;./2.txt&quot;</span>,ios::in);</span><br><span class="line">    <span class="keyword">if</span>(!file)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;open file fail&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">runQueries</span>(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TextQuery.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INC_1_TEXTQUERY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INC_1_TEXTQUERY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;QueryResult.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextQuery</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TextQuery</span>(std::fstream &amp;);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getword</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">QueryResult <span class="title">query</span><span class="params">(<span class="keyword">const</span> std::string)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file_context;</span><br><span class="line">    std::map&lt;std::string,std::shared_ptr&lt;std::set&lt;<span class="keyword">int</span>&gt;&gt;&gt; word;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//INC_1_TEXTQUERY_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TextQuery.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TextQuery.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TextQuery::<span class="built_in">TextQuery</span>(std::fstream &amp;file) &#123;</span><br><span class="line">    std::string tmp;</span><br><span class="line">    <span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;file_context=std::make_shared&lt;std::vector&lt;std::string&gt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(std::<span class="built_in">getline</span>(file,tmp))&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;file_context-&gt;<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="function">std::istringstream <span class="title">line</span><span class="params">(tmp)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(line&gt;&gt;tmp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;word.<span class="built_in">find</span>(tmp)==<span class="keyword">this</span>-&gt;word.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">auto</span> word_set= std::make_shared&lt;std::set&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">                word_set-&gt;<span class="built_in">insert</span>(cur);</span><br><span class="line">                <span class="keyword">this</span>-&gt;word.<span class="built_in">insert</span>(&#123;tmp,word_set&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> value=<span class="keyword">this</span>-&gt;word[tmp];</span><br><span class="line">                value-&gt;<span class="built_in">insert</span>(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TextQuery::getword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter=<span class="keyword">this</span>-&gt;word.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iter!=<span class="keyword">this</span>-&gt;word.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="keyword">auto</span> tmp=iter-&gt;second-&gt;<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(tmp!=iter-&gt;second-&gt;<span class="built_in">end</span>())&#123;</span><br><span class="line">            std::cout&lt;&lt;*tmp&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            tmp++;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;std::endl;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QueryResult <span class="title">TextQuery::query</span><span class="params">(std::string user_word)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> word_set=<span class="keyword">this</span>-&gt;word[user_word];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QueryResult</span>(user_word,word_set,<span class="keyword">this</span>-&gt;file_context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>QueryResult.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INC_1_QUERYRESULT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INC_1_QUERYRESULT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream &amp;os, QueryResult &amp;qr)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string word;</span><br><span class="line">    std::shared_ptr&lt;std::set&lt;<span class="keyword">int</span>&gt;&gt; word_set;</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file_count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">QueryResult</span>(std::string word,std::shared_ptr&lt;std::set&lt;<span class="keyword">int</span>&gt;&gt; word_set,std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file_count)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;word=word;</span><br><span class="line">        <span class="keyword">this</span>-&gt;word_set=word_set;</span><br><span class="line">        <span class="keyword">this</span>-&gt;file_count=file_count;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//INC_1_QUERYRESULT_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>QueryResult.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;QueryResult.h&quot;</span></span></span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream &amp;os,QueryResult &amp;qr)</span></span>&#123;</span><br><span class="line">    os&lt;&lt;qr.word&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;occurs &quot;</span>&lt;&lt;qr.word_set-&gt;<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; times&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">auto</span> iter=qr.word_set-&gt;<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iter!=qr.word_set-&gt;<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> line_num=*iter+<span class="number">1</span>;</span><br><span class="line">        os&lt;&lt;<span class="string">&quot;(line &quot;</span>&lt;&lt;line_num&lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;(*qr.file_count)[*iter]&lt;&lt;std::endl;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体来说不是很难，主要记录一下这些标准库的主要用法。</p>
<h2 id="拷贝构造函数的参数问题"><a href="#拷贝构造函数的参数问题" class="headerlink" title="拷贝构造函数的参数问题"></a>拷贝构造函数的参数问题</h2><p>拷贝构造函数的参数只能这个类的对象的引用不能是一个对象，因为当拷贝构造函数形参是一个对象时，那发生拷贝的时候就会调用拷贝构造函数，而拷贝构造函数也会发生拷贝，所以又会调用拷贝构造函数，这就造成了死循环了。这个拷贝构造函数永远没有办法调用成功。</p>
<p>注意参数不仅是引用，如果要使用容器对对象进行存储的话，必须得存在一个const引用的构造函数，原因应该还是非const引用没办法接收临时变量。</p>
<p>所以拷贝构造函数最好有两个版本，一个const引用一个非const引用（我的理解）。</p>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>编译器可以自动隐式的进行一步类型转换，但只能进行一步,比如下面代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="built_in">A</span>(string s);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(A a)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果这样<code>fun(&quot;123&quot;)</code>,就会发成错误，因为编译器只能自动隐式的进行一步类型转换，比如把字符串转换成string或者把string转换成class A,但是不能自动进行两步转化，<code>fun(&quot;123&quot;)</code>就是两步转化，正确的方式可以是这样<code>fun(string(&quot;123&quot;))</code>或者<code>fun(A(&quot;123&quot;))</code>。</p>
<p>这确实很方便，但是有时候程序员并不想进行这种自动转化，那就可以使用<strong>explicit</strong>进行限制，比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(string s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(A a)</span></span>;</span><br></pre></td></tr></table></figure>

<p>此时再调用<code>fun(string(&quot;123&quot;))</code>就会发生错误，因为禁止从string转化成class A了。</p>
<h2 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h2><p>拷贝初始化的时候会自动调用拷贝构造函数或者移动构造函数。</p>
<p>直接初始化和拷贝初始化还是有很大区别的，直接初始化指调用构造函数完成对象的初始化工作，拷贝初始化是指当对象发生拷贝的时候被动调用拷贝构造函数或者移动构造函数。</p>
<h2 id="拷贝构造函数和拷贝赋值运算符的区别"><a href="#拷贝构造函数和拷贝赋值运算符的区别" class="headerlink" title="拷贝构造函数和拷贝赋值运算符的区别"></a>拷贝构造函数和拷贝赋值运算符的区别</h2><p>主要区别就是他们调用的时机不同，比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;asd&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(A &amp;a)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;123&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp;)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;234&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A c=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那就是调用拷贝构造函数，输出123,那是因为此时是初始化一个对象的时候发生拷贝行为，就会调用拷贝构造函数</p>
<p>如果这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a,c;</span><br><span class="line">    c=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单纯的把一个已经初始化的对象赋值给另一个已经初始化的对象就会调用拷贝赋值运算符。</p>
<p>所以为了一个类的健壮性，建议两者都得有。</p>
<h2 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h2><p>c++太恐怖了，太多细节了。</p>
<h2 id="智能指针的简单实现"><a href="#智能指针的简单实现" class="headerlink" title="智能指针的简单实现"></a>智能指针的简单实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;,HasPtr &amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="keyword">int</span> i,<span class="keyword">const</span> string &amp;s= <span class="built_in">string</span>()):<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">string</span>(s)),<span class="built_in">i</span>(i),<span class="built_in">use</span>(<span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>))&#123;&#125;;</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="keyword">const</span> HasPtr &amp;hasptr):<span class="built_in">ptr</span>(hasptr.ptr),<span class="built_in">i</span>(hasptr.i),<span class="built_in">use</span>(hasptr.use)&#123;</span><br><span class="line">        *use++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">HasPtr</span>(HasPtr &amp;hasptr):<span class="built_in">ptr</span>(hasptr.ptr),<span class="built_in">i</span>(hasptr.i),<span class="built_in">use</span>(hasptr.use)&#123;</span><br><span class="line">        *use++;</span><br><span class="line">    &#125;;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;hasptr)&#123;</span><br><span class="line">        (*hasptr.use)++;</span><br><span class="line">        *use--;</span><br><span class="line">        <span class="keyword">if</span>(*use==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> use;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr=hasptr.ptr;</span><br><span class="line">        use=hasptr.use;</span><br><span class="line">        i=hasptr.i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(HasPtr &amp;hp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;hp.i)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">string&amp; <span class="title">getstring</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;ptr);</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">HasPtr</span>()&#123;</span><br><span class="line">        *use--;</span><br><span class="line">        <span class="keyword">if</span>(*use==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> use;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> *use;</span><br><span class="line">    string *ptr;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs,HasPtr &amp;rhs)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;hp swap&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">swap</span>(lhs.use,rhs.use);</span><br><span class="line">    <span class="built_in">swap</span>(lhs.ptr,rhs.ptr);</span><br><span class="line">    <span class="built_in">swap</span>(lhs.i,rhs.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const对象只能调用const成员函数"><a href="#const对象只能调用const成员函数" class="headerlink" title="const对象只能调用const成员函数"></a>const对象只能调用const成员函数</h2><p>因为要保证对象的const属性.</p>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p>标准库函数，能够显示调用对象的移动构造函数。</p>
<p>比如下面的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s1=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="function">string <span class="title">s2</span><span class="params">(move(s1))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是将s1移动到了s2,移动后s1依然可以正常析构，但是此时s1不再指向”123”的字符串了，s2将指向”123”的字符串。</p>
<h2 id="multiple-definition-多重定义问题"><a href="#multiple-definition-多重定义问题" class="headerlink" title="multiple definition 多重定义问题"></a>multiple definition 多重定义问题</h2><p>在c++中切记切记不要在头文件中定义全局变量或者函数，因为如果这个头文件被多个cpp文件引用绝对会爆multiple definition这个错。</p>
<p>如果在头文件中定义了变量（是定义不是声明），并分别在a.c和b.c中进行了引用，编译过程中这个变量的符号会同时包含在a.o和b.o中，导致链接失败，原因是C语言规定“一个变量可以多次声明但只能定义一次”，解决办法是在头文件中加上#ifndef X条件编译，使该变量只定义一次，但是这里又有一个问题，该解决办法只适用C而不适用C++，在C++中，即使在头文件中加了#ifndef X，链接错误同样会发生，原因是C++中#ifndef X的作用域<strong>仅在单个文件中</strong>，因此只要在.h中定义了变量并在不同.cpp中进行引用，链接时都会报重定义错误，再说得直白点，a.cpp和b.cpp都引用了条件编译的g.h，g.h的条件编译只能分别保证在a.cpp和b.cpp中不出现重复定义，但在链接a.o和b.o的过程中就会发现重复定义。</p>
<p>c++这样做我理解是更加细粒度变量的作用域，变量只属于某一个模块而不是整个程序，如果一个模块想使用另一个模块的某一个变量就得使用<code>extern</code>这个关键字</p>
<p>extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。要使用其他模块的变量只要在这个模块中使用<code>extern 变量声明</code>就可以了。</p>
<h2 id="StrVec简单实现"><a href="#StrVec简单实现" class="headerlink" title="StrVec简单实现"></a>StrVec简单实现</h2><p>.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INC_1_STRVEC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INC_1_STRVEC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StrVec</span>():<span class="built_in">elements</span>(<span class="literal">nullptr</span>),<span class="built_in">first_free</span>(<span class="literal">nullptr</span>),<span class="built_in">cap</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">    <span class="built_in">StrVec</span>(std::initializer_list&lt;std::string&gt;);</span><br><span class="line">    <span class="built_in">StrVec</span>(<span class="keyword">const</span> StrVec&amp;);</span><br><span class="line">    StrVec&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> StrVec&amp;);</span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> );</span><br><span class="line">    ~<span class="built_in">StrVec</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> std::string&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first_free-elements;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">capacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cap-elements;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::string* <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elements;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::string* <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first_free;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">size_t</span>,<span class="keyword">const</span> std::string&amp; s=std::string(<span class="string">&quot;&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> std::allocator&lt;std::string&gt; alloc;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chk_n_alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span>()==<span class="built_in">capacity</span>())&#123;</span><br><span class="line">            <span class="built_in">reallocate</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::pair&lt;std::string*,std::string*&gt; <span class="title">alloc_n_copy</span><span class="params">(<span class="keyword">const</span> std::string*,<span class="keyword">const</span> std::string*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reallocate</span><span class="params">()</span></span>;</span><br><span class="line">    std::string *elements;</span><br><span class="line">    std::string *first_free;</span><br><span class="line">    std::string *cap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//INC_1_STRVEC_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StrVec.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">std::allocator&lt;std::string&gt; StrVec::alloc;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::push_back</span><span class="params">(<span class="keyword">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">chk_n_alloc</span>();</span><br><span class="line">    alloc.<span class="built_in">construct</span>(first_free++,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;std::string *, std::string *&gt; <span class="title">StrVec::alloc_n_copy</span><span class="params">(<span class="keyword">const</span> std::string *b, <span class="keyword">const</span> std::string *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> data=alloc.<span class="built_in">allocate</span>(e-b);</span><br><span class="line">    <span class="keyword">return</span> &#123;data, std::<span class="built_in">uninitialized_copy</span>(b,e,data)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::free</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(elements)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p=first_free;p!=elements;)&#123;</span><br><span class="line">            alloc.<span class="built_in">destroy</span>(--p);</span><br><span class="line">        &#125;</span><br><span class="line">        alloc.<span class="built_in">deallocate</span>(elements,cap-elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">StrVec::<span class="built_in">StrVec</span>(<span class="keyword">const</span> StrVec &amp; strvec) &#123;</span><br><span class="line">    <span class="keyword">auto</span> newstrings= <span class="built_in">alloc_n_copy</span>(strvec.<span class="built_in">begin</span>(),strvec.<span class="built_in">end</span>());</span><br><span class="line">    elements=newstrings.first;</span><br><span class="line">    first_free=cap=newstrings.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(<span class="keyword">const</span> StrVec &amp;strvec) &#123;</span><br><span class="line">    <span class="keyword">auto</span> newstrings= <span class="built_in">alloc_n_copy</span>(strvec.<span class="built_in">begin</span>(),strvec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements=newstrings.first;</span><br><span class="line">    first_free=cap=newstrings.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::reallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> newvecsize=<span class="built_in">size</span>()? <span class="built_in">size</span>()*<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> newelement=alloc.<span class="built_in">allocate</span>(newvecsize);</span><br><span class="line">    <span class="keyword">auto</span> dest=newelement;</span><br><span class="line">    <span class="keyword">auto</span> src=elements;</span><br><span class="line">    <span class="keyword">while</span>(src!=first_free)&#123;</span><br><span class="line">        alloc.<span class="built_in">construct</span>(dest++,std::<span class="built_in">move</span>(*src++));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements=newelement;</span><br><span class="line">    first_free=dest;</span><br><span class="line">    cap=elements+newvecsize;</span><br><span class="line">&#125;</span><br><span class="line">StrVec::~<span class="built_in">StrVec</span>() &#123;</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::resize</span><span class="params">(<span class="keyword">size_t</span> newsize, <span class="keyword">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> newelement=alloc.<span class="built_in">allocate</span>(newsize);</span><br><span class="line">    <span class="keyword">auto</span> dest=newelement;</span><br><span class="line">    <span class="keyword">auto</span> src=elements;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(i&lt;newsize)&amp;&amp;(src!=first_free);i++)&#123;</span><br><span class="line">        alloc.<span class="built_in">construct</span>(dest++,std::<span class="built_in">move</span>(*src++));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements=newelement;</span><br><span class="line">    first_free=dest;</span><br><span class="line">    cap=elements+newsize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::reserve</span><span class="params">(<span class="keyword">size_t</span> newsize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(newsize&gt;<span class="built_in">capacity</span>())&#123;</span><br><span class="line">        <span class="built_in">resize</span>(newsize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">StrVec::<span class="built_in">StrVec</span>(std::initializer_list&lt;std::string&gt; lst) :<span class="built_in">elements</span>(<span class="literal">nullptr</span>),<span class="built_in">first_free</span>(<span class="literal">nullptr</span>),<span class="built_in">cap</span>(<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter=lst.<span class="built_in">begin</span>();iter!=lst.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">        <span class="built_in">push_back</span>(*iter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::string &amp;StrVec::<span class="keyword">operator</span>[](<span class="keyword">int</span> idx) &#123;</span><br><span class="line">    <span class="keyword">return</span> *(elements+idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="左值-右值-左值引用-右值引用"><a href="#左值-右值-左值引用-右值引用" class="headerlink" title="左值 右值 左值引用 右值引用"></a>左值 右值 左值引用 右值引用</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Jacky_Feng/article/details/120742414">(93条消息) 【C++】左值和右值、左值引用（&amp;）和右值引用（&amp;&amp;）_Jacky_Feng的博客-CSDN博客_c++ 左值右值&amp;&amp;的作用</a></p>
<p>比较有意思的点是右值引用变量是左值。所以不能把一个右值引用变量赋值给一个右值引用变量。因为右值引用变量是一个变量，在内存中有对应地址，所以他本身并不是一个右值，而是一个左值。</p>
<h2 id="类的小知识点总结"><a href="#类的小知识点总结" class="headerlink" title="类的小知识点总结"></a>类的小知识点总结</h2><ul>
<li><p>动态绑定就相当于多态，多态不仅可以通过指针来使用，还可以通过引用</p>
</li>
<li><p>虚函数也可以在自己的类中进行定义</p>
</li>
<li><p>析构函数是可以虚函数的，在基类中通常就应该定义一个虚析构函数。</p>
</li>
<li><p>任何构造函数之外的非静态函数都可以是虚函数。</p>
</li>
<li><p>派生类必须将继承而来的成员函数中需要覆盖的那些重新声明。</p>
</li>
<li><p>派生类如果是public继承了类，那他就只可以访问父类的公有成员和受保护成员0，不可以访问私有成员。</p>
</li>
<li><p>如果派生类的虚函数需要使用默认实参，基类和派生类中定义的默认实参最好一致，不然通过多态调用派生类的虚函数的时候，传入的默认参数是基类的默认参数。</p>
</li>
<li><p>派生类可以重写或者不重写基类的虚函数，但是纯虚函数派生类必须得重写，除非派生类也是一个抽象基类。</p>
</li>
<li><p>protected是publibc和private的中和产物，当使用protected修饰成员的时候，这个成员就是受保护成员，这个成员对于类的用户来说不可见，但是对类的派生类可见。        </p>
</li>
<li><p>对于访问权限和继承来说，有两个影响变量，可以通过三个角度来讨论，即类的使用者，类是实现者，类的派生类。解释起来有些麻烦，忘了还是直接看书吧，p542处.</p>
</li>
<li><p>派生类的作用域位于基类作用域之内，在如果调用类的某个成员函数时首先进行名字匹配，从这个类找起，如果这个类没有那就从这个类的父类找起，如果没有找见那就一直找到这个继承链的顶点，如果还没有找到那就报错，如果名字匹配上了，那就再进行类型检查，检查通过了就是合法调用。</p>
</li>
<li><p>比较有意思的是派生类不存在对基类的重载，如果派生类的变量或者函数的名字和基类重了那派生类就会隐藏基类的重名函数或者重名变量，那其实重名变量在内存中有两份了，必须得通过作用域运算符来强制访问，下面的代码就是很好的解释,值得注意的是名字查找优于类型查找，如果派生类中的成员函数只有名字和基类函数重名，类型完全不一样，派生类还是会隐藏基类的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>  c;</span><br><span class="line">    A()&#123;</span><br><span class="line">        c=<span class="number">14</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    B(<span class="keyword">int</span> c):c(c)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_c</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;A::c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">23</span>)</span></span>;</span><br><span class="line">    b.c=<span class="number">12</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b.c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    b.get_c();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b.c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果基类中有一个函数名的多个重载版本，在派生类中还想重载某一个版本，不能直接对其重载，原因上述已经说清楚了，可以使用using把所有的重载版本全部引入派生类中再进行重载。</p>
</li>
<li><p>一条经验准则，如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作。但是基类的虚析构函数是个例外。原因仔细想想也能明白，正常一个类需要析构函数是因为有自己管理的资源了，有自己管理的资源那就得考虑拷贝和赋值移动的时候到底该怎么处理，但是基类不一样，基类有析构函数是因为要为多态服务，他自己可能有资源可能没有，所以可以不必要有拷贝赋值移动操纵。</p>
</li>
<li><p>虚函数和多态是强绑定的，虚函数并不是说基类有虚函数，派生类就必须实现虚函数，这是错误的观点，虚函数我感觉就是完全为了多态服务，当基类的指针或者引用指向了派生类时，如果调用了虚函数，就会调用指向的对象的函数。所以如果派生类都有某个功能但是实现的方式不一样的话就可以标记成虚函数，除此之外就没必要了。 </p>
</li>
<li><p>当一个类中有了析构函数就不会合成移动操作，基类一定有析构函数，所以正常情况下一定没有合成的移动操作，这就会阻止派生类拥有自己的移动操作，所以如果派生类确实需要自己的移动操作，就需要在基类中显示的定义移动操作。</p>
</li>
<li><p>不管是移动，构造，还是拷贝，派生类都会在初始化列表中调用基类的对应函数，以此来移动，构造或者拷贝派生类中的基类部分，然后在函数体中移动，构造，或者拷贝派生类自己的部分。</p>
</li>
<li><p>在析构函数执行完之后，对象的成员会被隐式销毁，类似的，对象的基类部分也是隐式销毁，所以没必要在派生类的析构函数中调用基类的析构函数。</p>
</li>
<li><p>最后不要在基类的特殊函数中使用虚函数，因为如果是派生调用基类的特殊函数的时候基类的特殊函数里的虚函数就会执行派生类的虚函数版本，这会导致不可知的错误。如果需要使用的话最好指明虚函数版本。</p>
</li>
</ul>
<h2 id="第十五章-单词查询程序"><a href="#第十五章-单词查询程序" class="headerlink" title="第十五章 单词查询程序"></a>第十五章 单词查询程序</h2><p>通过这个练习让我更加深刻的理解了类的继承的实际意义，对于要处理某一类事情，这类事情又可以分成很多小类型的话，那就可以提取所有小类型的公共特性然后成为一个基类，这些小类型继承这些基类，如果这些小类型还可以再细分的话，再次对小类型的所有小类型提取共有特性成为一个基类，小类型的小类型继承这个基类，依次类推。</p>
<p>这么做我感觉最大的好处就是让整个继承体系条理分明，层次关系清晰，还减少了代码的冗余量。</p>
<p>要处理某一类事情不能直接使用我们构造的继承体系，因为最后派生类你改使用哪一个派生类呢，所以得再构造一个类来管理使用这个继承体系，这个类（即Query）就是这个继承体系的接口类，暴露了这个继承体系的接口又隐藏了整个继承体系。</p>
<p>下面是这个联系的代码</p>
<p>Query.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INC_1_QUERY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INC_1_QUERY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TextQuery.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query_base</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>~(<span class="keyword">const</span> Query &amp;);</span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> Query &amp;,<span class="keyword">const</span> Query &amp;);</span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>|(<span class="keyword">const</span> Query &amp;,<span class="keyword">const</span> Query &amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Query</span>(<span class="keyword">const</span> std::string &amp;s);</span><br><span class="line">    <span class="function">QueryResult <span class="title">eval</span><span class="params">(TextQuery &amp;t)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Query</span>(std::shared_ptr&lt;Query_base&gt; query) :<span class="built_in">q</span>(query)&#123;&#125;;</span><br><span class="line">    std::shared_ptr&lt;Query_base&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//INC_1_QUERY_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Query.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Query.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Query_base.h&quot;</span></span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os,<span class="keyword">const</span> Query &amp;query)&#123;</span><br><span class="line">    <span class="keyword">return</span> os&lt;&lt;query.<span class="built_in">rep</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QueryResult <span class="title">Query::eval</span><span class="params">(TextQuery &amp;t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;<span class="built_in">eval</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Query::rep</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;<span class="built_in">rep</span>();</span><br><span class="line">&#125;</span><br><span class="line">Query::<span class="built_in">Query</span>(<span class="keyword">const</span> std::string &amp;s):<span class="built_in">q</span>(<span class="keyword">new</span> <span class="built_in">WordQuery</span>(s))&#123;&#125;</span><br><span class="line"></span><br><span class="line">Query <span class="keyword">operator</span>~(<span class="keyword">const</span> Query &amp;q) &#123;</span><br><span class="line"><span class="comment">//    this-&gt;q=std::shared_ptr&lt;Query_base&gt;(new NotQuery(*this));</span></span><br><span class="line"><span class="comment">//    return *this;</span></span><br><span class="line">    <span class="keyword">return</span> std::shared_ptr&lt;Query_base&gt;(<span class="keyword">new</span> <span class="built_in">NotQuery</span>(q));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Query <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> Query &amp;l,<span class="keyword">const</span> Query &amp;r) &#123;</span><br><span class="line"><span class="comment">//    this-&gt;q=std::shared_ptr&lt;Query_base&gt;(new AndQuery(*this,r));</span></span><br><span class="line"><span class="comment">//    return *this;</span></span><br><span class="line">    <span class="keyword">return</span> std::shared_ptr&lt;Query_base&gt;(<span class="keyword">new</span> <span class="built_in">AndQuery</span>(l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Query <span class="keyword">operator</span>|(<span class="keyword">const</span> Query &amp;l,<span class="keyword">const</span> Query &amp;r) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::shared_ptr&lt;Query_base&gt;(<span class="keyword">new</span> <span class="built_in">OrQuery</span>(l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Query_base.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INC_1_QUERY_BASE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INC_1_QUERY_BASE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Query.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query_base</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Query_base</span>()=<span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QueryResult <span class="title">eval</span><span class="params">(TextQuery&amp;)</span> <span class="keyword">const</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordQuery</span>:</span><span class="keyword">public</span> Query_base&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>;</span></span><br><span class="line">    <span class="built_in">WordQuery</span>(<span class="keyword">const</span> std::string &amp;s) :<span class="built_in">query_word</span>(s)&#123;&#125;;</span><br><span class="line">    <span class="function">QueryResult <span class="title">eval</span><span class="params">(TextQuery &amp;t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">query</span>(query_word);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::string <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query_word;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::string query_word;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotQuery</span>:</span><span class="keyword">public</span> Query_base&#123;</span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>~(<span class="keyword">const</span> Query&amp;);</span><br><span class="line">    <span class="function">std::string  <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;~(&quot;</span>+query.<span class="built_in">rep</span>()+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">QueryResult <span class="title">eval</span><span class="params">(TextQuery &amp;t)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    Query query;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">NotQuery</span>(<span class="keyword">const</span> Query &amp;q): <span class="built_in">query</span>(q)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinareyQuery</span> :</span> <span class="keyword">public</span> Query_base&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">BinareyQuery</span>(<span class="keyword">const</span> Query &amp;l,<span class="keyword">const</span> Query &amp;r,<span class="keyword">const</span> std::string &amp;s):<span class="built_in">lhs</span>(l),<span class="built_in">rhs</span>(r),<span class="built_in">opSym</span>(s)&#123;&#125;;</span><br><span class="line">    <span class="function">std::string  <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span>+lhs.<span class="built_in">rep</span>()+<span class="string">&quot; &quot;</span>+opSym+<span class="string">&quot; &quot;</span>+rhs.<span class="built_in">rep</span>()+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Query lhs,rhs;</span><br><span class="line">    std::string opSym;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndQuery</span>:</span><span class="keyword">public</span> BinareyQuery&#123;</span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> Query &amp;,<span class="keyword">const</span> Query &amp;);</span><br><span class="line">    <span class="built_in">AndQuery</span>(<span class="keyword">const</span> Query &amp;l,<span class="keyword">const</span> Query &amp;r): <span class="built_in">BinareyQuery</span>(l,r,<span class="string">&quot;&amp;&quot;</span>)&#123;&#125;;</span><br><span class="line">    <span class="function">QueryResult <span class="title">eval</span><span class="params">(TextQuery&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrQuery</span>:</span><span class="keyword">public</span> BinareyQuery&#123;</span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>|(<span class="keyword">const</span> Query &amp;,<span class="keyword">const</span> Query &amp;);</span><br><span class="line">    <span class="built_in">OrQuery</span>(<span class="keyword">const</span> Query &amp;l,<span class="keyword">const</span> Query &amp;r): <span class="built_in">BinareyQuery</span>(l,r,<span class="string">&quot;|&quot;</span>)&#123;&#125;;</span><br><span class="line">    <span class="function">QueryResult <span class="title">eval</span><span class="params">(TextQuery&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//INC_1_QUERY_BASE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Query_base.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Query_base.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">QueryResult <span class="title">NotQuery::eval</span><span class="params">(TextQuery &amp;t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result=query.<span class="built_in">eval</span>(t);</span><br><span class="line">    <span class="keyword">auto</span> ret_lines= std::make_shared&lt;std::set&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">    <span class="keyword">auto</span> beg=result.begin,end=result.end;</span><br><span class="line">    <span class="keyword">auto</span> size=result.<span class="built_in">get_file</span>()-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n=<span class="number">0</span>;n!=size;n++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(beg==end|| *beg!=n)&#123;</span><br><span class="line">            ret_lines-&gt;<span class="built_in">insert</span>(n);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(beg!=end)&#123;</span><br><span class="line">            ++beg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QueryResult</span>(<span class="built_in">rep</span>(),ret_lines,result.<span class="built_in">get_file</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QueryResult <span class="title">OrQuery::eval</span><span class="params">(TextQuery &amp;test)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> letf=lhs.<span class="built_in">eval</span>(test);</span><br><span class="line">    <span class="keyword">auto</span> right=rhs.<span class="built_in">eval</span>(test);</span><br><span class="line">    <span class="keyword">auto</span> ret_lines=std::make_shared&lt;std::set&lt;<span class="keyword">int</span>&gt;&gt;(letf.begin,letf.end);</span><br><span class="line">    ret_lines-&gt;<span class="built_in">insert</span>(right.begin,right.end);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QueryResult</span>(<span class="built_in">rep</span>(),ret_lines,letf.<span class="built_in">get_file</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QueryResult <span class="title">AndQuery::eval</span><span class="params">(TextQuery &amp;test)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> letf=lhs.<span class="built_in">eval</span>(test);</span><br><span class="line">    <span class="keyword">auto</span> right=rhs.<span class="built_in">eval</span>(test);</span><br><span class="line">    <span class="keyword">auto</span> ret_lines=std::make_shared&lt;std::set&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">    std::<span class="built_in">set_intersection</span>(letf.begin,letf.end,right.begin,right.end,std::<span class="built_in">inserter</span>(*ret_lines,ret_lines-&gt;<span class="built_in">begin</span>()));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QueryResult</span>(<span class="built_in">rep</span>(),ret_lines,letf.<span class="built_in">get_file</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Query_base.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fstream file;</span><br><span class="line">    file.<span class="built_in">open</span>(<span class="string">&quot;./2.txt&quot;</span>,ios::in);</span><br><span class="line">    <span class="keyword">if</span>(!file)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;open file fail&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Query q=<span class="built_in">Query</span>(<span class="string">&quot;is&quot;</span>) &amp; <span class="built_in">Query</span>(<span class="string">&quot;that&quot;</span>)|<span class="built_in">Query</span>(<span class="string">&quot;serious&quot;</span>);</span><br><span class="line">    <span class="function">TextQuery <span class="title">textquery</span><span class="params">(file)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> res=q.<span class="built_in">eval</span>(textquery);</span><br><span class="line">    <span class="built_in">print</span>(cout,res)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20230204002217162.png" alt="image-20230204002217162"></p>
<h2 id="运算符类"><a href="#运算符类" class="headerlink" title="运算符类"></a>运算符类</h2><p>运算符类是对运算的一个扩展吧相当于，可以有如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;<span class="keyword">int</span>&gt; intadd;</span><br><span class="line"><span class="keyword">int</span> s=<span class="built_in">intadd</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>不再是直接使用运算符，而是做了一层封装，这么做的好处就是让运算更加适普。比如两个指针的<code>&lt;</code>操作，不能直接<code>p1&lt;p2</code>这会出问题，但是可以这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less&lt;<span class="keyword">char</span> *&gt; intptrless;</span><br><span class="line"><span class="keyword">bool</span> s=<span class="built_in">intptrless</span>(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;2324&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种运算符类是标准库提供的。</p>
<p>使用运算符类进行模板编程会更加类型无关和可移植性。</p>
<h2 id="关于模板函数要在头文件中进行定义的问题"><a href="#关于模板函数要在头文件中进行定义的问题" class="headerlink" title="关于模板函数要在头文件中进行定义的问题"></a>关于模板函数要在头文件中进行定义的问题</h2><p>之前讨论过普通变量或者普通函数能否在头文件中定义的问题，答案是否定的，这是非常愚蠢的行为，但是这条规则在模板编程中不适用，当编译器遇到一个模板定义的时候，他并不会生成代码，只有在当实例化模板的一个特定版本时，编译器才会生成代码，当我们使用而不是定义模板的时候，编译器才会生成代码，这一特性非常重要。假如有如下文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.cpp引用了add.h,当使用add(1,1)的时候就需要实例化一个add(int,int)的函数，模板就定义在头文件中，所以可以直接通过头文件实例化，但是如果只有定义在头文件中，而定义在cpp文件中，在链接期间就会报错了。如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数想要寻找add模板函数并且实例化的时候，发现头文件中只有声明，他就会认为这个函数会在add.cpp中进行实例化，到时候在链接期间进行链接就好了，但是在编译add.cpp这个模块的时候又没有使用add模板函数，也就不会给他实例化，导致最终链接期间，main模块想要链接add模块中的函数，但是add模块没有这个函数，导致链接错误。</p>
<p>那直接在头文件中定义一个模板函数会不会像在头文件中定义一个普通函数那样，在链接的时候爆多重定义的错误。答案是不会的，因为针对特定类型模板函数长的是一样的，所以如果多个模块中都有同一个特性类型的模板函数，那就会随机选择一个并使用。</p>
<h2 id="保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正常工作，是调用者的责任。"><a href="#保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正常工作，是调用者的责任。" class="headerlink" title="保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正常工作，是调用者的责任。"></a>保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正常工作，是调用者的责任。</h2><h2 id="typedef-using"><a href="#typedef-using" class="headerlink" title="typedef using"></a>typedef using</h2><p>typedef主要是起别名的关键字，using除了可以引入命名空间外，还可以起别名，而且还可以给模板起别名，但是typedef不能给模板起别名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = MyVector&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line">Vec&lt;<span class="keyword">int</span>&gt; vec;</span><br></pre></td></tr></table></figure>

<p>::作用域运算符</p>
<p>众所周知::可以所以类内的static成员或者类内定义的类型，对于一个非模板类来说，通过::引用的是类内的static成员还是类型很好判断，但是如果使用模板类型参数类的名字就不好判断了，在默认情况下c++假定通过::访问的名字不是类型，因此如果使用一个模板参数的类型成员，就得显示的通过关键字typename来实现，如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="keyword">const</span> T&amp; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!c.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typename</span> T::<span class="built_in">value_type</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板实例化声明和实例化定义"><a href="#模板实例化声明和实例化定义" class="headerlink" title="模板实例化声明和实例化定义"></a>模板实例化声明和实例化定义</h2><p>实例化声明语法如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这就是两个实例化声明，实例化声明是指别的模块中已经实例化了Blob<string>所以没必要在这个模块中再实例化一次，所以进行一个声明，在编译的时候就不会实例化了而是在别的模块中找到这个实例化模板。</p>
<p>实例化定义语法如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;</span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;,<span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>实例化定义是指在这个模块中根据模板实参实例化这个模板。此定义非彼定义。</p>
<p>对于每个实例化声明，在程序中的某个位置必须有其显示的实例化定义。</p>
<h2 id="将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换以及属猪或者函数指针的转换，但是如果函数参数类型不是模板参数，则对实参进行正常的类型转换。"><a href="#将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换以及属猪或者函数指针的转换，但是如果函数参数类型不是模板参数，则对实参进行正常的类型转换。" class="headerlink" title="将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换以及属猪或者函数指针的转换，但是如果函数参数类型不是模板参数，则对实参进行正常的类型转换。"></a>将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换以及属猪或者函数指针的转换，但是如果函数参数类型不是模板参数，则对实参进行正常的类型转换。</h2><h2 id="引用折叠和右值引用参数"><a href="#引用折叠和右值引用参数" class="headerlink" title="引用折叠和右值引用参数"></a>引用折叠和右值引用参数</h2><p>总结，如果一个函数参数是指向模板参数类型的右值引用，则可以传递给他任意类型的实参，如果将一个优质传递给这个的参数，则函数参数被实例化为一个普通的左值引用。</p>
<p>这个就是c++的例外，不过比较有意思的一点是模板参数可以推断为一个引用类型。</p>
<h2 id="显示的左值引用转化成右值引用"><a href="#显示的左值引用转化成右值引用" class="headerlink" title="显示的左值引用转化成右值引用"></a>显示的左值引用转化成右值引用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string t=<span class="string">&quot;qwe&quot;</span>;</span><br><span class="line">std::string &amp;&amp;s=static_const&lt;string&amp;&amp;&gt;(t);</span><br></pre></td></tr></table></figure>

<h2 id="可变参数函数模板"><a href="#可变参数函数模板" class="headerlink" title="可变参数函数模板"></a>可变参数函数模板</h2><p>利用递归一个一个处理参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os,<span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os&lt;&lt;t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os,<span class="keyword">const</span> T &amp;t,<span class="keyword">const</span> Args&amp;... rest)</span></span>&#123;</span><br><span class="line">    os&lt;&lt;t&lt;&lt;<span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os,rest...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(cout,<span class="number">2134</span>,<span class="number">3456</span>,<span class="string">&quot;asfd&quot;</span>,<span class="string">&quot;2134&quot;</span>,<span class="number">123.2345</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c-基础学习告一段落"><a href="#c-基础学习告一段落" class="headerlink" title="c++基础学习告一段落"></a>c++基础学习告一段落</h2>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/20/%E4%BD%8E%E7%89%88%E6%9C%AC-%E4%BD%8E%E4%BA%8E5-14-%E5%9F%BA%E4%BA%8Emsg%E4%B8%8Bdoublefree%E7%9A%84%E5%88%A9%E7%94%A8%E9%80%9A%E8%A7%A3/" rel="prev" title="低版本(低于5.14)基于msg下doublefree的利用通解">
      <i class="fa fa-chevron-left"></i> 低版本(低于5.14)基于msg下doublefree的利用通解
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/08/cve-2022-2588/" rel="next" title="cve-2022-2588">
      cve-2022-2588 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#c-study-tips"><span class="nav-number">1.</span> <span class="nav-text">c++ study tips</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E7%9B%B8%E5%BC%95%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">互相引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">指针类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">1.3.</span> <span class="nav-text">返回局部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.4.</span> <span class="nav-text">智能指针初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9Econst%E5%BC%95%E7%94%A8%E4%B8%8E%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.</span> <span class="nav-text">非const引用与临时变量问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E8%87%AA%E5%B7%B1%E5%88%A9%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93%E5%86%99%E7%9A%84%E5%8D%95%E8%AF%8D%E7%B4%A2%E5%BC%95%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.6.</span> <span class="nav-text">记录自己利用智能指针和标准库写的单词索引程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.</span> <span class="nav-text">拷贝构造函数的参数问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#explicit"><span class="nav-number">1.8.</span> <span class="nav-text">explicit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.9.</span> <span class="nav-text">拷贝初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.10.</span> <span class="nav-text">拷贝构造函数和拷贝赋值运算符的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E8%AE%B0"><span class="nav-number">1.11.</span> <span class="nav-text">小记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.12.</span> <span class="nav-text">智能指针的简单实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const%E5%AF%B9%E8%B1%A1%E5%8F%AA%E8%83%BD%E8%B0%83%E7%94%A8const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.13.</span> <span class="nav-text">const对象只能调用const成员函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-move"><span class="nav-number">1.14.</span> <span class="nav-text">std::move</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#multiple-definition-%E5%A4%9A%E9%87%8D%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98"><span class="nav-number">1.15.</span> <span class="nav-text">multiple definition 多重定义问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StrVec%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.16.</span> <span class="nav-text">StrVec简单实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC-%E5%8F%B3%E5%80%BC-%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">1.17.</span> <span class="nav-text">左值 右值 左值引用 右值引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93"><span class="nav-number">1.18.</span> <span class="nav-text">类的小知识点总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E5%8D%95%E8%AF%8D%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.19.</span> <span class="nav-text">第十五章 单词查询程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%B1%BB"><span class="nav-number">1.20.</span> <span class="nav-text">运算符类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E8%A6%81%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%B9%89%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.21.</span> <span class="nav-text">关于模板函数要在头文件中进行定义的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E4%BC%A0%E9%80%92%E7%BB%99%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E5%8F%82%E6%94%AF%E6%8C%81%E6%A8%A1%E6%9D%BF%E6%89%80%E8%A6%81%E6%B1%82%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BB%A5%E5%8F%8A%E8%BF%99%E4%BA%9B%E6%93%8D%E4%BD%9C%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%AD%E8%83%BD%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C%EF%BC%8C%E6%98%AF%E8%B0%83%E7%94%A8%E8%80%85%E7%9A%84%E8%B4%A3%E4%BB%BB%E3%80%82"><span class="nav-number">1.22.</span> <span class="nav-text">保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正常工作，是调用者的责任。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typedef-using"><span class="nav-number">1.23.</span> <span class="nav-text">typedef using</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AE%9A%E4%B9%89"><span class="nav-number">1.24.</span> <span class="nav-text">模板实例化声明和实例化定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E5%AE%9E%E5%8F%82%E4%BC%A0%E9%80%92%E7%BB%99%E5%B8%A6%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E6%97%B6%EF%BC%8C%E8%83%BD%E5%A4%9F%E8%87%AA%E5%8A%A8%E5%BA%94%E7%94%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%8F%AA%E6%9C%89const%E8%BD%AC%E6%8D%A2%E4%BB%A5%E5%8F%8A%E5%B1%9E%E7%8C%AA%E6%88%96%E8%80%85%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%8C%E4%BD%86%E6%98%AF%E5%A6%82%E6%9E%9C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8D%E6%98%AF%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%EF%BC%8C%E5%88%99%E5%AF%B9%E5%AE%9E%E5%8F%82%E8%BF%9B%E8%A1%8C%E6%AD%A3%E5%B8%B8%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%82"><span class="nav-number">1.25.</span> <span class="nav-text">将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换以及属猪或者函数指针的转换，但是如果函数参数类型不是模板参数，则对实参进行正常的类型转换。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-number">1.26.</span> <span class="nav-text">引用折叠和右值引用参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E7%9A%84%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E8%BD%AC%E5%8C%96%E6%88%90%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">1.27.</span> <span class="nav-text">显示的左值引用转化成右值引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.28.</span> <span class="nav-text">可变参数函数模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E5%91%8A%E4%B8%80%E6%AE%B5%E8%90%BD"><span class="nav-number">1.29.</span> <span class="nav-text">c++基础学习告一段落</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rootzhang</p>
  <div class="site-description" itemprop="description">我的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rootzhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
